This file has been translated from LaTeX by HeVeA.

Node: Subsection 6-9-3,	Next: Subsection 6-9-4,	Prev: Subsection 6-9-2,	Up: Section 6-9
  

6.9.3   Class definitions
=========================
   
  
  class-definition ::=  class class-binding  { and class-binding }             
                                                       
                                                                               
                                                       
          class-binding ::=  [virtual] [[ type-parameters ]]  class-name 
                  {parameter}  [: class-type]  =  class-expr 
                                                                               
                                                       
   type-parameters ::=  ' ident  { , ' ident }                                 
                                                       
                                                                               
                                                       
  
  A class definition class class-binding  { and class-binding } is recursive.
Each class-binding defines a class-name that can be used in the whole
expression except for inheritance. It can also be used for inheritance, but
only in the definitions that follow its own.
  A class binding binds the class name class-name to the value of expression
class-expr. It also binds the class type class-name to the type of the class,
and defines two type abbreviations : class-name and # class-name. The first one
is the type of objects of this class, while the second is more general as it
unifies with the type of any object belonging to a subclass (see
section 6.4*Note Section 6-4::).

Virtual class
-------------
  
 A class must be flagged virtual if one of its methods is
virtual (that is, appears in the class type, but is not actually defined).
Objects cannot be created from a virtual class.

Type parameters
---------------
  
  The class type parameters correspond to the ones of the class type and of the
two type abbreviations defined by the class binding. They must be bound to
actual types in the class definition using type constraints. So that the
abbreviations are well-formed, type variables of the inferred type of the class
must either be type parameters or be bound in the constraint clause.

Node: Subsection 6-9-4,	Next: Subsection 6-9-5,	Prev: Subsection 6-9-3,	Up: Section 6-9
  

6.9.4   Class specification
===========================
   
  
  class-specification ::=  class class-spec  { and class-spec }                
                                          
                                                                               
                                          
              class-spec ::=  [virtual] [[ type-parameters ]]  class-name : 
                                  class-type 
                                                                               
                                          
  
  This is the counterpart in signatures of class definitions. A class
specification matches a class definition if they have the same type parameters
and their types match.

Node: Subsection 6-9-5,	Next: Section 6-10,	Prev: Subsection 6-9-4,	Up: Section 6-9
  

6.9.5   Class type definitions
==============================
   
  

  classtype-definition ::=  class type classtype-def  { and classtype-def }    
                                             
                                                                               
                                             
           classtype-def ::=  [virtual] [[ type-parameters ]]  class-name = 
                               class-body-type 
                                                                               
                                             
  
  A class type definition class class-name =  class-body-type defines an
abbreviation class-name for the class body type class-body-type. As for class
definitions, two type abbreviations class-name and # class-name are also
defined. The definition can be parameterized by some type parameters. If any
method in the class type body is virtual, the definition must be flagged
virtual.
  Two class type definitions match if they have the same type parameters and
the types they expand to match.  

Node: Section 6-10,	Next: Subsection 6-10-1,	Prev: Section 6-9,	Up: Chapter 6
  

6.10   Module types (module specifications)
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  Module types are the module-level equivalent of type expressions: they
specify the general shape and type properties of modules.
  
  
  
  
     module-type ::=  modtype-path                                             
                                             
                  |   sig { specification  [;;] } end                          
                                             
                  |   functor ( module-name :  module-type ) ->  module-type   
                                             
                  |   module-type with  mod-constraint  { and mod-constraint } 
                                             
                  |   ( module-type )                                          
                                             
                                                                               
                                             
  mod-constraint ::=  type [type-parameters]  typeconstr =  typexpr            
                                             
                  |   module module-path =  extended-module-path               
                                             
                                                                               
                                             
   specification ::=  val value-name :  typexpr                                
                                             
                  |   external value-name :  typexpr =  external-declaration   
                                             
                  |   type-definition                                          
                                             
                  |   exception constr-decl                                    
                                             
                  |   class-specification                                      
                                             
                  |   classtype-definition                                     
                                             
                  |   module module-name :  module-type                        
                                             
                  |   module module-name  { ( module-name :  module-type ) } : 
                                 module-type 
                  |   module type modtype-name                                 
                                             
                  |   module type modtype-name =  module-type                  
                                             
                  |   open module-path                                         
                                             
                  |   include module-type                                      
                                             
                                                                               
                                             
  
* Menu:

* Subsection 6-10-1::	Simple module types
* Subsection 6-10-2::	Signatures
* Subsection 6-10-3::	Functor types
* Subsection 6-10-4::	The with operator


Node: Subsection 6-10-1,	Next: Subsection 6-10-2,	Prev: Section 6-10,	Up: Section 6-10
  

6.10.1   Simple module types
============================
  
  The expression modtype-path is equivalent to the module type bound to the
name modtype-path. The expression ( module-type ) denotes the same type as
module-type.

Node: Subsection 6-10-2,	Next: Subsection 6-10-3,	Prev: Subsection 6-10-1,	Up: Section 6-10
  

6.10.2   Signatures
===================
  
 
  Signatures are type specifications for structures. Signatures sig ... end are
collections of type specifications for value names, type names, exceptions,
module names and module type names. A structure will match a signature if the
structure provides definitions (implementations) for all the names specified in
the signature (and possibly more), and these definitions meet the type
requirements given in the signature.
  For compatibility with Caml Light, an optional ;; is allowed after each
specification in a signature. The ;; has no semantic meaning.

Value specifications
--------------------
  

  A specification of a value component in a signature is written val value-name
:  typexpr, where value-name is the name of the value and typexpr its expected
type.

  The form external value-name :  typexpr =  external-declaration is similar,
except that it requires in addition the name to be implemented as the external
function specified in external-declaration (see
chapter 18*Note Chapter 18::).

Type specifications
-------------------
  

  A specification of one or several type components in a signature is written
type typedef  { and typedef } and consists of a sequence of mutually recursive
definitions of type names.
  Each type definition in the signature specifies an optional type equation =
typexpr and an optional type representation  = constr-decl ... or = {
field-decl ... }. The implementation of the type name in a matching structure
must be compatible with the type expression specified in the equation (if
given), and have the specified representation (if given). Conversely, users of
that signature will be able to rely on the type equation or type
representation, if given. More precisely, we have the following four
situations:
  
  
 Abstract type: no equation, no representation.
 Names that are defined as abstract types in a signature can be implemented in
   a matching structure by any kind of type definition (provided it has the
   same number of type parameters). The exact implementation of the type will
   be hidden to the users of the structure. In particular, if the type is
   implemented as a variant type or record type, the associated constructors
   and fields will not be accessible to the users; if the type is implemented
   as an abbreviation, the type equality between the type name and the
   right-hand side of the abbreviation will be hidden from the users of the
   structure. Users of the structure consider that type as incompatible with
   any other type: a fresh type has been generated.
 
 Type abbreviation: an equation = typexpr, no representation.
 The type name must be implemented by a type compatible with typexpr. All users
   of the structure know that the type name is compatible with typexpr.
 
 New variant type or record type: no equation, a representation.
 The type name must be implemented by a variant type or record type with
   exactly the constructors or fields specified. All users of the structure
   have access to the constructors or fields, and can use them to create or
   inspect values of that type. However, users of the structure consider that
   type as incompatible with any other type: a fresh type has been generated.
 
 Re-exported variant type or record type: an equation, a representation.
 This case combines the previous two: the representation of the type is made
   visible to all users, and no fresh type is generated. 
  

Exception specification
-----------------------
  

  The specification exception constr-decl in a signature requires the matching
structure to provide an exception with the name and arguments specified in the
definition, and makes the exception available to all users of the structure.

Class specifications
--------------------
  

  A specification of one or several classes in a signature is written class
class-spec  { and class-spec } and consists of a sequence of mutually recursive
definitions of class names.
  Class specifications are described more precisely in
section 6.9.4*Note Subsection 6-9-4::.

Class type specifications
-------------------------
  
 
  A specification of one or several classe types in a signature is written
class type classtype-def { and classtype-def } and consists of a sequence of
mutually recursive definitions of class type names. Class type specifications
are described more precisely in section 6.9.5*Note Subsection 6-9-5::.

Module specifications
---------------------
  

  A specification of a module component in a signature is written module
module-name :  module-type, where module-name is the name of the module
component and module-type its expected type. Modules can be nested arbitrarily;
in particular, functors can appear as components of structures and functor
types as components of signatures.
  For specifying a module component that is a functor, one may write 
         module module-name (  name_1 :  module-type_1 ) ... (  name_n :
                        module-type_n ) :  module-type 
   instead of 
       module module-name : functor (  name_1 :  module-type_1 ) -> ... ->
                                  module-type 
  

Module type specifications
--------------------------
  
 
  A module type component of a signature can be specified either as a manifest
module type or as an abstract module type.
  An abstract module type specification module type modtype-name allows the
name modtype-name to be implemented by any module type in a matching signature,
but hides the implementation of the module type to all users of the signature.
  A manifest module type specification module type modtype-name =  module-type
requires the name modtype-name to be implemented by the module type module-type
in a matching signature, but makes the equality between modtype-name and
module-type apparent to all users of the signature.
  

 Opening a module path
----------------------
  

  The expression open module-path in a signature does not specify any
components. It simply affects the parsing of the following items of the
signature, allowing components of the module denoted by module-path to be
referred to by their simple names name instead of path accesses module-path .
 name. The scope of the open stops at the end of the signature expression.
  

 Including a signature
----------------------
  

  The expression include module-type in a signature performs textual inclusion
of the components of the signature denoted by module-type. It behaves as if the
components of the included signature were copied at the location of the
include. The module-type argument must refer to a module type that is a
signature, not a functor type.

Node: Subsection 6-10-3,	Next: Subsection 6-10-4,	Prev: Subsection 6-10-2,	Up: Section 6-10
  

6.10.3   Functor types
======================
  

  The module type expression  functor ( module-name :  module-type_1 ) ->
 module-type_2  is the type of functors (functions from modules to modules)
that take as argument a module of type module-type_1 and return as result a
module of type module-type_2. The module type module-type_2 can use the name
module-name to refer to type components of the actual argument of the functor.
No restrictions are placed on the type of the functor argument; in particular,
a functor may take another functor as argument ("higher-order" functor).

Node: Subsection 6-10-4,	Next: Section 6-11,	Prev: Subsection 6-10-3,	Up: Section 6-10
  

6.10.4   The with operator
==========================
  

  Assuming module-type denotes a signature, the expression module-type with
 mod-constraint { and mod-constraint } denotes the same signature where type
equations have been added to some of the type specifications, as described by
the constraints following the with keyword. The constraint type
[type-parameters]  typeconstr =  typexpr adds the type equation = typexpr to
the specification of the type component named typeconstr of the constrained
signature. The constraint module module-path =  extended-module-path adds type
equations to all type components of the sub-structure denoted by module-path,
making them equivalent to the corresponding type components of the structure
denoted by extended-module-path.
  For instance, if the module type name S is bound to the signature 
<<        sig type t module M: (sig type u end) end
>>
  then S with type t=int denotes the signature 
<<        sig type t=int module M: (sig type u end) end
>>
  and S with module M = N denotes the signature 
<<        sig type t module M: (sig type u=N.u end) end
>>
  A functor taking two arguments of type S that share their t component is
written 
<<        functor (A: S) (B: S with type t = A.t) ...
>>
  
  Constraints are added left to right. After each constraint has been applied,
the resulting signature must be a subtype of the signature before the
constraint was applied. Thus, the with operator can only add information on the
type components of a signature, but never remove information.  

Node: Section 6-11,	Next: Subsection 6-11-1,	Prev: Section 6-10,	Up: Chapter 6
  

6.11   Module expressions (module implementations)
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  Module expressions are the module-level equivalent of value expressions: they
evaluate to modules, thus providing implementations for the specifications
expressed in module types.
  
  
  
 
  module-expr ::=  module-path                                                 
                                                      
               |   struct { definition  [;;] |  expr ;; } end                  
                                                      
               |   functor ( module-name :  module-type ) ->  module-expr      
                                                      
               |   module-expr (  module-expr )                                
                                                      
               |   ( module-expr )                                             
                                                      
               |   ( module-expr :  module-type )                              
                                                      
                                                                               
                                                      
   definition ::=  let [rec] let-binding   { and let-binding }                 
                                                      
               |   external value-name :  typexpr =  external-declaration      
                                                      
               |   type-definition                                             
                                                      
               |   exception-definition                                        
                                                      
               |   class-definition                                            
                                                      
               |   classtype-definition                                        
                                                      
               |   module module-name  { ( module-name :  module-type ) }  [ :
                        module-type ]  =  module-expr 
               |   module type modtype-name =  module-type                     
                                                      
               |   open module-path                                            
                                                      
               |   include module-expr                                         
                                                      
  
* Menu:

* Subsection 6-11-1::	Simple module expressions
* Subsection 6-11-2::	Structures
* Subsection 6-11-3::	Functors


Node: Subsection 6-11-1,	Next: Subsection 6-11-2,	Prev: Section 6-11,	Up: Section 6-11
  

6.11.1   Simple module expressions
==================================
  
  The expression module-path evaluates to the module bound to the name
module-path.
  The expression ( module-expr ) evaluates to the same module as module-expr.
  The expression ( module-expr :  module-type ) checks that the type of
module-expr is a subtype of module-type, that is, that all components specified
in module-type are implemented in module-expr, and their implementation meets
the requirements given in module-type. In other terms, it checks that the
implementation module-expr meets the type specification module-type. The whole
expression evaluates to the same module as module-expr, except that all
components not specified in module-type are hidden and can no longer be
accessed.

Node: Subsection 6-11-2,	Next: Subsection 6-11-3,	Prev: Subsection 6-11-1,	Up: Section 6-11
  

6.11.2   Structures
===================
  
 
  Structures struct ... end are collections of definitions for value names,
type names, exceptions, module names and module type names. The definitions are
evaluated in the order in which they appear in the structure. The scope of the
bindings performed by the definitions extend to the end of the structure. As a
consequence, a definition may refer to names bound by earlier definitions in
the same structure.
  For compatibility with toplevel phrases (chapter 9*Note Chapter 9::)
and with Caml Light, an optional ;; is allowed after each definition in a
structure. The ;; has no semantic meaning. Also for compatibility, expr ;; is
allowed as a component of a structure, meaning let _ = expr, i.e. evaluate expr
for its side-effects. In this case, the ;; of the previous component is not
optional.

Value definitions
-----------------
  

  A value definition let [rec] let-binding  { and let-binding } bind value
names in the same way as a let ... in ... expression (see
section 6.7.1*Note Subsection 6-7-1::). The value names appearing in the
left-hand sides of the bindings are bound to the corresponding values in the
right-hand sides.

  A value definition external value-name :  typexpr =  external-declaration
implements value-name as the external function specified in
external-declaration (see chapter 18*Note Chapter 18::).

Type definitions
----------------
  

  A definition of one or several type components is written type typedef  { and
typedef } and consists of a sequence of mutually recursive definitions of type
names.

Exception definitions
---------------------
  

  Exceptions are defined with the syntax exception constr-decl or exception
constr-name =  constr.

Class definitions
-----------------
  

  A definition of one or several classes is written class class-binding  { and
class-binding } and consists of a sequence of mutually recursive definitions of
class names. Class definitions are described more precisely in
section 6.9.3*Note Subsection 6-9-3::.

Class type definitions
----------------------
  
 
  A definition of one or several classes is written class type classtype-def  {
and classtype-def } and consists of a sequence of mutually recursive
definitions of class type names. Class type definitions are described more
precisely in section 6.9.5*Note Subsection 6-9-5::.

Module definitions
------------------
  

  The basic form for defining a module component is module module-name =
 module-expr, which evaluates module-expr and binds the result to the name
module-name.
  One can write 
                module module-name :  module-type =  module-expr 
   instead of 
              module module-name = (  module-expr :  module-type ). 
   Another derived form is 
         module module-name (  name_1 :  module-type_1 ) ... (  name_n :
                        module-type_n ) =  module-expr 
   which is equivalent to 
       module module-name = functor (  name_1 :  module-type_1 ) -> ... ->
                                  module-expr 
  

Module type definitions
-----------------------
  
 
  A definition for a module type is written module type modtype-name =
 module-type. It binds the name modtype-name to the module type denoted by the
expression module-type.

Opening a module path
---------------------
  

  The expression open module-path in a structure does not define any components
nor perform any bindings. It simply affects the parsing of the following items
of the structure, allowing components of the module denoted by module-path to
be referred to by their simple names name instead of path accesses module-path
.  name. The scope of the open stops at the end of the structure expression.

Including the components of another structure
---------------------------------------------
  

  The expression include  module-expr in a structure re-exports in the current
structure all definitions of the structure denoted by module-expr. For
instance, if the identifier S is bound to the module 
<<        struct type t = int  let x = 2 end
>>
  the module expression 
<<        struct include S  let y = (x + 1 : t) end
>>
  is equivalent to the module expression 
<<        struct type t = int  let x = 2  let y = (x + 1 : t) end
>>
  The difference between open and include is that open simply provides short
names for the components of the opened structure, without defining any
components of the current structure, while include also adds definitions for
the components of the included structure.

Node: Subsection 6-11-3,	Next: Section 6-12,	Prev: Subsection 6-11-2,	Up: Section 6-11
  

6.11.3   Functors
=================
  

Functor definition
------------------
  

  The expression functor ( module-name :  module-type ) ->  module-expr
evaluates to a functor that takes as argument modules of the type
module-type_1, binds module-name to these modules, evaluates module-expr in the
extended environment, and returns the resulting modules as results. No
restrictions are placed on the type of the functor argument; in particular, a
functor may take another functor as argument ("higher-order" functor).

Functor application
-------------------
  
  The expression module-expr_1 (  module-expr_2 ) evaluates module-expr_1 to a
functor and module-expr_2 to a module, and applies the former to the latter.
The type of module-expr_2 must match the type expected for the arguments of the
functor module-expr_1.
   

Node: Section 6-12,	Next: Chapter 7,	Prev: Section 6-11,	Up: Chapter 6
  

6.12   Compilation units
*=*=*=*=*=*=*=*=*=*=*=*=

   
                     unit-interface ::=  { specification  [;;] } 
                                                                 
                unit-implementation ::=  { definition  [;;] }    
  
  Compilation units bridge the module system and the separate compilation
system. A compilation unit is composed of two parts: an interface and an
implementation. The interface contains a sequence of specifications, just as
the inside of a sig ... end signature expression. The implementation contains a
sequence of definitions, just as the inside of a struct ... end module
expression. A compilation unit also has a name unit-name, derived from the
names of the files containing the interface and the implementation (see
chapter 8*Note Chapter 8:: for more details). A compilation unit behaves
roughly as the module definition 
   module unit-name : sig  unit-interface end = struct  unit-implementation end

  A compilation unit can refer to other compilation units by their names, as if
they were regular modules. For instance, if U is a compilation unit that
defines a type t, other compilation units can refer to that type under the name
U.t; they can also refer to U as a whole structure. Except for names of other
compilation units, a unit interface or unit implementation must not have any
other free variables. In other terms, the type-checking and compilation of an
interface or implementation proceeds in the initial environment 
    name_1 : sig  specification_1 end ...  name_n : sig  specification_n end 
   where name_1 ...  name_n are the names of the other compilation units
available in the search path (see chapter 8*Note Chapter 8:: for more
details) and specification_1 ...  specification_n are their respective
interfaces.   

Node: Chapter 7,	Next: Section 7-1,	Prev: Chapter 6,	Up: Part II
  

Chapter 7     Language extensions
*********************************
    
  This chapter describes language extensions and convenience features that are
implemented in Objective Caml, but not described in the Objective Caml
reference manual.
* Menu:

* Section 7-1::	Integer literals for types int32, int64 and nativeint
* Section 7-2::	Streams and stream parsers
* Section 7-3::	Recursive definitions of values
* Section 7-4::	Range patterns
* Section 7-5::	Assertion checking
* Section 7-6::	Lazy evaluation
* Section 7-7::	Local modules
* Section 7-8::	Recursive modules
* Section 7-9::	Private types
* Section 7-10::	Local opens
* Section 7-11::	Record notations
* Section 7-12::	Explicit polymorphic type annotations
* Section 7-13::	Explicit naming of type variables
* Section 7-14::	First-class modules
* Section 7-15::	Recovering the type of a module
* Section 7-16::	Substituting inside a signature
* Section 7-17::	Explicit overriding in class definitions


Node: Section 7-1,	Next: Section 7-2,	Prev: Chapter 7,	Up: Chapter 7
  

7.1   Integer literals for types int32, int64 and nativeint
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

  
  (Introduced in OCaml 3.07)
                        int32-literal ::=  integer-literal l 
                                                             
                        int64-literal ::=  integer-literal L 
                                                             
                    nativeint-literal ::=  integer-literal n 
   An integer literal can be followed by one of the letters l, L or n to
indicate that this integer has type int32, int64 or nativeint respectively,
instead of the default type int for integer literals. 
  The library modules Int32[], Int64[] and
Nativeint[] provide operations on these integer types.

Node: Section 7-2,	Next: Section 7-3,	Prev: Section 7-1,	Up: Chapter 7
  

7.2   Streams and stream parsers
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  (Removed in OCaml 3.03)
  The syntax for streams and stream parsers is no longer part of the Objective
Caml language, but available through a Camlp4 syntax extension. See the Camlp4
reference manual for more information. Support for basic operations on streams
is still available through the Stream[] module of the standard library.
Objective Caml programs that use the stream parser syntax should be compiled
with the -pp camlp4o option to ocamlc and ocamlopt. For interactive use, run
ocaml and issue the '#load "camlp4o.cma";;' command.

Node: Section 7-3,	Next: Section 7-4,	Prev: Section 7-2,	Up: Chapter 7
  

7.3   Recursive definitions of values
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  (Introduced in OCaml 1.00)
  As mentioned in section 6.7.1*Note Subsection 6-7-1::, the let rec binding
construct, in addition to the definition of recursive functions, also supports
a certain class of recursive definitions of non-functional values, such as 
        let rec name_1 = 1 ::  name_2 and  name_2 = 2 ::  name_1 in  expr 
   which binds name_1 to the cyclic list 1::2::1::2::..., and name_2 to the
cyclic list 2::1::2::1::...Informally, the class of accepted definitions
consists of those definitions where the defined names occur only inside
function bodies or as argument to a data constructor.
  More precisely, consider the expression: 
         let rec name_1 =  expr_1 and ... and  name_n =  expr_n in  expr 
   It will be accepted if each one of expr_1 ...  expr_n is statically
constructive with respect to name_1 ...  name_n, is not immediately linked to
any of name_1 ...  name_n, and is not an array constructor whose arguments have
abstract type.
  An expression e is said to be statically constructive with respect to the
variables name_1 ...  name_n if at least one of the following conditions is
true: 
  
   - e has no free occurrence of any of name_1 ...  name_n 
   - e is a variable 
   - e has the form fun ... -> ... 
   - e has the form function ... -> ... 
   - e has the form lazy ( ... ) 
   - e has one of the following forms, where each one of expr_1 ...  expr_m is
   statically constructive with respect to name_1 ...  name_n, and expr_0 is
   statically constructive with respect to name_1 ...  name_n,  xname_1 ...
    xname_m: 
     
      - let [rec] xname_1 =  expr_1 and ... and  xname_m =  expr_m in  expr_0 
      - let module ... in expr_1 
      - constr ( expr_1, ... ,  expr_m) 
      - `tag-name ( expr_1, ... ,  expr_m) 
      - [| expr_1; ... ;  expr_m |] 
      - { field_1 =  expr_1; ... ;  field_m =  expr_m } 
      - { expr_1 with  field_2 =  expr_2; ... ;  field_m =  expr_m } where
      expr_1 is not immediately linked to name_1 ...  name_n 
      - ( expr_1, ... ,  expr_m ) 
      - expr_1; ... ;  expr_m 
  
  
  An expression e is said to be immediately linked to the variable name in the
following cases: 
  
   - e is name 
   - e has the form expr_1; ... ;  expr_m where expr_m is immediately linked to
   name 
   - e has the form let [rec] xname_1 =  expr_1 and ... and  xname_m =  expr_m
   in  expr_0 where expr_0 is immediately linked to name or to one of the
   xname_i such that expr_i is immediately linked to name. 
  

Node: Section 7-4,	Next: Section 7-5,	Prev: Section 7-3,	Up: Chapter 7
  

7.4   Range patterns
*=*=*=*=*=*=*=*=*=*=

  
  (Introduced in OCaml 1.00)
  In patterns, Objective Caml recognizes the form ' c ' .. ' d ' (two character
literals separated by ..) as shorthand for the pattern 
                ' c ' | ' c_1 ' | ' c_2 ' | ... | ' c_n ' | ' d ' 
   where c_1, c_2, ..., c_n are the characters that occur between c and d in
the ASCII character set. For instance, the pattern '0'..'9' matches all
characters that are digits.

Node: Section 7-5,	Next: Section 7-6,	Prev: Section 7-4,	Up: Chapter 7
  

7.5   Assertion checking
*=*=*=*=*=*=*=*=*=*=*=*=

   
  (Introduced in OCaml 1.06)
  Objective Caml supports the assert construct to check debugging assertions.
The expression assert expr evaluates the expression expr and returns () if expr
evaluates to true. Otherwise, the exception Assert_failure is raised with the
source file name and the location of expr as arguments. Assertion checking can
be turned off with the -noassert compiler option.
  As a special case, assert false is reduced to raise (Assert_failure ...),
which is polymorphic (and is not turned off by the -noassert option).


Node: Section 7-6,	Next: Section 7-7,	Prev: Section 7-5,	Up: Chapter 7
  

7.6   Lazy evaluation
*=*=*=*=*=*=*=*=*=*=*

   
  (Introduced in OCaml 1.06 for expressions; in OCaml 3.11 for patterns)
  The expression lazy expr returns a value v of type Lazy.t that encapsulates
the computation of expr. The argument expr is not evaluated at this point in
the program. Instead, its evaluation will be performed the first time
Lazy.force is applied to the value v, returning the actual value of expr.
Subsequent applications of Lazy.force to v do not evaluate expr again.
Applications of Lazy.force may be implicit through pattern matching.
  The pattern lazy pattern matches values v of type Lazy.t, provided pattern
matches the result of forcing v with Lazy.force. A successful match of a
pattern containing lazy sub-patterns forces the corresponding parts of the
value being matched, even those that imply no test such as lazy value-name or
lazy _. Matching a value with a pattern-matching where some patterns contain
lazy sub-patterns may imply forcing parts of the value, even when the pattern
selected in the end has no lazy sub-pattern.
  For more information, see the description of module Lazy in the standard
library (see section 20.15*Note Section 20-15::). 

Node: Section 7-7,	Next: Section 7-8,	Prev: Section 7-6,	Up: Chapter 7
  

7.7   Local modules
*=*=*=*=*=*=*=*=*=*

    
  (Introduced in OCaml 2.00)
  The expression let module module-name =  module-expr in  expr locally binds
the module expression module-expr to the identifier module-name during the
evaluation of the expression expr. It then returns the value of expr. For
example: 
<<        let remove_duplicates comparison_fun string_list =
            let module StringSet =
              Set.Make(struct type t = string
                              let compare = comparison_fun end) in
            StringSet.elements
              (List.fold_right StringSet.add string_list StringSet.empty)
>>
  

Node: Section 7-8,	Next: Section 7-9,	Prev: Section 7-7,	Up: Chapter 7
  

7.8   Recursive modules
*=*=*=*=*=*=*=*=*=*=*=*

     
  (Introduced in OCaml 3.07)
     definition ::=  ...                                                       
                                                              
                  |   module rec module-name :  module-type =  module-expr   {
                and module-name:  module-type =  module-expr } 
                                                                               
                                                              
  specification ::=  ...                                                       
                                                              
                 |   module rec module-name :  module-type  { and module-name: 
                 module-type }                                
  
  Recursive module definitions, introduced by the 'module rec' ...'and' ...
construction, generalize regular module definitions module module-name =
 module-expr and module specifications module module-name :  module-type by
allowing the defining module-expr and the module-type to refer recursively to
the module identifiers being defined. A typical example of a recursive module
definition is: 
<<    module rec A : sig
                       type t = Leaf of string | Node of ASet.t
                       val compare: t -> t -> int
                     end
                   = struct
                       type t = Leaf of string | Node of ASet.t
                       let compare t1 t2 =
                         match (t1, t2) with
                           (Leaf s1, Leaf s2) -> Pervasives.compare s1 s2
                         | (Leaf _, Node _) -> 1
                         | (Node _, Leaf _) -> -1
                         | (Node n1, Node n2) -> ASet.compare n1 n2
                     end
          and ASet : Set.S with type elt = A.t
                   = Set.Make(A)
>>
  It can be given the following specification: 
<<    module rec A : sig
                       type t = Leaf of string | Node of ASet.t
                       val compare: t -> t -> int
                     end
          and ASet : Set.S with type elt = A.t
>>
  
  This is an experimental extension of Objective Caml: the class of recursive
definitions accepted, as well as its dynamic semantics are not final and
subject to change in future releases.
  Currently, the compiler requires that all dependency cycles between the
recursively-defined module identifiers go through at least one "safe" module. A
module is "safe" if all value definitions that it contains have function types
typexpr_1 ->  typexpr_2. Evaluation of a recursive module definition proceeds
by building initial values for the safe modules involved, binding all
(functional) values to fun _ -> raise Undefined_recursive_module. The defining
module expressions are then evaluated, and the initial values for the safe
modules are replaced by the values thus computed. If a function component of a
safe module is applied during this computation (which corresponds to an
ill-founded recursive definition), the Undefined_recursive_module exception is
raised.

Node: Section 7-9,	Next: Subsection 7-9-1,	Prev: Section 7-8,	Up: Chapter 7
  

7.9   Private types
*=*=*=*=*=*=*=*=*=*

   
  Private type declarations in module signatures, of the form  type t = private
..., enable libraries to reveal some, but not all aspects of the implementation
of a type to clients of the library. In this respect, they strike a middle
ground between abstract type declarations, where no information is revealed on
the type implementation, and data type definitions and type abbreviations,
where all aspects of the type implementation are publicized. Private type
declarations come in three flavors: for variant and record types
(section 7.9.1*Note Subsection 7-9-1::), for type abbreviations
(section 7.9.2*Note Subsection 7-9-2::), and for row types
(section 7.9.3*Note Subsection 7-9-3::).
* Menu:

* Subsection 7-9-1::	Private variant and record types
* Subsection 7-9-2::	Private type abbreviations
* Subsection 7-9-3::	Private row types


Node: Subsection 7-9-1,	Next: Subsection 7-9-2,	Prev: Section 7-9,	Up: Section 7-9
  

7.9.1   Private variant and record types
========================================
   
  (Introduced in OCaml 3.07)
      type-representation ::=  ...                                        
                           |   = private constr-decl  { | constr-decl }   
                           |   = private { field-decl  { ; field-decl } } 
   Values of a variant or record type declared private can be de-structured
normally in pattern-matching or via the expr .  field notation for record
accesses. However, values of these types cannot be constructed directly by
constructor application or record construction. Moreover, assignment on a
mutable field of a private record type is not allowed.
  The typical use of private types is in the export signature of a module, to
ensure that construction of values of the private type always go through the
functions provided by the module, while still allowing pattern-matching outside
the defining module. For example: 
<<        module M : sig
                       type t = private A | B of int
                       val a : t
                       val b : int -> t
                     end
                   = struct
                       type t = A | B of int
                       let a = A
                       let b n = assert (n > 0); B n
                     end
>>
  Here, the private declaration ensures that in any value of type M.t, the
argument to the B constructor is always a positive integer.
  With respect to the variance of their parameters, private types are handled
like abstract types. That is, if a private type has parameters, their variance
is the one explicitly given by prefixing the parameter by a `+' or a `-', it is
invariant otherwise.

Node: Subsection 7-9-2,	Next: Subsection 7-9-3,	Prev: Subsection 7-9-1,	Up: Section 7-9
  

7.9.2   Private type abbreviations
==================================
   
  (Introduced in OCaml 3.11)
                      type-equation ::=  ...               
                                     |   = private typexpr 
   Unlike a regular type abbreviation, a private type abbreviation declares a
type that is distinct from its implementation type typexpr. However, coercions
from the type to typexpr are permitted.  Moreover, the compiler "knows" the
implementation type and can take advantage of this knowledge to perform
type-directed optimizations. For ambiguity reasons, typexpr cannot be an object
or polymorphic variant type, but a similar behaviour can be obtained through
private row types.
  The following example uses a private type abbreviation to define a module of
nonnegative integers: 
<<        module N : sig
                       type t = private int
                       val of_int: int -> t
                       val to_int: t -> int
                     end
                   = struct
                       type t = int
                       let of_int n = assert (n >= 0); n
                       let to_int n = n
                     end
>>
  The type N.t is incompatible with int, ensuring that nonnegative integers and
regular integers are not confused. However, if x has type N.t, the coercion (x
:> int) is legal and returns the underlying integer, just like N.to_int x. Deep
coercions are also supported: if l has type N.t list, the coercion (l :> int
list) returns the list of underlying integers, like List.map N.to_int l but
without copying the list l.
  Note that the coercion (expr :> typexpr) is actually an abbreviated form, and
will only work in presence of private abbreviations if both the type of expr
and typexpr contain no type variables. If this is not the case, you must use
the full form (expr : typ_e :> typexpr) where typ_e is the expected type of
expr. Concretely, this would be (x : N.t :> int) and (l : N.t list :> int list)
for the above examples.

Node: Subsection 7-9-3,	Next: Section 7-10,	Prev: Subsection 7-9-2,	Up: Section 7-9
  

7.9.3   Private row types
=========================
    
  (Introduced in OCaml 3.09)
                      type-equation ::=  ...               
                                     |   = private typexpr 
   Private row types are type abbreviations where part of the structure of the
type is left abstract. Concretely typexpr in the above should denote either an
object type or a polymorphic variant type, with some possibility of refinement
left. If the private declaration is used in an interface, the corresponding
implementation may either provide a ground instance, or a refined private type.
<<   module M : sig type c = private < x : int; .. > val o : c end =
       struct
         class c = object method x = 3 method y = 2 end
         let o = new c
       end
>>
  This declaration does more than hiding the y method, it also makes the type c
incompatible with any other closed object type, meaning that only o will be of
type c. In that respect it behaves similarly to private record types. But
private row types are more flexible with respect to incremental refinement.
This feature can be used in combination with functors. 
<<   module F(X : sig type c = private < x : int; .. > end) =
       struct
         let get_x (o : X.c) = o#x
       end
     module G(X : sig type c = private < x : int; y : int; .. > end) =
       struct
         include F(X)
         let get_y (o : X.c) = o#y
       end
>>
  
  Polymorphic variant types can be refined in two ways, either to allow the
addition of new constructors, or to allow the disparition of declared
constructors. The second case corresponds to private variant types (one cannot
create a value of the private type), while the first case requires default
cases in pattern-matching to handle addition. 
<<   type t = [ `A of int | `B of bool ]
     type u = private [< t > `A ]
     type v = private [> t ]
>>
  With type u, it is possible to create values of the form (`A n), but not (`B
b). With type v, construction is not restricted but pattern-matching must have
a default case.
  Like for abstract and private types, the variance of type parameters is not
inferred, and must be given explicitly.

Node: Section 7-10,	Next: Section 7-11,	Prev: Section 7-9,	Up: Chapter 7
  

7.10   Local opens
*=*=*=*=*=*=*=*=*=

    
  (Introduced in OCaml 3.12)
                    expr ::=  ...                           
                          |   let open module-path in  expr 
                          |   module-path .(  expr )        
                                                            
  
  The expressions let open module-path in  expr and module-path. (expr) are
strictly equivalent. They locally open the module referred to by the module
path module-path in the scope of the expression expr.
  Restricting opening to the scope of a single expression instead of a whole
structure allows one to benefit from shorter syntax to refer to components of
the opened module, without polluting the global scope. Also, this can make the
code easier to read (the open statement is closer to where it is used) and to
refactor (because the code fragment is more self-contained).

Node: Section 7-11,	Next: Section 7-12,	Prev: Section 7-10,	Up: Chapter 7
  

7.11   Record notations
*=*=*=*=*=*=*=*=*=*=*=*

  
  (Introduced in OCaml 3.12)
   pattern ::=  ...                                                          
            |   { field  (= pattern)?  { ; (field =  pattern)? }  ( ; _ )? } 
                                                                             
      expr ::=  ...                                                          
            |   { field  (= expr)?  { ; field  (= expr)? } }                 
            |   { expr with  field  (= expr?)  { ; field  (= expr)? } }      
                                                                             
  
  In a record pattern or a record construction expression, a single identifier
id stands for id =  id, and a qualified identifier path ,  id stands for path .
 id =  id. For example, assuming the record type 
<<          type point = { x: float; y: float }
>>
  has been declared, the following expressions are equivalent: 
<<          let x = 1 and y = 2 in { x = x; y = y }
            let x = 1 and y = 2 in { x; y }
            let x = 1 and y = 2 in { x = x; y }
>>
  Likewise, the following functions are equivalent: 
<<          fun {x = x; y = y} -> x + y
            fun {x; y} -> x + y
>>
  
  Optionally, a record pattern can be terminated by ; _ to convey the fact that
not all fields of the record type are listed in the record pattern and that it
is intentional. By default, the compiler ignores the ; _ annotation. If the R
warning is turned on, however, the compiler will warn if a record pattern fails
to list all fields of the corresponding record type and is not terminated by ;
_. Continuing the point example above, 
<<          fun {x} -> x + 1
>>
  will warn if the R warning is on, while 
<<          fun {x; _} -> x + 1
>>
  will not warn. This warning can help spot program points where record
patterns may need to be modified after new fields were added to a record type.

Node: Section 7-12,	Next: Section 7-13,	Prev: Section 7-11,	Up: Chapter 7
  

7.12   Explicit polymorphic type annotations
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  (Introduced in OCaml 3.12)
              let-binding ::=  ...                                
                           |   value-name :  poly-typexpr =  expr 
  
  Polymorphic type annotations in let-definitions behave in a way similar to
polymorphic methods: they explicitly require the defined value to be
polymorphic, and allow one to use this polymorphism in recursive occurences
(when using let rec). Note however that this is just an usual polymorphic type,
unifiable with any instance of itself.
  There two possible applications of this feature. One is polymorphic
recursion: 
<<        type 'a t = Leaf of 'a | Node of ('a * 'a) t
          let rec depth : 'a. 'a t -> 'b = function
              Leaf _ -> 1
            | Node x -> 1 + depth x
>>
  Note that 'b is not explicitly polymorphic here, and it will actually be
unified with int.
  The other application is to ensure that some definition is sufficiently
polymorphic. 
<<#let id : 'a. 'a -> 'a = fun x -> x+1 ;;
  Error: This definition has type int -> int which is less general than
           'a. 'a -> 'a
>>
  
