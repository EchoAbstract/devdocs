This file has been translated from LaTeX by HeVeA.

Node: Section 9-1,	Next: Section 9-2,	Prev: Chapter 9,	Up: Chapter 9
  

9.1   Options
*=*=*=*=*=*=*

   
  The following command-line options are recognized by the ocaml command.
  
 
 
 -I directory  Add the given directory to the list of directories searched for
   source and compiled files. By default, the current directory is searched
   first, then the standard library directory. Directories added with -I are
   searched after the current directory, in the order in which they were given
   on the command line, but before the standard library directory.
 If the given directory starts with +, it is taken relative to the standard
   library directory. For instance, -I +labltk adds the subdirectory labltk of
   the standard library to the search path.
 Directories can also be added to the list once the toplevel is running with
   the #directory directive (section 9.2*Note Section 9-2::).
 
 -init file  Load the given file instead of the default initialization file.
   The default file is .ocamlinit in the current directory if it exists,
   otherwise .ocamlinit in the user's home directory.
 
 -labels  Labels are not ignored in types, labels may be used in applications,
   and labelled parameters can be given in any order. This is the default.
 
 -noassert  Do not compile assertion checks. Note that the special form assert
   false is always compiled because it is typed specially.
 
 -nolabels  Ignore non-optional labels in types. Labels cannot be used in
   applications, and parameter order becomes strict.
 
 -noprompt  Do not display any prompt when waiting for input.
 
 -nostdlib  Do not include the standard library directory in the list of
   directories searched for source and compiled files.
 
 -principal  Check information path during type-checking, to make sure that all
   types are derived in a principal way. When using labelled arguments and/or
   polymorphic methods, this flag is required to ensure future versions of the
   compiler will be able to infer types correctly, even if internal algorithms
   change. All programs accepted in -principal mode are also accepted in the
   default mode with equivalent types, but different binary signatures, and
   this may slow down type checking; yet it is a good idea to use it once
   before publishing source code.
 
 -rectypes  Allow arbitrary recursive types during type-checking. By default,
   only recursive types where the recursion goes through an object type are
   supported.
 
 -unsafe  See the corresponding option for ocamlc,
   chapter 8*Note Chapter 8::. Turn bound checking off on array and string
   accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe
   are therefore slightly faster, but unsafe: anything can happen if the
   program accesses an array or string outside of its bounds.
 
 -version  Print version string and exit.
 
 -vnum  Print short version number and exit.
 
 -w warning-list  Enable or disable warnings according to the argument
   warning-list. See section 8.2*Note Section 8-2:: for the syntax of
   the argument.
 
 -warn-error warning-list  Treat as errors the warnings enabled by the argument
   warning-list. See section 8.2*Note Section 8-2:: for the syntax of
   the argument.
 
 -help or --help  Display a short usage summary and exit. 
  
     Unix: 
    The following environment variables are also consulted: 
     
    LC_CTYPE  If set to iso_8859_1, accented characters (from the ISO Latin-1
      character set) in string and character literals are printed as is;
      otherwise, they are printed as decimal escape sequences (\ddd).
    
    TERM  When printing error messages, the toplevel system attempts to
      underline visually the location of the error. It consults the TERM
      variable to determines the type of output terminal and look up its
      capabilities in the terminal database.
    
    HOME  Directory where the .ocamlinit file is searched. 
    
  

Node: Section 9-2,	Next: Section 9-3,	Prev: Section 9-1,	Up: Chapter 9
  

9.2   Toplevel directives
*=*=*=*=*=*=*=*=*=*=*=*=*

   
  The following directives control the toplevel behavior, load files in memory,
and trace program execution.
  Note: all directives start with a # (sharp) symbol. This # must be typed
before the directive, and must not be confused with the # prompt displayed by
the interactive loop. For instance, typing #quit;; will exit the toplevel loop,
but typing quit;; will result in an "unbound value quit" error.
  
 
 
 #quit;;  Exit the toplevel loop and terminate the ocaml command.
 
 #labels bool;;  Ignore labels in function types if argument is false, or
   switch back to default behaviour (commuting style) if argument is true.
 
 #warnings "warning-list";;  Enable or disable warnings according to the
   argument.
 
 #directory "dir-name";;  Add the given directory to the list of directories
   searched for source and compiled files.
 
 #cd "dir-name";;  Change the current working directory.
 
 #load "file-name";;  Load in memory a bytecode object file (.cmo file)
   produced by the batch compiler ocamlc.
 
 #use "file-name";;  Read, compile and execute source phrases from the given
   file. This is textual inclusion: phrases are processed just as if they were
   typed on standard input. The reading of the file stops at the first error
   encountered.
 
 #install_printer printer-name;;  This directive registers the function named
   printer-name (a value path) as a printer for values whose types match the
   argument type of the function. That is, the toplevel loop will call
   printer-name when it has such a value to print.
 The printing function printer-name should have type Format.formatter -> t ->
   unit, where t is the type for the values to be printed, and should output
   its textual representation for the value of type t on the given formatter,
   using the functions provided by the Format library. For backward
   compatibility, printer-name can also have type t -> unit and should then
   output on the standard formatter, but this usage is deprecated.
 
 #remove_printer printer-name;;  Remove the named function from the table of
   toplevel printers.
 
 #trace function-name;;  After executing this directive, all calls to the
   function named function-name will be "traced". That is, the argument and the
   result are displayed for each call, as well as the exceptions escaping out
   of the function, raised either by the function itself or by another function
   it calls. If the function is curried, each argument is printed as it is
   passed to the function.
 
 #untrace function-name;;  Stop tracing the given function.
 
 #untrace_all;;  Stop tracing all functions traced so far.
 
 #print_depth n;;  Limit the printing of values to a maximal depth of n. The
   parts of values whose depth exceeds n are printed as ... (ellipsis).
 
 #print_length n;;  Limit the number of value nodes printed to at most n.
   Remaining parts of values are printed as ... (ellipsis).
  

Node: Section 9-3,	Next: Section 9-4,	Prev: Section 9-2,	Up: Chapter 9
  

9.3   The toplevel and the module system
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  Toplevel phrases can refer to identifiers defined in compilation units with
the same mechanisms as for separately compiled units: either by using qualified
names (Modulename.localname), or by using the open construct and unqualified
names (see section 6.3*Note Section 6-3::).
  However, before referencing another compilation unit, an implementation of
that unit must be present in memory. At start-up, the toplevel system contains
implementations for all the modules in the the standard library.
Implementations for user modules can be entered with the #load directive
described above. Referencing a unit for which no implementation has been
provided results in the error "Reference to undefined global `...' ".
  Note that entering open Mod merely accesses the compiled interface (.cmi
file) for Mod, but does not load the implementation of Mod, and does not cause
any error if no implementation of Mod has been loaded. The error  "reference to
undefined global Mod" will occur only when executing a value or module
definition that refers to Mod.

Node: Section 9-4,	Next: Section 9-5,	Prev: Section 9-3,	Up: Chapter 9
  

9.4   Common errors
*=*=*=*=*=*=*=*=*=*

  
  This section describes and explains the most frequently encountered error
messages.
  
 
 
 Cannot find file filename  The named file could not be found in the current
   directory, nor in the directories of the search path. 
 If filename has the format mod.cmi, this means you have referenced the
   compilation unit mod, but its compiled interface could not be found. Fix:
   compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.
 If filename has the format mod.cmo, this means you are trying to load with
   #load a bytecode object file that does not exist yet. Fix: compile mod.ml
   first.
 If your program spans several directories, this error can also appear because
   you haven't specified the directories to look into. Fix: use the #directory
   directive to add the correct directories to the search path.
 
 This expression has type t_1, but is used with type t_2  See
   section 8.4*Note Section 8-4::.
 
 Reference to undefined global mod  You have neglected to load in memory an
   implementation for a module with #load. See
   section 9.3*Note Section 9-3:: above.
  

Node: Section 9-5,	Next: Section 9-6,	Prev: Section 9-4,	Up: Chapter 9
  

9.5   Building custom toplevel systems: ocamlmktop
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

  
  The ocamlmktop command builds Objective Caml toplevels that contain user code
preloaded at start-up. 
  The ocamlmktop command takes as argument a set of .cmo and .cma files, and
links them with the object files that implement the Objective Caml toplevel.
The typical use is: 
<<        ocamlmktop -o mytoplevel foo.cmo bar.cmo gee.cmo
>>
  This creates the bytecode file mytoplevel, containing the Objective Caml
toplevel system, plus the code from the three .cmo files. This toplevel is
directly executable and is started by: 
<<        ./mytoplevel
>>
  This enters a regular toplevel loop, except that the code from foo.cmo,
bar.cmo and gee.cmo is already loaded in memory, just as if you had typed: 
<<        #load "foo.cmo";;
          #load "bar.cmo";;
          #load "gee.cmo";;
>>
  on entrance to the toplevel. The modules Foo, Bar and Gee are not opened,
though; you still have to do 
<<        open Foo;;
>>
  yourself, if this is what you wish.

Node: Section 9-6,	Next: Chapter 10,	Prev: Section 9-5,	Up: Chapter 9
  

9.6   Options
*=*=*=*=*=*=*

  
  The following command-line options are recognized by ocamlmktop.
  
 
 
 -cclib libname  Pass the -llibname option to the C linker when linking in
   "custom runtime" mode. See the corresponding option for ocamlc, in
   chapter 8*Note Chapter 8::.
 
 -ccopt option  Pass the given option to the C compiler and linker, when
   linking in "custom runtime" mode. See the corresponding option for ocamlc,
   in chapter 8*Note Chapter 8::.
 
 -custom  Link in "custom runtime" mode. See the corresponding option for
   ocamlc, in chapter 8*Note Chapter 8::.
 
 -I directory  Add the given directory to the list of directories searched for
   compiled object code files (.cmo and .cma).
 
 -o exec-file  Specify the name of the toplevel file produced by the linker.
   The default is a.out.
    

Node: Notes 2
 ---------------------------------------
 
(1) http://caml.inria.fr/humps/index_framed_caml.html

Node: Chapter 10,	Next: Section 10-1,	Prev: Chapter 9,	Up: Part III
  

Chapter 10     The runtime system (ocamlrun)
********************************************
    
  The ocamlrun command executes bytecode files produced by the linking phase of
the ocamlc command.
* Menu:

* Section 10-1::	Overview
* Section 10-2::	Options
* Section 10-3::	Dynamic loading of shared libraries
* Section 10-4::	Common errors


Node: Section 10-1,	Next: Section 10-2,	Prev: Chapter 10,	Up: Chapter 10
  

10.1   Overview
*=*=*=*=*=*=*=*

  
  The ocamlrun command comprises three main parts: the bytecode interpreter,
that actually executes bytecode files; the memory allocator and garbage
collector; and a set of C functions that implement primitive operations such as
input/output.
  The usage for ocamlrun is: 
<<
          ocamlrun options bytecode-executable arg_1 ... arg_n
>>
   The first non-option argument is taken to be the name of the file containing
the executable bytecode. (That file is searched in the executable path as well
as in the current directory.) The remaining arguments are passed to the Caml
program, in the string array Sys.argv. Element 0 of this array is the name of
the bytecode executable file; elements 1 to n are the remaining arguments arg_1
to arg_n.
  As mentioned in chapter 8*Note Chapter 8::, the bytecode executable files
produced by the ocamlc command are self-executable, and manage to launch the
ocamlrun command on themselves automatically. That is, assuming caml.out is a
bytecode executable file, 
<<
          caml.out arg_1 ... arg_n
>>
   works exactly as 
<<
          ocamlrun caml.out arg_1 ... arg_n
>>
   Notice that it is not possible to pass options to ocamlrun when invoking
caml.out directly.
     Windows: 
    Under several versions of Windows, bytecode executable files are
   self-executable only if their name ends in .exe. It is recommended to always
   give .exe names to bytecode executables, e.g. compile with ocamlc -o
   myprog.exe ... rather than ocamlc -o myprog .... 
  

Node: Section 10-2,	Next: Section 10-3,	Prev: Section 10-1,	Up: Chapter 10
  

10.2   Options
*=*=*=*=*=*=*=

   
  The following command-line options are recognized by ocamlrun.
  
 
 
 -b  When the program aborts due to an uncaught exception, print a detailed
   "back trace" of the execution, showing where the exception was raised and
   which function calls were outstanding at this point. The back trace is
   printed only if the bytecode executable contains debugging information, i.e.
   was compiled and linked with the -g option to ocamlc set. This is equivalent
   to setting the b flag in the OCAMLRUNPARAM environment variable (see below).
   
 -I dir  Search the directory dir for dynamically-loaded libraries, in addition
   to the standard search path (see
   section 10.3*Note Section 10-3::). 
 -p  Print the names of the primitives known to this version of ocamlrun and
   exit. 
 -v   Direct the memory manager to print some progress messages on standard
   error. This is equivalent to setting v=63 in the OCAMLRUNPARAM environment
   variable (see below). 
 -version   Print version string and exit. 
 -vnum   Print short version number and exit.
  
  The following environment variables are also consulted:
  
  
 CAML_LD_LIBRARY_PATH  Additional directories to search for dynamically-loaded
   libraries (see section 10.3*Note Section 10-3::).
 
 OCAMLLIB  The directory containing the Objective Caml standard library. (If
   OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the
   ld.conf configuration file for dynamic loading (see
   section 10.3*Note Section 10-3::). If not set, default to the
   library directory specified when compiling Objective Caml.
 
 OCAMLRUNPARAM  Set the runtime system options  and garbage collection
   parameters. (If OCAMLRUNPARAM is not set, CAMLRUNPARAM will be used
   instead.) This variable must be a sequence of parameter specifications. A
   parameter specification is an option letter followed by an = sign, a decimal
   number (or an hexadecimal number prefixed by 0x), and an optional
   multiplier. There are nine options, six of which correspond to the fields of
   the control record documented in  section 20.10*Note Section 20-10::. 
     
    b  (backtrace) Trigger the printing of a stack backtrace  when an uncaught
      exception aborts the program. This option takes no argument. 
    p  (parser trace) Turn on debugging support for ocamlyacc-generated
      parsers. When this option is on, the pushdown automaton that executes the
      parsers prints a trace of its actions. This option takes no argument. 
    s  (minor_heap_size) Size of the minor heap. (in words) 
    i  (major_heap_increment) Default size increment for the major heap. (in
      words) 
    o  (space_overhead) The major GC speed setting. 
    O  (max_overhead) The heap compaction trigger setting. 
    v  (verbose) What GC messages to print to stderr. This is a sum of values
      selected from the following: 
        
       1 (= 0x001)  Start of major GC cycle. 
       2 (= 0x002)  Minor collection and major GC slice. 
       4 (= 0x004)  Growing and shrinking of the heap. 
       8 (= 0x008)  Resizing of stacks and memory manager tables. 
       16 (= 0x010)  Heap compaction. 
       32 (= 0x020)  Change of GC parameters. 
       64 (= 0x040)  Computation of major GC slice size. 
       128 (= 0x080)  Calling of finalisation functions 
       256 (= 0x100)  Startup messages (loading the bytecode executable file,
         resolving shared libraries). 
     
    l  (stack_limit) The limit (in words) of the stack size. 
    h  The initial size of the major heap (in words). 
  The multiplier is k, M, or G, for multiplication by 2^10, 2^20, and 2^30
   respectively. For example, on a 32-bit machine, under bash the command 
   <<
             export OCAMLRUNPARAM='b,s=256k,v=0x015'
   >>
  tells a subsequent ocamlrun to print backtraces for uncaught exceptions, set
   its initial minor heap size to 1 megabyte and print a message at the start
   of each major GC cycle, when the heap size changes, and when compaction is
   triggered.
 
 CAMLRUNPARAM  If OCAMLRUNPARAM is not found in the environment, then
   CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is not found, then the
   default values will be used.
 
 PATH  List of directories searched to find the bytecode executable file. 
  

Node: Section 10-3,	Next: Section 10-4,	Prev: Section 10-2,	Up: Chapter 10
  

10.3   Dynamic loading of shared libraries
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  On platforms that support dynamic loading, ocamlrun can link dynamically with
C shared libraries (DLLs) providing additional C primitives beyond those
provided by the standard runtime system. The names for these libraries are
provided at link time as described in
section 18.1.4*Note Subsection 18-1-4::), and recorded in the bytecode
executable file; ocamlrun, then, locates these libraries and resolves
references to their primitives when the bytecode executable program starts.
  The ocamlrun command searches shared libraries in the following directories,
in the order indicated: 
  
   1. Directories specified on the ocamlrun command line with the -I option. 
   2. Directories specified in the CAML_LD_LIBRARY_PATH environment variable. 
   3. Directories specified at link-time via the -dllpath option to ocamlc.
   (These directories are recorded in the bytecode executable file.) 
   4. Directories specified in the file ld.conf. This file resides in the
   Objective Caml standard library directory, and lists directory names (one
   per line) to be searched. Typically, it contains only one line naming the
   stublibs subdirectory of the Objective Caml standard library directory.
   Users can add there the names of other directories containing
   frequently-used shared libraries; however, for consistency of installation,
   we recommend that shared libraries are installed directly in the system
   stublibs directory, rather than adding lines to the ld.conf file. 
   5. Default directories searched by the system dynamic loader. Under Unix,
   these generally include /lib and /usr/lib, plus the directories listed in
   the file /etc/ld.so.conf and the environment variable LD_LIBRARY_PATH. Under
   Windows, these include the Windows system directories, plus the directories
   listed in the PATH environment variable. 
   

Node: Section 10-4,	Next: Chapter 11,	Prev: Section 10-3,	Up: Chapter 10
  

10.4   Common errors
*=*=*=*=*=*=*=*=*=*=

  
  This section describes and explains the most frequently encountered error
messages.
  
 
 
 filename: no such file or directory  If filename is the name of a
   self-executable bytecode file, this means that either that file does not
   exist, or that it failed to run the ocamlrun bytecode interpreter on itself.
   The second possibility indicates that Objective Caml has not been properly
   installed on your system.
 
 Cannot exec ocamlrun  (When launching a self-executable bytecode file.) The
   ocamlrun could not be found in the executable path. Check that Objective
   Caml has been properly installed on your system.
 
 Cannot find the bytecode file  The file that ocamlrun is trying to execute
   (e.g. the file given as first non-option argument to ocamlrun) either does
   not exist, or is not a valid executable bytecode file.
 
 Truncated bytecode file  The file that ocamlrun is trying to execute is not a
   valid executable bytecode file. Probably it has been truncated or mangled
   since created. Erase and rebuild it.
 
 Uncaught exception  The program being executed contains a "stray" exception.
   That is, it raises an exception at some point, and this exception is never
   caught. This causes immediate termination of the program. The name of the
   exception is printed, along with its string and integer arguments (arguments
   of more complex types are not correctly printed). To locate the context of
   the uncaught exception, compile the program with the -g option and either
   run it again under the ocamldebug debugger (see
   chapter 16*Note Chapter 16::), or run it with ocamlrun -b or with the
   OCAMLRUNPARAM environment variable set to b=1.
 
 Out of memory  The program being executed requires more memory than available.
   Either the program builds excessively large data structures; or the program
   contains too many nested function calls, and the stack overflows. In some
   cases, your program is perfectly correct, it just requires more memory than
   your machine provides. In other cases, the "out of memory" message reveals
   an error in your program: non-terminating recursive function, allocation of
   an excessively large array or string, attempts to build an infinite list or
   other data structure, ...
 To help you diagnose this error, run your program with the -v option to
   ocamlrun, or with the OCAMLRUNPARAM environment variable set to v=63. If it
   displays lots of "Growing stack..." messages, this is probably a looping
   recursive function. If it displays lots of "Growing heap..." messages, with
   the heap size growing slowly, this is probably an attempt to construct a
   data structure with too many (infinitely many?) cells. If it displays few 
   "Growing heap..." messages, but with a huge increment in the heap size, this
   is probably an attempt to build an excessively large array or string.
    

Node: Chapter 11,	Next: Section 11-1,	Prev: Chapter 10,	Up: Part III
  

Chapter 11     Native-code compilation (ocamlopt)
*************************************************
    
  This chapter describes the Objective Caml high-performance native-code
compiler ocamlopt, which compiles Caml source files to native code object files
and link these object files to produce standalone executables. 
  The native-code compiler is only available on certain platforms. It produces
code that runs faster than the bytecode produced by ocamlc, at the cost of
increased compilation time and executable code size. Compatibility with the
bytecode compiler is extremely high: the same source code should run
identically when compiled with ocamlc and ocamlopt.
  It is not possible to mix native-code object files produced by ocamlopt with
bytecode object files produced by ocamlc: a program must be compiled entirely
with ocamlopt or entirely with ocamlc. Native-code object files produced by
ocamlopt cannot be loaded in the toplevel system ocaml.
* Menu:

* Section 11-1::	Overview of the compiler
* Section 11-2::	Options
* Section 11-3::	Common errors
* Section 11-4::	Running executables produced by ocamlopt
* Section 11-5::	Compatibility with the bytecode compiler


Node: Section 11-1,	Next: Section 11-2,	Prev: Chapter 11,	Up: Chapter 11
  

11.1   Overview of the compiler
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

  
  The ocamlopt command has a command-line interface very close to that of
ocamlc. It accepts the same types of arguments, and processes them
sequentially:
  
  
   - Arguments ending in .mli are taken to be source files for compilation unit
   interfaces. Interfaces specify the names exported by compilation units: they
   declare value names with their types, define public data types, declare
   abstract data types, and so on. From the file x.mli, the ocamlopt compiler
   produces a compiled interface in the file x.cmi. The interface produced is
   identical to that produced by the bytecode compiler ocamlc.
 
   - Arguments ending in .ml are taken to be source files for compilation unit
   implementations. Implementations provide definitions for the names exported
   by the unit, and also contain expressions to be evaluated for their
   side-effects. From the file x.ml, the ocamlopt compiler produces two files:
   x.o, containing native object code, and x.cmx, containing extra information
   for linking and optimization of the clients of the unit. The compiled
   implementation should always be referred to under the name x.cmx (when given
   a .o or .obj file, ocamlopt assumes that it contains code compiled from C,
   not from Caml).
 The implementation is checked against the interface file x.mli (if it exists)
   as described in the manual for ocamlc (chapter 8*Note Chapter 8::).
 
   - Arguments ending in .cmx are taken to be compiled object code. These files
   are linked together, along with the object files obtained by compiling .ml
   arguments (if any), and the Caml standard library, to produce a native-code
   executable program. The order in which .cmx and .ml arguments are presented
   on the command line is relevant: compilation units are initialized in that
   order at run-time, and it is a link-time error to use a component of a unit
   before having initialized it. Hence, a given x.cmx file must come before all
   .cmx files that refer to the unit x.
 
   - Arguments ending in .cmxa are taken to be libraries of object code. Such a
   library packs in two files (lib.cmxa and lib.a/.lib) a set of object files
   (.cmx and .o/.obj files). Libraries are build with ocamlopt -a (see the
   description of the -a option below). The object files contained in the
   library are linked as regular .cmx files (see above), in the order specified
   when the library was built. The only difference is that if an object file
   contained in a library is not referenced anywhere in the program, then it is
   not linked in.
 
   - Arguments ending in .c are passed to the C compiler, which generates a
   .o/.obj object file. This object file is linked with the program.
 
   - Arguments ending in .o, .a or .so (.obj, .lib and .dll under Windows) are
   assumed to be C object files and libraries. They are linked with the
   program.
  
  The output of the linking phase is a regular Unix or Windows executable file.
It does not need ocamlrun to run.

Node: Section 11-2,	Next: Section 11-3,	Prev: Section 11-1,	Up: Chapter 11
  

11.2   Options
*=*=*=*=*=*=*=

  
  The following command-line options are recognized by ocamlopt. The options
-pack, -a, -shared, -c and -output-obj are mutually exclusive.
  
 
 
 -a  Build a library (.cmxa and .a/.lib files) with the object files (.cmx and
   .o/.obj files) given on the command line, instead of linking them into an
   executable file. The name of the library must be set with the -o option.
 If -cclib or -ccopt options are passed on the command line, these options are
   stored in the resulting .cmxa library. Then, linking with this library
   automatically adds back the -cclib and -ccopt options as if they had been
   provided on the command line, unless the -noautolink option is given.
 
 -annot  Dump detailed information about the compilation (types, bindings,
   tail-calls, etc). The information for file src.ml is put into file
   src.annot. In case of a type error, dump all the information inferred by the
   type-checker before the error. The src.annot file can be used with the emacs
   commands given in emacs/caml-types.el to display types and other annotations
   interactively.
 
 -c  Compile only. Suppress the linking phase of the compilation. Source code
   files are turned into compiled files, but no executable file is produced.
   This option is useful to compile modules separately.
 
 -cc ccomp  Use ccomp as the C linker called to build the final executable and
   as the C compiler for compiling .c source files.
 
 -cclib -llibname  Pass the -llibname option to the linker. This causes the
   given C library to be linked with the program.
 
 -ccopt option  Pass the given option to the C compiler and linker. For
   instance, -ccopt -Ldir causes the C linker to search for C libraries in
   directory dir.
 
 -compact  Optimize the produced code for space rather than for time. This
   results in slightly smaller but slightly slower programs. The default is to
   optimize for speed.
 
 -config  Print the version number of ocamlopt and a detailed summary of its
   configuration, then exit.
 
 -for-pack module-path  Generate an object file (.cmx and .o/.obj files) that
   can later be included as a sub-module (with the given access path) of a
   compilation unit constructed with -pack. For instance, ocamlopt -for-pack P
   -c A.ml will generate a.cmx and a.o files that can later be used with
   ocamlopt -pack -o P.cmx a.cmx.
 
 -g  Add debugging information while compiling and linking. This option is
   required in order to produce stack backtraces when the program terminates on
   an uncaught exception (see section 10.2*Note Section 10-2::).
 
 -i  Cause the compiler to print all defined names (with their inferred types
   or their definitions) when compiling an implementation (.ml file). No
   compiled files (.cmo and .cmi files) are produced. This can be useful to
   check the types inferred by the compiler. Also, since the output follows the
   syntax of interfaces, it can help in writing an explicit interface (.mli
   file) for a file: just redirect the standard output of the compiler to a
   .mli file, and edit that file to remove all declarations of unexported
   names.
 
 -I directory  Add the given directory to the list of directories searched for
   compiled interface files (.cmi), compiled object code files (.cmx), and
   libraries (.cmxa). By default, the current directory is searched first, then
   the standard library directory. Directories added with -I are searched after
   the current directory, in the order in which they were given on the command
   line, but before the standard library directory.
 If the given directory starts with +, it is taken relative to the standard
   library directory. For instance, -I +labltk adds the subdirectory labltk of
   the standard library to the search path.
 
 -inline n  Set aggressiveness of inlining to n, where n is a positive integer.
   Specifying -inline 0 prevents all functions from being inlined, except those
   whose body is smaller than the call site. Thus, inlining causes no expansion
   in code size. The default aggressiveness, -inline 1, allows slightly larger
   functions to be inlined, resulting in a slight expansion in code size.
   Higher values for the -inline option cause larger and larger functions to
   become candidate for inlining, but can result in a serious increase in code
   size.
 
 -intf filename  Compile the file filename as an interface file, even if its
   extension is not .mli.
 
 -intf-suffix string  Recognize file names ending with string as interface
   files (instead of the default .mli).
 
 -labels  Labels are not ignored in types, labels may be used in applications,
   and labelled parameters can be given in any order. This is the default.
 
 -linkall  Force all modules contained in libraries to be linked in. If this
   flag is not given, unreferenced modules are not linked in. When building a
   library (-a flag), setting the -linkall flag forces all subsequent links of
   programs involving that library to link all the modules contained in the
   library.
 
 -noassert  Do not compile assertion checks. Note that the special form assert
   false is always compiled because it is typed specially. This flag has no
   effect when linking already-compiled files.
 
 -noautolink  When linking .cmxa libraries, ignore -cclib and -ccopt options
   potentially contained in the libraries (if these options were given when
   building the libraries). This can be useful if a library contains incorrect
   specifications of C libraries or C options; in this case, during linking,
   set -noautolink and pass the correct C libraries and options on the command
   line.
 
 -nodynlink  Allow the compiler to use some optimizations that are valid only
   for code that is never dynlinked.
 
 -nolabels  Ignore non-optional labels in types. Labels cannot be used in
   applications, and parameter order becomes strict.
 
 -o exec-file  Specify the name of the output file produced by the linker. The
   default output name is a.out under Unix and camlprog.exe under Windows. If
   the -a option is given, specify the name of the library produced. If the
   -pack option is given, specify the name of the packed object file produced.
   If the -output-obj option is given, specify the name of the output file
   produced. If the -shared option is given, specify the name of plugin file
   produced.
 
 -output-obj  Cause the linker to produce a C object file instead of an
   executable file. This is useful to wrap Caml code as a C library, callable
   from any C program. See chapter 18*Note Chapter 18::,
   section 18.7.5*Note Subsection 18-7-5::. The name of the output object
   file is camlprog.o by default; it can be set with the -o option. This option
   can also be used to produce a compiled shared/dynamic library (.so
   extension, .dll under Windows).
 
 -p  Generate extra code to write profile information when the program is
   executed. The profile information can then be examined with the analysis
   program gprof. (See chapter 17*Note Chapter 17:: for more information
   on profiling.) The -p option must be given both at compile-time and at
   link-time. Linking object files not compiled with -p is possible, but
   results in less precise profiling.
    Unix: 
       See the Unix manual page for gprof(1) for more information about the
      profiles.
      Full support for gprof is only available for certain platforms
      (currently: Intel x86/Linux and Alpha/Digital Unix). On other platforms,
      the -p option will result in a less precise profile (no call graph
      information, only a time profile). 
 
    Windows: 
       The -p option does not work under Windows. 
 
 
 -pack  Build an object file (.cmx and .o/.obj files) and its associated
   compiled interface (.cmi) that combines the .cmx object files given on the
   command line, making them appear as sub-modules of the output .cmx file. The
   name of the output .cmx file must be given with the -o option. For instance,
   
   <<        ocamlopt -pack -o P.cmx A.cmx B.cmx C.cmx
   >>
 generates compiled files P.cmx, P.o and P.cmi describing a compilation unit
   having three sub-modules A, B and C, corresponding to the contents of the
   object files A.cmx, B.cmx and C.cmx. These contents can be referenced as
   P.A, P.B and P.C in the remainder of the program.
 The .cmx object files being combined must have been compiled with the
   appropriate -for-pack option. In the example above, A.cmx, B.cmx and C.cmx
   must have been compiled with ocamlopt -for-pack P.
 Multiple levels of packing can be achieved by combining -pack with -for-pack.
   Consider the following example: 
   <<        ocamlopt -for-pack P.Q -c A.ml
             ocamlopt -pack -o Q.cmx -for-pack P A.cmx
             ocamlopt -for-pack P -c B.ml
             ocamlopt -pack -o P.cmx Q.cmx B.cmx
   >>
 The resulting P.cmx object file has sub-modules P.Q, P.Q.A and P.B.
 
 -pp command  Cause the compiler to call the given command as a preprocessor
   for each source file. The output of command is redirected to an intermediate
   file, which is compiled. If there are no compilation errors, the
   intermediate file is deleted afterwards.
 
 -principal  Check information path during type-checking, to make sure that all
   types are derived in a principal way. All programs accepted in -principal
   mode are also accepted in default mode with equivalent types, but different
   binary signatures.
 
 -rectypes  Allow arbitrary recursive types during type-checking. By default,
   only recursive types where the recursion goes through an object type are
   supported. Note that once you have created an interface using this flag, you
   must use it again for all dependencies.
 
 -S  Keep the assembly code produced during the compilation. The assembly code
   for the source file x.ml is saved in the file x.s.
 
 -shared  Build a plugin (usually .cmxs) that can be dynamically loaded with
   the Dynlink module. The name of the plugin must be set with the -o option. A
   plugin can include a number of Caml modules and libraries, and extra native
   objects (.o, .obj, .a, .lib files). Building native plugins is only
   supported for some operating system. Under some systems (currently, only
   Linux AMD 64), all the Caml code linked in a plugin must have been compiled
   without the -nodynlink flag. Some constraints might also apply to the way
   the extra native objects have been compiled (under Linux AMD 64, they must
   contain only position-independent code).
 
 -thread  Compile or link multithreaded programs, in combination with the
   system threads library described in chapter 24*Note Chapter 24::.
 
 -unsafe  Turn bound checking off for array and string accesses (the v.(i) and
   s.[i] constructs). Programs compiled with -unsafe are therefore faster, but
   unsafe: anything can happen if the program accesses an array or string
   outside of its bounds. Additionally, turn off the check for zero divisor in
   integer division and modulus operations. With -unsafe, an integer division
   (or modulus) by zero can halt the program or continue with an unspecified
   result instead of raising a Division_by_zero exception.
 
 -v  Print the version number of the compiler and the location of the standard
   library directory, then exit.
 
 -verbose  Print all external commands before they are executed, in particular
   invocations of the assembler, C compiler, and linker.
 
 -vnum or -version  Print the version number of the compiler in short form
   (e.g. 3.11.0), then exit.
 
 -w warning-list  Enable, disable, or mark as errors the warnings specified by
   the argument warning-list. Each warning can be enabled or disabled, and each
   warning can be marked or unmarked. If a warning is disabled, it isn't
   displayed and doesn't affect compilation in any way (even if it is marked).
   If a warning is enabled, it is displayed normally by the compiler whenever
   the source code triggers it. If it is enabled and marked, the compiler will
   stop with an error after displaying that warning if the source code triggers
   it.
 The warning-list argument is a sequence of warning specifiers, with no
   separators between them. A warning specifier is one of the following:
 
     
    +num  Enable warning number num. 
    -num  Disable warning number num. 
    @num  Enable and mark warning number num. 
    +num1..num2  Enable warnings in the given range. 
    -num1..num2  Disable warnings in the given range. 
    @num1..num2  Enable and mark warnings in the given range. 
    +letter  Enable the set of warnings corresponding to letter. The letter may
      be uppercase or lowercase. 
    -letter  Disable the set of warnings corresponding to letter. The letter
      may be uppercase or lowercase. 
    @letter  Enable and mark the set of warnings corresponding to letter. The
      letter may be uppercase or lowercase. 
    uppercase-letter  Enable the set of warnings corresponding to
      uppercase-letter. 
    lowercase-letter  Disable the set of warnings corresponding to
      lowercase-letter. 
 
 Warning numbers which are out of the range of warnings that are currently
   defined are ignored. The warning numbers are as follows. 
     
    1  Suspicious-looking start-of-comment mark. 
    2  Suspicious-looking end-of-comment mark. 
    3  Deprecated syntax. 
    4  Fragile pattern matching: matching that will remain complete even if
      additional constructors are added to one of the variant types matched. 
    5  Partially applied function: expression whose result has function type
      and is ignored. 
    6  Label omitted in function application. 
    7  Some methods are overridden in the class where they are defined. 
    8  Partial match: missing cases in pattern-matching. 
    9  Missing fields in a record pattern. 
    10  Expression on the left-hand side of a sequence that doesn't have type
      "unit" (and that is not a function, see warning number 5). 
    11  Redundant case in a pattern matching (unused match case). 
    12  Redundant sub-pattern in a pattern-matching. 
    13  Override of an instance variable. 
    14  Illegal backslash escape in a string constant. 
    15  Private method made public implicitly. 
    16  Unerasable optional argument. 
    17  Undeclared virtual method. 
    18  Non-principal type. 
    19  Type without principality. 
    20  Unused function argument. 
    21  Non-returning statement. 
    22  Camlp4 warning. 
    23  Useless record "with" clause. 
    24  Bad module name: the source file name is not a valid OCaml module name.
      
    25  Pattern-matching with all clauses guarded. Exhaustiveness cannot be
      checked 
    26  Suspicious unused variable: unused variable that is bound with "let" or
      "as", and doesn't start with an underscore ("_") character. 
    27  Innocuous unused variable: unused variable that is not bound with "let"
      nor "as", and doesn't start with an underscore ("_") character. 
    28  Wildcard pattern given as argument to a constant constructor. 
    29  Unescaped end-of-line in a string constant (non-portable code). 
    30  Two labels or constructors of the same name are defined in two mutually
      recursive types.  
 
 The letters stand for the following sets of warnings. Any letter not mentioned
   here corresponds to the empty set.
 
     
    A  all warnings 
    C  1, 2 
    D  3 
    E  4 
    F  5 
    L  6 
    M  7 
    P  8 
    R  9 
    S  10 
    U  11, 12 
    V  13 
    X  14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 
    Y  26 
    Z  27 
 
 The default setting is -w +a-4-6-7-9-27..29. Note that warnings 5 and 10 are
   not always triggered, depending on the internals of the type checker.
 
 -warn-error warning-list  Mark as errors the warnings specified in the
   argument warning-list. The compiler will stop with an error when one of
   these warnings is emitted. The warning-list has the same meaning as for the
   -w option: a + sign (or an uppercase letter) turns the corresponding
   warnings into errors, a - sign (or a lowercase letter) turns them back into
   warnings, and a @ sign both enables and marks the corresponding warnings.
 Note: it is not recommended to use warning sets (i.e. letters) as arguments to
   -warn-error in production code, because this can break your build when
   future versions of OCaml add some new warnings.
 The default setting is -warn-error -a (none of the warnings is treated as an
   error).
 
 -where  Print the location of the standard library, then exit.
 
 - file  Process file as a file name, even if it starts with a dash (-)
   character.
 
 -help or --help  Display a short usage summary and exit. 
  
 Options for the IA32 architecture
   The IA32 code generator (Intel Pentium, AMD Athlon) supports the following
additional option:
  
  
 -ffast-math  Use the IA32 instructions to compute trigonometric and
   exponential functions, instead of calling the corresponding library
   routines. The functions affected are: atan, atan2, cos, log, log10, sin,
   sqrt and tan. The resulting code runs faster, but the range of supported
   arguments and the precision of the result can be reduced. In particular,
   trigonometric operations cos, sin, tan have their range reduced to [-2^64,
   2^64]. 
  
 Options for the AMD64 architecture
   The AMD64 code generator (64-bit versions of Intel Pentium and AMD Athlon)
supports the following additional options:
  
  
 -fPIC  Generate position-independent machine code. This is the default. 
 -fno-PIC  Generate position-dependent machine code. 
  
 Options for the Sparc architecture
   The Sparc code generator supports the following additional options: 
  
 -march=v8  Generate SPARC version 8 code. 
 -march=v9  Generate SPARC version 9 code. 
   The default is to generate code for SPARC version 7, which runs on all SPARC
processors.

Node: Section 11-3,	Next: Section 11-4,	Prev: Section 11-2,	Up: Chapter 11
  

11.3   Common errors
*=*=*=*=*=*=*=*=*=*=

  
  The error messages are almost identical to those of ocamlc. See
section 8.4*Note Section 8-4::.

Node: Section 11-4,	Next: Section 11-5,	Prev: Section 11-3,	Up: Chapter 11
  

11.4   Running executables produced by ocamlopt
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

  
  Executables generated by ocamlopt are native, stand-alone executable files
that can be invoked directly. They do not depend on the ocamlrun bytecode
runtime system nor on dynamically-loaded C/Caml stub libraries.
  During execution of an ocamlopt-generated executable, the following
environment variables are also consulted: 
  
 OCAMLRUNPARAM  Same usage as in ocamlrun (see
   section 10.2*Note Section 10-2::), except that option l is ignored
   (the operating system's stack size limit is used instead). 
 CAMLRUNPARAM  If OCAMLRUNPARAM is not found in the environment, then
   CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is not found, then the
   default values will be used. 
  

Node: Section 11-5,	Next: Chapter 12,	Prev: Section 11-4,	Up: Chapter 11
  

11.5   Compatibility with the bytecode compiler
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  This section lists the known incompatibilities between the bytecode compiler
and the native-code compiler. Except on those points, the two compilers should
generate code that behave identically.
  
 
 
   - Signals are detected only when the program performs an allocation in the
   heap. That is, if a signal is delivered while in a piece of code that does
   not allocate, its handler will not be called until the next heap allocation.
 
   - Stack overflow, typically caused by excessively deep recursion,  is
   handled in one of the following ways, depending on the platform used: 
     
      - By raising a Stack_overflow exception, like the bytecode compiler does.
      (IA32/Linux, AMD64/Linux, PowerPC/MacOSX, MS Windows 32-bit ports). 
      - By aborting the program on a "segmentation fault" signal. (All other
      Unix systems.) 
      - By terminating the program silently. (MS Windows 64 bits). 
 
 
   - On IA32 processors only (Intel Pentium, AMD Athlon, etc, in 32-bit mode),
   some intermediate results in floating-point computations are kept in
   extended precision rather than being rounded to double precision like the
   bytecode compiler always does. Floating-point results can therefore differ
   between bytecode and native code; in general, the results obtained with
   native code are "more exact" (less affected by rounding errors and loss of
   precision).
 
   - On the Alpha processor only, floating-point operations involving infinite
   or denormalized numbers can abort the program on a "floating-point
   exception" signal.
  
   

Node: Chapter 12,	Next: Section 12-1,	Prev: Chapter 11,	Up: Part III
  

Chapter 12     Lexer and parser generators (ocamllex, ocamlyacc)
****************************************************************
    
  This chapter describes two program generators: ocamllex, that produces a
lexical analyzer from a set of regular expressions with associated semantic
actions, and ocamlyacc, that produces a parser from a grammar with associated
semantic actions.
  These program generators are very close to the well-known lex and yacc
commands that can be found in most C programming environments. This chapter
assumes a working knowledge of lex and yacc: while it describes the input
syntax for ocamllex and ocamlyacc and the main differences with lex and yacc,
it does not explain the basics of writing a lexer or parser description in lex
and yacc. Readers unfamiliar with lex and yacc are referred to "Compilers:
principles, techniques, and tools" by Aho, Sethi and Ullman (Addison-Wesley,
1986), or "Lex & Yacc", by Levine, Mason and Brown (O'Reilly, 1992).
* Menu:

* Section 12-1::	Overview of ocamllex
* Section 12-2::	Syntax of lexer definitions
* Section 12-3::	Overview of ocamlyacc
* Section 12-4::	Syntax of grammar definitions
* Section 12-5::	Options
* Section 12-6::	A complete example
* Section 12-7::	Common errors


Node: Section 12-1,	Next: Subsection 12-1-1,	Prev: Chapter 12,	Up: Chapter 12
  

12.1   Overview of ocamllex
*=*=*=*=*=*=*=*=*=*=*=*=*=*

  
  The ocamllex command produces a lexical analyzer from a set of regular
expressions with attached semantic actions, in the style of lex. Assuming the
input file is lexer.mll, executing 
<<
          ocamllex lexer.mll
>>
   produces Caml code for a lexical analyzer in file lexer.ml. This file
defines one lexing function per entry point in the lexer definition. These
functions have the same names as the entry points. Lexing functions take as
argument a lexer buffer, and return the semantic attribute of the corresponding
entry point.
  Lexer buffers are an abstract data type implemented in the standard library
module Lexing. The functions Lexing.from_channel, Lexing.from_string and
Lexing.from_function create lexer buffers that read from an input channel, a
character string, or any reading function, respectively. (See the description
of module Lexing in chapter 20*Note Chapter 20::.)
  When used in conjunction with a parser generated by ocamlyacc, the semantic
actions compute a value belonging to the type token defined by the generated
parsing module. (See the description of ocamlyacc below.)
* Menu:

* Subsection 12-1-1::	Options

