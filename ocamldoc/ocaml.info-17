This file has been translated from LaTeX by HeVeA.

Node: Section 20-28,	Next: Section 20-29,	Prev: Section 20-27,	Up: Chapter 20
  

20.28   Module Set : Sets over ordered types.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  This module implements the set data structure, given a total ordering
function over the set elements. All operations over sets are purely applicative
(no side-effects). The implementation uses balanced binary trees, and is
therefore reasonably efficient: insertion and membership take time logarithmic
in the size of the set, for instance.
  
  
<<
  module type OrderedType = >>
   
    sig
  
  
   
   <<
     type t 
   >>
   
       The type of the set elements.
 
   
   <<
     val compare : t -> t -> int
   >>
   
       A total ordering function over the set elements. This is a two-argument
      function f such that f e1 e2 is zero if the elements e1 and e2 are equal,
      f e1 e2 is strictly negative if e1 is smaller than e2, and f e1 e2 is
      strictly positive if e1 is greater than e2. Example: a suitable ordering
      function is the generic structural comparison function
      Pervasives.compare[19.2*Note Section 19-2::].
  
    end
  
    Input signature of the functor Set.Make[20.28*Note Section 20-28::].
  
<<
  module type S = >>
   
    sig
  
  
   
   <<
     type elt 
   >>
   
       The type of the set elements.
 
   
   <<
     type t 
   >>
   
       The type of sets.
 
   
   <<
     val empty : t
   >>
   
       The empty set.
 
   
   <<
     val is_empty : t -> bool
   >>
   
       Test whether a set is empty or not.
 
   
   <<
     val mem : elt -> t -> bool
   >>
   
       mem x s tests whether x belongs to the set s.
 
   
   <<
     val add : elt -> t -> t
   >>
   
       add x s returns a set containing all elements of s, plus x. If x was
      already in s, s is returned unchanged.
 
   
   <<
     val singleton : elt -> t
   >>
   
       singleton x returns the one-element set containing only x.
 
   
   <<
     val remove : elt -> t -> t
   >>
   
       remove x s returns a set containing all elements of s, except x. If x
      was not in s, s is returned unchanged.
 
   
   <<
     val union : t -> t -> t
   >>
   
       Set union.
 
   
   <<
     val inter : t -> t -> t
   >>
   
       Set intersection.
 
   
   <<
     val diff : t -> t -> t
   >>
   
       Set difference.
 
   
   <<
     val compare : t -> t -> int
   >>
   
       Total ordering between sets. Can be used as the ordering function for
      doing sets of sets.
 
   
   <<
     val equal : t -> t -> bool
   >>
   
       equal s1 s2 tests whether the sets s1 and s2 are equal, that is, contain
      equal elements.
 
   
   <<
     val subset : t -> t -> bool
   >>
   
       subset s1 s2 tests whether the set s1 is a subset of the set s2.
 
   
   <<
     val iter : (elt -> unit) -> t -> unit
   >>
   
       iter f s applies f in turn to all elements of s. The elements of s are
      presented to f in increasing order with respect to the ordering over the
      type of the elements.
 
   
   <<
     val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
   >>
   
       fold f s a computes (f xN ... (f x2 (f x1 a))...), where x1 ... xN are
      the elements of s, in increasing order.
 
   
   <<
     val for_all : (elt -> bool) -> t -> bool
   >>
   
       for_all p s checks if all elements of the set satisfy the predicate p.
 
   
   <<
     val exists : (elt -> bool) -> t -> bool
   >>
   
       exists p s checks if at least one element of the set satisfies the
      predicate p.
 
   
   <<
     val filter : (elt -> bool) -> t -> t
   >>
   
       filter p s returns the set of all elements in s that satisfy predicate
      p.
 
   
   <<
     val partition : (elt -> bool) -> t -> t * t
   >>
   
       partition p s returns a pair of sets (s1, s2), where s1 is the set of
      all the elements of s that satisfy the predicate p, and s2 is the set of
      all the elements of s that do not satisfy p.
 
   
   <<
     val cardinal : t -> int
   >>
   
       Return the number of elements of a set.
 
   
   <<
     val elements : t -> elt list
   >>
   
       Return the list of all elements of the given set. The returned list is
      sorted in increasing order with respect to the ordering Ord.compare,
      where Ord is the argument given to Set.Make[20.28*Note Section 20-28::].
 
   
   <<
     val min_elt : t -> elt
   >>
   
       Return the smallest element of the given set (with respect to the
      Ord.compare ordering), or raise Not_found if the set is empty.
 
   
   <<
     val max_elt : t -> elt
   >>
   
       Same as Set.S.min_elt[20.28*Note Section 20-28::], but
      returns the largest element of the given set.
 
   
   <<
     val choose : t -> elt
   >>
   
       Return one element of the given set, or raise Not_found if the set is
      empty. Which element is chosen is unspecified, but equal elements will be
      chosen for equal sets.
 
   
   <<
     val split : elt -> t -> t * bool * t
   >>
   
       split x s returns a triple (l, present, r), where l is the set of
      elements of s that are strictly less than x; r is the set of elements of
      s that are strictly greater than x; present is false if s contains no
      element equal to x, or true if s contains an element equal to x.
  
    end
  
    Output signature of the functor Set.Make[20.28*Note Section 20-28::].
  
<<
  module Make : >>
   
  functor (Ord : OrderedType) -> S  with type elt = Ord.t
    Functor building an implementation of the set structure given a totally
   ordered type.
  
   

Node: Section 20-29,	Next: Section 20-30,	Prev: Section 20-28,	Up: Chapter 20
  

20.29   Module Sort : Sorting and merging lists.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

    This module is obsolete and exists only for
backward compatibility. The sorting functions in Array[20.2*Note Section 20-2::]
and List[20.17*Note Section 20-17::] should be used instead. The new functions are
faster and use less memory.Sorting and merging lists.
  
  

<<
  val list : ('a -> 'a -> bool) -> 'a list -> 'a list
>>
    
    Sort a list in increasing order according to an ordering predicate. The
   predicate should return true if its first argument is less than or equal to
   its second argument.
  

<<
  val array : ('a -> 'a -> bool) -> 'a array -> unit
>>
    
    Sort an array in increasing order according to an ordering predicate. The
   predicate should return true if its first argument is less than or equal to
   its second argument. The array is sorted in place.
  

<<
  val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
>>
    
    Merge two lists according to the given predicate. Assuming the two argument
   lists are sorted according to the predicate, merge returns a sorted list
   containing the elements from the two lists. The behavior is undefined if the
   two argument lists were not sorted.
  
   

Node: Section 20-30,	Next: Section 20-31,	Prev: Section 20-29,	Up: Chapter 20
  

20.30   Module Stack : Last-in first-out stacks.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  This module implements stacks (LIFOs), with in-place modification.
  
  

<<
  type 'a t 
>>
    
    The type of stacks containing elements of type 'a.
  

<<
  exception Empty
>>
    
    Raised when Stack.pop[20.30*Note Section 20-30::] or
   Stack.top[20.30*Note Section 20-30::] is applied to an empty stack.
  

<<
  val create : unit -> 'a t
>>
    
    Return a new stack, initially empty.
  

<<
  val push : 'a -> 'a t -> unit
>>
    
    push x s adds the element x at the top of stack s.
  

<<
  val pop : 'a t -> 'a
>>
    
    pop s removes and returns the topmost element in stack s, or raises Empty
   if the stack is empty.
  

<<
  val top : 'a t -> 'a
>>
    
    top s returns the topmost element in stack s, or raises Empty if the stack
   is empty.
  

<<
  val clear : 'a t -> unit
>>
    
    Discard all elements from a stack.
  

<<
  val copy : 'a t -> 'a t
>>
    
    Return a copy of the given stack.
  

<<
  val is_empty : 'a t -> bool
>>
    
    Return true if the given stack is empty, false otherwise.
  

<<
  val length : 'a t -> int
>>
    
    Return the number of elements in a stack.
  

<<
  val iter : ('a -> unit) -> 'a t -> unit
>>
    
    iter f s applies f in turn to all elements of s, from the element at the
   top of the stack to the element at the bottom of the stack. The stack itself
   is unchanged.
  
   

Node: Section 20-31,	Next: Section 20-32,	Prev: Section 20-30,	Up: Chapter 20
  

20.31   Module StdLabels : Standard labeled libraries.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  This meta-module provides labelized version of the
Array[20.2*Note Section 20-2::], List[20.17*Note Section 20-17::] and
String[20.33*Note Section 20-33::] modules.
  They only differ by their labels. Detailed interfaces can be found in
arrayLabels.mli, listLabels.mli and stringLabels.mli.
  
  
<<
  module Array : >>
   
    sig
  
  
   
   <<
     val length : 'a array -> int
   >>
  
   
   <<
     val get : 'a array -> int -> 'a
   >>
  
   
   <<
     val set : 'a array -> int -> 'a -> unit
   >>
  
   
   <<
     val make : int -> 'a -> 'a array
   >>
  
   
   <<
     val create : int -> 'a -> 'a array
   >>
  
   
   <<
     val init : int -> f:(int -> 'a) -> 'a array
   >>
  
   
   <<
     val make_matrix : dimx:int -> dimy:int -> 'a -> 'a array array
   >>
  
   
   <<
     val create_matrix : dimx:int -> dimy:int -> 'a -> 'a array array
   >>
  
   
   <<
     val append : 'a array -> 'a array -> 'a array
   >>
  
   
   <<
     val concat : 'a array list -> 'a array
   >>
  
   
   <<
     val sub : 'a array -> pos:int -> len:int -> 'a array
   >>
  
   
   <<
     val copy : 'a array -> 'a array
   >>
  
   
   <<
     val fill : 'a array -> pos:int -> len:int -> 'a -> unit
   >>
  
   
   <<
     val blit :
       src:'a array -> src_pos:int -> dst:'a array -> dst_pos:int -> len:int ->
   unit
   >>
  
   
   <<
     val to_list : 'a array -> 'a list
   >>
  
   
   <<
     val of_list : 'a list -> 'a array
   >>
  
   
   <<
     val iter : f:('a -> unit) -> 'a array -> unit
   >>
  
   
   <<
     val map : f:('a -> 'b) -> 'a array -> 'b array
   >>
  
   
   <<
     val iteri : f:(int -> 'a -> unit) -> 'a array -> unit
   >>
  
   
   <<
     val mapi : f:(int -> 'a -> 'b) -> 'a array -> 'b array
   >>
  
   
   <<
     val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b array -> 'a
   >>
  
   
   <<
     val fold_right : f:('a -> 'b -> 'b) -> 'a array -> init:'b -> 'b
   >>
  
   
   <<
     val sort : cmp:('a -> 'a -> int) -> 'a array -> unit
   >>
  
   
   <<
     val stable_sort : cmp:('a -> 'a -> int) -> 'a array -> unit
   >>
  
   
   <<
     val fast_sort : cmp:('a -> 'a -> int) -> 'a array -> unit
   >>
  
   
   <<
     val unsafe_get : 'a array -> int -> 'a
   >>
  
   
   <<
     val unsafe_set : 'a array -> int -> 'a -> unit
   >>
   
    end
  
<<
  module List : >>
   
    sig
  
  
   
   <<
     val length : 'a list -> int
   >>
  
   
   <<
     val hd : 'a list -> 'a
   >>
  
   
   <<
     val tl : 'a list -> 'a list
   >>
  
   
   <<
     val nth : 'a list -> int -> 'a
   >>
  
   
   <<
     val rev : 'a list -> 'a list
   >>
  
   
   <<
     val append : 'a list -> 'a list -> 'a list
   >>
  
   
   <<
     val rev_append : 'a list -> 'a list -> 'a list
   >>
  
   
   <<
     val concat : 'a list list -> 'a list
   >>
  
   
   <<
     val flatten : 'a list list -> 'a list
   >>
  
   
   <<
     val iter : f:('a -> unit) -> 'a list -> unit
   >>
  
   
   <<
     val map : f:('a -> 'b) -> 'a list -> 'b list
   >>
  
   
   <<
     val rev_map : f:('a -> 'b) -> 'a list -> 'b list
   >>
  
   
   <<
     val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a
   >>
  
   
   <<
     val fold_right : f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b
   >>
  
   
   <<
     val iter2 : f:('a -> 'b -> unit) -> 'a list -> 'b list -> unit
   >>
  
   
   <<
     val map2 : f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
   >>
  
   
   <<
     val rev_map2 : f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
   >>
  
   
   <<
     val fold_left2 :
       f:('a -> 'b -> 'c -> 'a) -> init:'a -> 'b list -> 'c list -> 'a
   >>
  
   
   <<
     val fold_right2 :
       f:('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> init:'c -> 'c
   >>
  
   
   <<
     val for_all : f:('a -> bool) -> 'a list -> bool
   >>
  
   
   <<
     val exists : f:('a -> bool) -> 'a list -> bool
   >>
  
   
   <<
     val for_all2 : f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool
   >>
  
   
   <<
     val exists2 : f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool
   >>
  
   
   <<
     val mem : 'a -> set:'a list -> bool
   >>
  
   
   <<
     val memq : 'a -> set:'a list -> bool
   >>
  
   
   <<
     val find : f:('a -> bool) -> 'a list -> 'a
   >>
  
   
   <<
     val filter : f:('a -> bool) -> 'a list -> 'a list
   >>
  
   
   <<
     val find_all : f:('a -> bool) -> 'a list -> 'a list
   >>
  
   
   <<
     val partition : f:('a -> bool) -> 'a list -> 'a list * 'a list
   >>
  
   
   <<
     val assoc : 'a -> ('a * 'b) list -> 'b
   >>
  
   
   <<
     val assq : 'a -> ('a * 'b) list -> 'b
   >>
  
   
   <<
     val mem_assoc : 'a -> map:('a * 'b) list -> bool
   >>
  
   
   <<
     val mem_assq : 'a -> map:('a * 'b) list -> bool
   >>
  
   
   <<
     val remove_assoc : 'a -> ('a * 'b) list -> ('a * 'b) list
   >>
  
   
   <<
     val remove_assq : 'a -> ('a * 'b) list -> ('a * 'b) list
   >>
  
   
   <<
     val split : ('a * 'b) list -> 'a list * 'b list
   >>
  
   
   <<
     val combine : 'a list -> 'b list -> ('a * 'b) list
   >>
  
   
   <<
     val sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list
   >>
  
   
   <<
     val stable_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list
   >>
  
   
   <<
     val fast_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list
   >>
  
   
   <<
     val merge : cmp:('a -> 'a -> int) -> 'a list -> 'a list -> 'a list
   >>
   
    end
  
<<
  module String : >>
   
    sig
  
  
   
   <<
     val length : string -> int
   >>
  
   
   <<
     val get : string -> int -> char
   >>
  
   
   <<
     val set : string -> int -> char -> unit
   >>
  
   
   <<
     val create : int -> string
   >>
  
   
   <<
     val make : int -> char -> string
   >>
  
   
   <<
     val copy : string -> string
   >>
  
   
   <<
     val sub : string -> pos:int -> len:int -> string
   >>
  
   
   <<
     val fill : string -> pos:int -> len:int -> char -> unit
   >>
  
   
   <<
     val blit :
       src:string -> src_pos:int -> dst:string -> dst_pos:int -> len:int ->
   unit
   >>
  
   
   <<
     val concat : sep:string -> string list -> string
   >>
  
   
   <<
     val iter : f:(char -> unit) -> string -> unit
   >>
  
   
   <<
     val escaped : string -> string
   >>
  
   
   <<
     val index : string -> char -> int
   >>
  
   
   <<
     val rindex : string -> char -> int
   >>
  
   
   <<
     val index_from : string -> int -> char -> int
   >>
  
   
   <<
     val rindex_from : string -> int -> char -> int
   >>
  
   
   <<
     val contains : string -> char -> bool
   >>
  
   
   <<
     val contains_from : string -> int -> char -> bool
   >>
  
   
   <<
     val rcontains_from : string -> int -> char -> bool
   >>
  
   
   <<
     val uppercase : string -> string
   >>
  
   
   <<
     val lowercase : string -> string
   >>
  
   
   <<
     val capitalize : string -> string
   >>
  
   
   <<
     val uncapitalize : string -> string
   >>
  
   
   <<
     type t = string 
   >>
  
   
   <<
     val compare : t -> t -> int
   >>
  
   
   <<
     val unsafe_get : string -> int -> char
   >>
  
   
   <<
     val unsafe_set : string -> int -> char -> unit
   >>
  
   
   <<
     val unsafe_blit :
       src:string -> src_pos:int -> dst:string -> dst_pos:int -> len:int ->
   unit
   >>
  
   
   <<
     val unsafe_fill : string -> pos:int -> len:int -> char -> unit
   >>
   
    end
  
   

Node: Section 20-32,	Next: Section 20-33,	Prev: Section 20-31,	Up: Chapter 20
  

20.32   Module Stream : Streams and parsers.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  
  

<<
  type 'a t 
>>
    
    The type of streams holding values of type 'a.
  

<<
  exception Failure
>>
    
    Raised by parsers when none of the first components of the stream patterns
   is accepted.
  

<<
  exception Error of string
>>
    
    Raised by parsers when the first component of a stream pattern is accepted,
   but one of the following components is rejected.
  

Stream builders
===============
  
  Warning: these functions create streams with fast access; it is illegal to
mix them with streams built with [< >]; would raise Failure when accessing such
mixed streams.

<<
  val from : (int -> 'a option) -> 'a t
>>
    
    Stream.from f returns a stream built from the function f. To create a new
   stream element, the function f is called with the current stream count. The
   user function f must return either Some <value> for a value or None to
   specify the end of the stream.
  

<<
  val of_list : 'a list -> 'a t
>>
    
    Return the stream holding the elements of the list in the same order.
  

<<
  val of_string : string -> char t
>>
    
    Return the stream of the characters of the string parameter.
  

<<
  val of_channel : Pervasives.in_channel -> char t
>>
    
    Return the stream of the characters read from the input channel.
  

Stream iterator
===============
  

<<
  val iter : ('a -> unit) -> 'a t -> unit
>>
    
    Stream.iter f s scans the whole stream s, applying function f in turn to
   each stream element encountered.
  

Predefined parsers
==================
  

<<
  val next : 'a t -> 'a
>>
    
    Return the first element of the stream and remove it from the stream. Raise
   Stream.Failure if the stream is empty.
  

<<
  val empty : 'a t -> unit
>>
    
    Return () if the stream is empty, else raise Stream.Failure.
  

Useful functions
================
  

<<
  val peek : 'a t -> 'a option
>>
    
    Return Some of "the first element" of the stream, or None if the stream is
   empty.
  

<<
  val junk : 'a t -> unit
>>
    
    Remove the first element of the stream, possibly unfreezing it before.
  

<<
  val count : 'a t -> int
>>
    
    Return the current count of the stream elements, i.e. the number of the
   stream elements discarded.
  

<<
  val npeek : int -> 'a t -> 'a list
>>
    
    npeek n returns the list of the n first elements of the stream, or all its
   remaining elements if less than n elements are available.
  
   

Node: Section 20-33,	Next: Section 20-34,	Prev: Section 20-32,	Up: Chapter 20
  

20.33   Module String : String operations.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  Given a string s of length l, we call character number in s the index of a
character in s. Indexes start at 0, and we will call a character number valid
in s if it falls within the range [0...l-1]. A position is the point between
two characters or at the beginning or end of the string. We call a position
valid in s if it falls within the range [0...l]. Note that character number n
is between positions n and n+1.
  Two parameters start and len are said to designate a valid substring of s if
len >= 0 and start and start+len are valid positions in s.
  
  

<<
  val length : string -> int
>>
    
    Return the length (number of characters) of the given string.
  

<<
  val get : string -> int -> char
>>
    
    String.get s n returns character number n in string s. You can also write
   s.[n] instead of String.get s n.
   Raise Invalid_argument if n not a valid character number in s.
  

<<
  val set : string -> int -> char -> unit
>>
    
    String.set s n c modifies string s in place, replacing the character number
   n by c. You can also write s.[n] <- c instead of String.set s n c.
   Raise Invalid_argument if n is not a valid character number in s.
  

<<
  val create : int -> string
>>
    
    String.create n returns a fresh string of length n. The string initially
   contains arbitrary characters.
   Raise Invalid_argument if n < 0 or n >
   Sys.max_string_length[20.34].
  

<<
  val make : int -> char -> string
>>
    
    String.make n c returns a fresh string of length n, filled with the
   character c.
   Raise Invalid_argument if n < 0 or n >
   Sys.max_string_length[20.34].
  

<<
  val copy : string -> string
>>
    
    Return a copy of the given string.
  

<<
  val sub : string -> int -> int -> string
>>
    
    String.sub s start len returns a fresh string of length len, containing the
   substring of s that starts at position start and has length len.
   Raise Invalid_argument if start and len do not designate a valid substring
   of s.
  

<<
  val fill : string -> int -> int -> char -> unit
>>
    
    String.fill s start len c modifies string s in place, replacing len
   characters by c, starting at start.
   Raise Invalid_argument if start and len do not designate a valid substring
   of s.
  

<<
  val blit : string -> int -> string -> int -> int -> unit
>>
    
    String.blit src srcoff dst dstoff len copies len characters from string
   src, starting at character number srcoff, to string dst, starting at
   character number dstoff. It works correctly even if src and dst are the same
   string, and the source and destination intervals overlap.
   Raise Invalid_argument if srcoff and len do not designate a valid substring
   of src, or if dstoff and len do not designate a valid substring of dst.
  

<<
  val concat : string -> string list -> string
>>
    
    String.concat sep sl concatenates the list of strings sl, inserting the
   separator string sep between each.
  

<<
  val iter : (char -> unit) -> string -> unit
>>
    
    String.iter f s applies function f in turn to all the characters of s. It
   is equivalent to f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ().
  

<<
  val escaped : string -> string
>>
    
    Return a copy of the argument, with special characters represented by
   escape sequences, following the lexical conventions of Objective Caml. If
   there is no special character in the argument, return the original string
   itself, not a copy.
  

<<
  val index : string -> char -> int
>>
    
    String.index s c returns the character number of the first occurrence of
   character c in string s.
   Raise Not_found if c does not occur in s.
  

<<
  val rindex : string -> char -> int
>>
    
    String.rindex s c returns the character number of the last occurrence of
   character c in string s.
   Raise Not_found if c does not occur in s.
  

<<
  val index_from : string -> int -> char -> int
>>
    
    String.index_from s i c returns the character number of the first
   occurrence of character c in string s after position i. String.index s c is
   equivalent to String.index_from s 0 c.
   Raise Invalid_argument if i is not a valid position in s. Raise Not_found if
   c does not occur in s after position i.
  

<<
  val rindex_from : string -> int -> char -> int
>>
    
    String.rindex_from s i c returns the character number of the last
   occurrence of character c in string s before position i+1. String.rindex s c
   is equivalent to String.rindex_from s (String.length s - 1) c.
   Raise Invalid_argument if i+1 is not a valid position in s. Raise Not_found
   if c does not occur in s before position i+1.
  

<<
  val contains : string -> char -> bool
>>
    
    String.contains s c tests if character c appears in the string s.
  

<<
  val contains_from : string -> int -> char -> bool
>>
    
    String.contains_from s start c tests if character c appears in s after
   position start. String.contains s c is equivalent to String.contains_from s
   0 c.
   Raise Invalid_argument if start is not a valid position in s.
  

<<
  val rcontains_from : string -> int -> char -> bool
>>
    
    String.rcontains_from s stop c tests if character c appears in s before
   position stop+1.
   Raise Invalid_argument if stop < 0 or stop+1 is not a valid position in s.
  

<<
  val uppercase : string -> string
>>
    
    Return a copy of the argument, with all lowercase letters translated to
   uppercase, including accented letters of the ISO Latin-1 (8859-1) character
   set.
  

<<
  val lowercase : string -> string
>>
    
    Return a copy of the argument, with all uppercase letters translated to
   lowercase, including accented letters of the ISO Latin-1 (8859-1) character
   set.
  

<<
  val capitalize : string -> string
>>
    
    Return a copy of the argument, with the first character set to uppercase.
  

<<
  val uncapitalize : string -> string
>>
    
    Return a copy of the argument, with the first character set to lowercase.
  

<<
  type t = string 
>>
    
    An alias for the type of strings.
  

<<
  val compare : t -> t -> int
>>
    
    The comparison function for strings, with the same specification as
   Pervasives.compare[19.2*Note Section 19-2::]. Along with the type
   t, this function compare allows the module String to be passed as argument
   to the functors Set.Make[20.28*Note Section 20-28::] and
   Map.Make[20.18*Note Section 20-18::].
  
   

Node: Section 20-34,	Next: Section 20-35,	Prev: Section 20-33,	Up: Chapter 20
  

20.34   Module Sys : System interface.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  
  

<<
  val argv : string array
>>
    
    The command line arguments given to the process. The first element is the
   command name used to invoke the program. The following elements are the
   command-line arguments given to the program.
  

<<
  val executable_name : string
>>
    
    The name of the file containing the executable currently running.
  

<<
  val file_exists : string -> bool
>>
    
    Test if a file with the given name exists.
  

<<
  val is_directory : string -> bool
>>
    
    Returns true if the given name refers to a directory, false if it refers to
   another kind of file. Raise Sys_error if no file exists with the given name.
   Since: 3.12.0
  

<<
  val remove : string -> unit
>>
    
    Remove the given file name from the file system.
  

<<
  val rename : string -> string -> unit
>>
    
    Rename a file. The first argument is the old name and the second is the new
   name. If there is already another file under the new name, rename may
   replace it, or raise an exception, depending on your operating system.
  

<<
  val getenv : string -> string
>>
    
    Return the value associated to a variable in the process environment. Raise
   Not_found if the variable is unbound.
  

<<
  val command : string -> int
>>
    
    Execute the given shell command and return its exit code.
  

<<
  val time : unit -> float
>>
    
    Return the processor time, in seconds, used by the program since the
   beginning of execution.
  

<<
  val chdir : string -> unit
>>
    
    Change the current working directory of the process.
  

<<
  val getcwd : unit -> string
>>
    
    Return the current working directory of the process.
  

<<
  val readdir : string -> string array
>>
    
    Return the names of all files present in the given directory. Names
   denoting the current directory and the parent directory ("." and ".." in
   Unix) are not returned. Each string in the result is a file name rather than
   a complete path. There is no guarantee that the name strings in the
   resulting array will appear in any specific order; they are not, in
   particular, guaranteed to appear in alphabetical order.
  

<<
  val interactive : bool Pervasives.ref
>>
    
    This reference is initially set to false in standalone programs and to true
   if the code is being executed under the interactive toplevel system ocaml.
  

<<
  val os_type : string
>>
    
    Operating system currently executing the Caml program. One of
     
      - "Unix" (for all Unix versions, including Linux and Mac OS X), 
      - "Win32" (for MS-Windows, OCaml compiled with MSVC++ or Mingw), 
      - "Cygwin" (for MS-Windows, OCaml compiled with Cygwin). 
   
  

<<
  val word_size : int
>>
    
    Size of one word on the machine currently executing the Caml program, in
   bits: 32 or 64.
  

<<
  val max_string_length : int
>>
    
    Maximum length of a string.
  

<<
  val max_array_length : int
>>
    
    Maximum length of a normal array. The maximum length of a float array is
   max_array_length/2 on 32-bit machines and max_array_length on 64-bit
   machines.
  

Signal handling
===============
  

<<
  type signal_behavior =
    | Signal_default
    | Signal_ignore
    | Signal_handle of (int -> unit)
>>
   
    What to do when receiving a signal:
     
      - Signal_default: take the default behavior (usually: abort the program) 
      - Signal_ignore: ignore the signal 
      - Signal_handle f: call function f, giving it the signal number as
      argument. 
   
   

<<
  val signal : int -> signal_behavior -> signal_behavior
>>
    
    Set the behavior of the system on receipt of a given signal. The first
   argument is the signal number. Return the behavior previously associated
   with the signal. If the signal number is invalid (or not available on your
   system), an Invalid_argument exception is raised.
  

<<
  val set_signal : int -> signal_behavior -> unit
>>
    
    Same as Sys.signal[20.34*Note Section 20-34::] but return value is
   ignored.
  

Signal numbers for the standard POSIX signals.
----------------------------------------------
  

<<
  val sigabrt : int
>>
    
    Abnormal termination
  

<<
  val sigalrm : int
>>
    
    Timeout
  

<<
  val sigfpe : int
>>
    
    Arithmetic exception
  

<<
  val sighup : int
>>
    
    Hangup on controlling terminal
  

<<
  val sigill : int
>>
    
    Invalid hardware instruction
  

<<
  val sigint : int
>>
    
    Interactive interrupt (ctrl-C)
  

<<
  val sigkill : int
>>
    
    Termination (cannot be ignored)
  

<<
  val sigpipe : int
>>
    
    Broken pipe
  

<<
  val sigquit : int
>>
    
    Interactive termination
  

<<
  val sigsegv : int
>>
    
    Invalid memory reference
  

<<
  val sigterm : int
>>
    
    Termination
  

<<
  val sigusr1 : int
>>
    
    Application-defined signal 1
  

<<
  val sigusr2 : int
>>
    
    Application-defined signal 2
  

<<
  val sigchld : int
>>
    
    Child process terminated
  

<<
  val sigcont : int
>>
    
    Continue
  

<<
  val sigstop : int
>>
    
    Stop
  

<<
  val sigtstp : int
>>
    
    Interactive stop
  

<<
  val sigttin : int
>>
    
    Terminal read from background process
  

<<
  val sigttou : int
>>
    
    Terminal write from background process
  

<<
  val sigvtalrm : int
>>
    
    Timeout in virtual time
  

<<
  val sigprof : int
>>
    
    Profiling interrupt
  

<<
  exception Break
>>
    
    Exception raised on interactive interrupt if
   Sys.catch_break[20.34*Note Section 20-34::] is on.
  

<<
  val catch_break : bool -> unit
>>
    
    catch_break governs whether interactive interrupt (ctrl-C) terminates the
   program or raises the Break exception. Call catch_break true to enable
   raising Break, and catch_break false to let the system terminate the program
   on user interrupt.
  

<<
  val ocaml_version : string
>>
    
    ocaml_version is the version of Objective Caml. It is a string of the form
   "major.minor[.patchlevel][+additional-info]", where major, minor, and
   patchlevel are integers, and additional-info is an arbitrary string. The
   [.patchlevel] and [+additional-info] parts may be absent.
  
   

Node: Section 20-35,	Next: Chapter 21,	Prev: Section 20-34,	Up: Chapter 20
  

20.35   Module Weak : Arrays of weak pointers and hash tables of weak pointers.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  
  

Low-level functions
===================
  

<<
  type 'a t 
>>
    
    The type of arrays of weak pointers (weak arrays). A weak pointer is a
   value that the garbage collector may erase whenever the value is not used
   any more (through normal pointers) by the program. Note that finalisation
   functions are run after the weak pointers are erased.
   A weak pointer is said to be full if it points to a value, empty if the
   value was erased by the GC.
   Notes:
     
      - Integers are not allocated and cannot be stored in weak arrays. 
      - Weak arrays cannot be marshaled using
      Pervasives.output_value[19.2] nor the functions of the Marshal[20.19*Note Section 20-19::] module. 
   
  

<<
  val create : int -> 'a t
>>
    
    Weak.create n returns a new weak array of length n. All the pointers are
   initially empty. Raise Invalid_argument if n is negative or greater than
   Sys.max_array_length[20.34]-1.
  

<<
  val length : 'a t -> int
>>
    
    Weak.length ar returns the length (number of elements) of ar.
  

<<
  val set : 'a t -> int -> 'a option -> unit
>>
    
    Weak.set ar n (Some el) sets the nth cell of ar to be a (full) pointer to
   el; Weak.set ar n None sets the nth cell of ar to empty. Raise
   Invalid_argument "Weak.set" if n is not in the range 0 to
   Weak.length[20.35*Note Section 20-35::] a - 1.
  

<<
  val get : 'a t -> int -> 'a option
>>
    
    Weak.get ar n returns None if the nth cell of ar is empty, Some x (where x
   is the value) if it is full. Raise Invalid_argument "Weak.get" if n is not
   in the range 0 to Weak.length[20.35*Note Section 20-35::] a - 1.
  

<<
  val get_copy : 'a t -> int -> 'a option
>>
    
    Weak.get_copy ar n returns None if the nth cell of ar is empty, Some x
   (where x is a (shallow) copy of the value) if it is full. In addition to
   pitfalls with mutable values, the interesting difference with get is that
   get_copy does not prevent the incremental GC from erasing the value in its
   current cycle (get may delay the erasure to the next GC cycle). Raise
   Invalid_argument "Weak.get" if n is not in the range 0 to
   Weak.length[20.35*Note Section 20-35::] a - 1.
  

<<
  val check : 'a t -> int -> bool
>>
    
    Weak.check ar n returns true if the nth cell of ar is full, false if it is
   empty. Note that even if Weak.check ar n returns true, a subsequent
   Weak.get[20.35*Note Section 20-35::] ar n can return None.
  

<<
  val fill : 'a t -> int -> int -> 'a option -> unit
>>
    
    Weak.fill ar ofs len el sets to el all pointers of ar from ofs to ofs + len
   - 1. Raise Invalid_argument "Weak.fill" if ofs and len do not designate a
   valid subarray of a.
  

<<
  val blit : 'a t -> int -> 'a t -> int -> int -> unit
>>
    
    Weak.blit ar1 off1 ar2 off2 len copies len weak pointers from ar1 (starting
   at off1) to ar2 (starting at off2). It works correctly even if ar1 and ar2
   are the same. Raise Invalid_argument "Weak.blit" if off1 and len do not
   designate a valid subarray of ar1, or if off2 and len do not designate a
   valid subarray of ar2.
  

Weak hash tables
================
  
  A weak hash table is a hashed set of values. Each value may magically
disappear from the set when it is not used by the rest of the program any more.
This is normally used to share data structures without inducing memory leaks.
Weak hash tables are defined on values from a
Hashtbl.HashedType[20.12*Note Section 20-12::] module; the equal
relation and hash function are taken from that module. We will say that v is an
instance of x if equal x v is true.
  The equal relation must be able to work on a shallow copy of the values and
give the same result as with the values themselves.
<<
  module type S = >>
   
    sig
  
  
   
   <<
     type data 
   >>
   
       The type of the elements stored in the table.
 
   
   <<
     type t 
   >>
   
       The type of tables that contain elements of type data. Note that weak
      hash tables cannot be marshaled using
      Pervasives.output_value[19.2] or the functions of the Marshal[20.19*Note Section 20-19::] module.
 
   
   <<
     val create : int -> t
   >>
   
       create n creates a new empty weak hash table, of initial size n. The
      table will grow as needed.
 
   
   <<
     val clear : t -> unit
   >>
   
       Remove all elements from the table.
 
   
   <<
     val merge : t -> data -> data
   >>
   
       merge t x returns an instance of x found in t if any, or else adds x to
      t and return x.
 
   
   <<
     val add : t -> data -> unit
   >>
   
       add t x adds x to t. If there is already an instance of x in t, it is
      unspecified which one will be returned by subsequent calls to find and
      merge.
 
   
   <<
     val remove : t -> data -> unit
   >>
   
       remove t x removes from t one instance of x. Does nothing if there is no
      instance of x in t.
 
   
   <<
     val find : t -> data -> data
   >>
   
       find t x returns an instance of x found in t. Raise Not_found if there
      is no such element.
 
   
   <<
     val find_all : t -> data -> data list
   >>
   
       find_all t x returns a list of all the instances of x found in t.
 
   
   <<
     val mem : t -> data -> bool
   >>
   
       mem t x returns true if there is at least one instance of x in t, false
      otherwise.
 
   
   <<
     val iter : (data -> unit) -> t -> unit
   >>
   
       iter f t calls f on each element of t, in some unspecified order. It is
      not specified what happens if f tries to change t itself.
 
   
   <<
     val fold : (data -> 'a -> 'a) -> t -> 'a -> 'a
   >>
   
       fold f t init computes (f d1 (... (f dN init))) where d1 ... dN are the
      elements of t in some unspecified order. It is not specified what happens
      if f tries to change t itself.
 
   
   <<
     val count : t -> int
   >>
   
       Count the number of elements in the table. count t gives the same result
      as fold (fun _ n -> n+1) t 0 but does not delay the deallocation of the
      dead elements.
 
   
   <<
     val stats : t -> int * int * int * int * int * int
   >>
   
       Return statistics on the table. The numbers are, in order: table length,
      number of entries, sum of bucket lengths, smallest bucket length, median
      bucket length, biggest bucket length.
  
    end
  
    The output signature of the functor Weak.Make[20.35*Note Section 20-35::].
  
<<
  module Make : >>
   
  functor (H : Hashtbl.HashedType) -> S  with type data = H.t
    Functor building an implementation of the weak hash table structure.
  
    

Node: Chapter 21,	Next: Section 21-1,	Prev: Chapter 20,	Up: Part IV
  

Chapter 21     The unix library: Unix system calls
**************************************************
   
  The unix library makes many Unix system calls and system-related library
functions available to Objective Caml programs. This chapter describes briefly
the functions provided. Refer to sections 2 and 3 of the Unix manual for more
details on the behavior of these functions.
  Not all functions are provided by all Unix variants. If some functions are
not available, they will raise Invalid_arg when called.
  Programs that use the unix library must be linked as follows: 
<<
          ocamlc other options unix.cma other files
          ocamlopt other options unix.cmxa other files
>>
   For interactive use of the unix library, do: 
<<
          ocamlmktop -o mytop unix.cma
          ./mytop
>>
   or (if dynamic linking of C libraries is supported on your platform), start
ocaml and type #load "unix.cma";;.
     Windows: 
    A fairly complete emulation of the Unix system calls is provided in the
   Windows version of Objective Caml. The end of this chapter gives more
   information on the functions that are not supported under Windows. 
  
* Menu:

* Section 21-1::	Module Unix : Interface to the Unix system
* Section 21-2::	Module UnixLabels: labelized version of the interface


Node: Section 21-1,	Next: Section 21-2,	Prev: Chapter 21,	Up: Chapter 21
  

21.1   Module Unix : Interface to the Unix system
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  
  

Error report
============
  

<<
  type error =
    | E2BIG
>>
   
    Argument list too long 
   
<<
    | EACCES
>>
   
    Permission denied 
   
<<
    | EAGAIN
>>
   
    Resource temporarily unavailable; try again 
   
<<
    | EBADF
>>
   
    Bad file descriptor 
   
<<
    | EBUSY
>>
   
    Resource unavailable 
   
<<
    | ECHILD
>>
   
    No child process 
   
<<
    | EDEADLK
>>
   
    Resource deadlock would occur 
   
<<
    | EDOM
>>
   
    Domain error for math functions, etc. 
   
<<
    | EEXIST
>>
   
    File exists 
   
<<
    | EFAULT
>>
   
    Bad address 
   
<<
    | EFBIG
>>
   
    File too large 
   
<<
    | EINTR
>>
   
    Function interrupted by signal 
   
<<
    | EINVAL
>>
   
    Invalid argument 
   
<<
    | EIO
>>
   
    Hardware I/O error 
   
<<
    | EISDIR
>>
   
    Is a directory 
   
<<
    | EMFILE
>>
   
    Too many open files by the process 
   
<<
    | EMLINK
>>
   
    Too many links 
   
<<
    | ENAMETOOLONG
>>
   
    Filename too long 
   
<<
    | ENFILE
>>
   
    Too many open files in the system 
   
<<
    | ENODEV
>>
   
    No such device 
   
<<
    | ENOENT
>>
   
    No such file or directory 
   
<<
    | ENOEXEC
>>
   
    Not an executable file 
   
<<
    | ENOLCK
>>
   
    No locks available 
   
<<
    | ENOMEM
>>
   
    Not enough memory 
   
<<
    | ENOSPC
>>
   
    No space left on device 
   
<<
    | ENOSYS
>>
   
    Function not supported 
   
<<
    | ENOTDIR
>>
   
    Not a directory 
   
<<
    | ENOTEMPTY
>>
   
    Directory not empty 
   
<<
    | ENOTTY
>>
   
    Inappropriate I/O control operation 
   
<<
    | ENXIO
>>
   
    No such device or address 
   
<<
    | EPERM
>>
   
    Operation not permitted 
   
<<
    | EPIPE
>>
   
    Broken pipe 
   
<<
    | ERANGE
>>
   
    Result too large 
   
<<
    | EROFS
>>
   
    Read-only file system 
   
<<
    | ESPIPE
>>
   
    Invalid seek e.g. on a pipe 
   
<<
    | ESRCH
>>
   
    No such process 
   
<<
    | EXDEV
>>
   
    Invalid link 
   
<<
    | EWOULDBLOCK
>>
   
    Operation would block 
   
<<
    | EINPROGRESS
>>
   
    Operation now in progress 
   
<<
    | EALREADY
>>
   
    Operation already in progress 
   
<<
    | ENOTSOCK
>>
   
    Socket operation on non-socket 
   
<<
    | EDESTADDRREQ
>>
   
    Destination address required 
   
<<
    | EMSGSIZE
>>
   
    Message too long 
   
<<
    | EPROTOTYPE
>>
   
    Protocol wrong type for socket 
   
<<
    | ENOPROTOOPT
>>
   
    Protocol not available 
   
<<
    | EPROTONOSUPPORT
>>
   
    Protocol not supported 
   
<<
    | ESOCKTNOSUPPORT
>>
   
    Socket type not supported 
   
<<
    | EOPNOTSUPP
>>
   
    Operation not supported on socket 
   
<<
    | EPFNOSUPPORT
>>
   
    Protocol family not supported 
   
<<
    | EAFNOSUPPORT
>>
   
    Address family not supported by protocol family 
   
<<
    | EADDRINUSE
>>
   
    Address already in use 
   
<<
    | EADDRNOTAVAIL
>>
   
    Can't assign requested address 
   
<<
    | ENETDOWN
>>
   
    Network is down 
   
<<
    | ENETUNREACH
>>
   
    Network is unreachable 
   
<<
    | ENETRESET
>>
   
    Network dropped connection on reset 
   
<<
    | ECONNABORTED
>>
   
    Software caused connection abort 
   
<<
    | ECONNRESET
>>
   
    Connection reset by peer 
   
<<
    | ENOBUFS
>>
   
    No buffer space available 
   
<<
    | EISCONN
>>
   
    Socket is already connected 
   
<<
    | ENOTCONN
>>
   
    Socket is not connected 
   
<<
    | ESHUTDOWN
>>
   
    Can't send after socket shutdown 
   
<<
    | ETOOMANYREFS
>>
   
    Too many references: can't splice 
   
<<
    | ETIMEDOUT
>>
   
    Connection timed out 
   
<<
    | ECONNREFUSED
>>
   
    Connection refused 
   
<<
    | EHOSTDOWN
>>
   
    Host is down 
   
<<
    | EHOSTUNREACH
>>
   
    No route to host 
   
<<
    | ELOOP
>>
   
    Too many levels of symbolic links 
   
<<
    | EOVERFLOW
>>
   
    File size or position not representable 
   
<<
    | EUNKNOWNERR of int
>>
   
    Unknown error 
    
    The type of error codes. Errors defined in the POSIX standard and
   additional errors from UNIX98 and BSD. All other errors are mapped to
   EUNKNOWNERR.
  

<<
  exception Unix_error of error * string * string
>>
    
    Raised by the system calls below when an error is encountered. The first
   component is the error code; the second component is the function name; the
   third component is the string parameter to the function, if it has one, or
   the empty string otherwise.
  

<<
  val error_message : error -> string
>>
    
    Return a string describing the given error code.
  

<<
  val handle_unix_error : ('a -> 'b) -> 'a -> 'b
>>
    
    handle_unix_error f x applies f to x and returns the result. If the
   exception Unix_error is raised, it prints a message describing the error and
   exits with code 2.
  

Access to the process environment
=================================
  

<<
  val environment : unit -> string array
>>
    
    Return the process environment, as an array of strings with the format
   "variable=value".
  

<<
  val getenv : string -> string
>>
    
    Return the value associated to a variable in the process environment. Raise
   Not_found if the variable is unbound. (This function is identical to
   Sys.getenv.)
  

<<
  val putenv : string -> string -> unit
>>
    
    Unix.putenv name value sets the value associated to a variable in the
   process environment. name is the name of the environment variable, and value
   its new associated value.
  

Process handling
================
  

<<
  type process_status =
    | WEXITED of int
>>
   
    The process terminated normally by exit; the argument is the return code. 
   
<<
    | WSIGNALED of int
>>
   
    The process was killed by a signal; the argument is the signal number. 
   
<<
    | WSTOPPED of int
>>
   
    The process was stopped by a signal; the argument is the signal number. 
    
    The termination status of a process. See module Sys[20.34*Note Section 20-34::]
   for the definitions of the standard signal numbers. Note that they are not
   the numbers used by the OS.
  

<<
  type wait_flag =
    | WNOHANG
>>
   
    do not block if no child has died yet, but immediately return with a pid
   equal to 0. 
   
<<
    | WUNTRACED
>>
   
    report also the children that receive stop signals. 
    
    Flags for Unix.waitpid[21.1*Note Section 21-1::].
  

<<
  val execv : string -> string array -> 'a
>>
    
    execv prog args execute the program in file prog, with the arguments args,
   and the current process environment. These execv* functions never return: on
   success, the current program is replaced by the new one; on failure, a
   Unix.Unix_error[21.1*Note Section 21-1::]
   exception is raised.
  

<<
  val execve : string -> string array -> string array -> 'a
>>
    
    Same as Unix.execv[21.1*Note Section 21-1::], except that the third
   argument provides the environment to the program executed.
  

<<
  val execvp : string -> string array -> 'a
>>
    
    Same as Unix.execv[21.1*Note Section 21-1::], except that the program is
   searched in the path.
  

<<
  val execvpe : string -> string array -> string array -> 'a
>>
    
    Same as Unix.execve[21.1*Note Section 21-1::], except that the program
   is searched in the path.
  

<<
  val fork : unit -> int
>>
    
    Fork a new process. The returned integer is 0 for the child process, the
   pid of the child process for the parent process.
  

<<
  val wait : unit -> int * process_status
>>
    
    Wait until one of the children processes die, and return its pid and
   termination status.
  

<<
  val waitpid : wait_flag list -> int -> int * process_status
>>
    
    Same as Unix.wait[21.1*Note Section 21-1::], but waits for the child
   process whose pid is given. A pid of -1 means wait for any child. A pid of 0
   means wait for any child in the same process group as the current process.
   Negative pid arguments represent process groups. The list of options
   indicates whether waitpid should return immediately without waiting, or also
   report stopped children.
  

<<
  val system : string -> process_status
>>
    
    Execute the given command, wait until it terminates, and return its
   termination status. The string is interpreted by the shell /bin/sh and
   therefore can contain redirections, quotes, variables, etc. The result
   WEXITED 127 indicates that the shell couldn't be executed.
  

<<
  val getpid : unit -> int
>>
    
    Return the pid of the process.
  

<<
  val getppid : unit -> int
>>
    
    Return the pid of the parent process.
  

<<
  val nice : int -> int
>>
    
    Change the process priority. The integer argument is added to the "nice"
   value. (Higher values of the "nice" value mean lower priorities.) Return the
   new nice value.
  

Basic file input/output
=======================
  

<<
  type file_descr 
>>
    
    The abstract type of file descriptors.
  

<<
  val stdin : file_descr
>>
    
    File descriptor for standard input.
  

<<
  val stdout : file_descr
>>
    
    File descriptor for standard output.
  

<<
  val stderr : file_descr
>>
    
    File descriptor for standard error.
  

<<
  type open_flag =
    | O_RDONLY
>>
   
    Open for reading 
   
<<
    | O_WRONLY
>>
   
    Open for writing 
   
<<
    | O_RDWR
>>
   
    Open for reading and writing 
   
<<
    | O_NONBLOCK
>>
   
    Open in non-blocking mode 
   
<<
    | O_APPEND
>>
   
    Open for append 
   
<<
    | O_CREAT
>>
   
    Create if nonexistent 
   
<<
    | O_TRUNC
>>
   
    Truncate to 0 length if existing 
   
<<
    | O_EXCL
>>
   
    Fail if existing 
   
<<
    | O_NOCTTY
>>
   
    Don't make this dev a controlling tty 
   
<<
    | O_DSYNC
>>
   
    Writes complete as `Synchronised I/O data integrity completion' 
   
<<
    | O_SYNC
>>
   
    Writes complete as `Synchronised I/O file integrity completion' 
   
<<
    | O_RSYNC
>>
   
    Reads complete as writes (depending on O_SYNC/O_DSYNC) 
    
    The flags to Unix.openfile[21.1*Note Section 21-1::].
  

<<
  type file_perm = int 
>>
    
    The type of file access rights, e.g. 0o640 is read and write for user, read
   for group, none for others
  

<<
  val openfile : string -> open_flag list -> file_perm -> file_descr
>>
    
    Open the named file with the given flags. Third argument is the permissions
   to give to the file if it is created. Return a file descriptor on the named
   file.
  

<<
  val close : file_descr -> unit
>>
    
    Close a file descriptor.
  

<<
  val read : file_descr -> string -> int -> int -> int
>>
    
    read fd buff ofs len reads len characters from descriptor fd, storing them
   in string buff, starting at position ofs in string buff. Return the number
   of characters actually read.
  

<<
  val write : file_descr -> string -> int -> int -> int
>>
    
    write fd buff ofs len writes len characters to descriptor fd, taking them
   from string buff, starting at position ofs in string buff. Return the number
   of characters actually written. write repeats the writing operation until
   all characters have been written or an error occurs.
  

<<
  val single_write : file_descr -> string -> int -> int -> int
>>
    
    Same as write, but attempts to write only once. Thus, if an error occurs,
   single_write guarantees that no data has been written.
  

Interfacing with the standard input/output library
==================================================
  

<<
  val in_channel_of_descr : file_descr -> Pervasives.in_channel
>>
    
    Create an input channel reading from the given descriptor. The channel is
   initially in binary mode; use set_binary_mode_in ic false if text mode is
   desired.
  

<<
  val out_channel_of_descr : file_descr -> Pervasives.out_channel
>>
    
    Create an output channel writing on the given descriptor. The channel is
   initially in binary mode; use set_binary_mode_out oc false if text mode is
   desired.
  

<<
  val descr_of_in_channel : Pervasives.in_channel -> file_descr
>>
    
    Return the descriptor corresponding to an input channel.
  

<<
  val descr_of_out_channel : Pervasives.out_channel -> file_descr
>>
    
    Return the descriptor corresponding to an output channel.
  

Seeking and truncating
======================
  

<<
  type seek_command =
    | SEEK_SET
>>
   
    indicates positions relative to the beginning of the file 
   
<<
    | SEEK_CUR
>>
   
    indicates positions relative to the current position 
   
<<
    | SEEK_END
>>
   
    indicates positions relative to the end of the file 
    
    Positioning modes for Unix.lseek[21.1*Note Section 21-1::].
  

<<
  val lseek : file_descr -> int -> seek_command -> int
>>
    
    Set the current position for a file descriptor
  

<<
  val truncate : string -> int -> unit
>>
    
    Truncates the named file to the given size.
  

<<
  val ftruncate : file_descr -> int -> unit
>>
    
    Truncates the file corresponding to the given descriptor to the given size.
  

File status
===========
  

<<
  type file_kind =
    | S_REG
>>
   
    Regular file 
   
<<
    | S_DIR
>>
   
    Directory 
   
<<
    | S_CHR
>>
   
    Character device 
   
<<
    | S_BLK
>>
   
    Block device 
   
<<
    | S_LNK
>>
   
    Symbolic link 
   
<<
    | S_FIFO
>>
   
    Named pipe 
   
<<
    | S_SOCK
>>
   
    Socket 
   

<<
  type stats = {
    st_dev : int ;
>>
   
    Device number 
   
<<
    st_ino : int ;
>>
   
    Inode number 
   
<<
    st_kind : file_kind ;
>>
   
    Kind of the file 
   
<<
    st_perm : file_perm ;
>>
   
    Access rights 
   
<<
    st_nlink : int ;
>>
   
    Number of links 
   
<<
    st_uid : int ;
>>
   
    User id of the owner 
   
<<
    st_gid : int ;
>>
   
    Group ID of the file's group 
   
<<
    st_rdev : int ;
>>
   
    Device minor number 
   
<<
    st_size : int ;
>>
   
    Size in bytes 
   
<<
    st_atime : float ;
>>
   
    Last access time 
   
<<
    st_mtime : float ;
>>
   
    Last modification time 
   
<<
    st_ctime : float ;
>>
   
    Last status change time 
   
<<
  }
>>
    
    The information returned by the Unix.stat[21.1*Note Section 21-1::]
   calls.
  

<<
  val stat : string -> stats
>>
    
    Return the information for the named file.
  

<<
  val lstat : string -> stats
>>
    
    Same as Unix.stat[21.1*Note Section 21-1::], but in case the file is a
   symbolic link, return the information for the link itself.
  

<<
  val fstat : file_descr -> stats
>>
    
    Return the information for the file associated with the given descriptor.
  

<<
  val isatty : file_descr -> bool
>>
    
    Return true if the given file descriptor refers to a terminal or console
   window, false otherwise.
  

File operations on large files
==============================
  
<<
  module LargeFile : >>
   
    sig
  
  
   
   <<
     val lseek : Unix.file_descr -> int64 -> Unix.seek_command -> int64
   >>
  
   
   <<
     val truncate : string -> int64 -> unit
   >>
  
   
   <<
     val ftruncate : Unix.file_descr -> int64 -> unit
   >>
  
   
   <<
     type stats = {
       st_dev : int ;
   >>
  
       Device number 
  
   <<
       st_ino : int ;
   >>
  
       Inode number 
  
   <<
       st_kind : Unix.file_kind ;
   >>
  
       Kind of the file 
  
   <<
       st_perm : Unix.file_perm ;
   >>
  
       Access rights 
  
   <<
       st_nlink : int ;
   >>
  
       Number of links 
  
   <<
       st_uid : int ;
   >>
  
       User id of the owner 
  
   <<
       st_gid : int ;
   >>
  
       Group ID of the file's group 
  
   <<
       st_rdev : int ;
   >>
  
       Device minor number 
  
   <<
       st_size : int64 ;
   >>
  
       Size in bytes 
  
   <<
       st_atime : float ;
   >>
  
       Last access time 
  
   <<
       st_mtime : float ;
   >>
  
       Last modification time 
  
   <<
       st_ctime : float ;
   >>
  
       Last status change time 
  
   <<
     }
   >>
  
   
   <<
     val stat : string -> stats
   >>
  
   
   <<
     val lstat : string -> stats
   >>
  
   
   <<
     val fstat : Unix.file_descr -> stats
   >>
   
    end
  
    File operations on large files. This sub-module provides 64-bit variants of
   the functions Unix.lseek[21.1*Note Section 21-1::] (for positioning a
   file descriptor), Unix.truncate[21.1*Note Section 21-1::] and
   Unix.ftruncate[21.1*Note Section 21-1::] (for changing the size of a
   file), and Unix.stat[21.1*Note Section 21-1::],
   Unix.lstat[21.1*Note Section 21-1::] and
   Unix.fstat[21.1*Note Section 21-1::] (for obtaining information on
   files). These alternate functions represent positions and sizes by 64-bit
   integers (type int64) instead of regular integers (type int), thus allowing
   operating on files whose sizes are greater than max_int.
  

Operations on file names
========================
  

<<
  val unlink : string -> unit
>>
    
    Removes the named file
  

<<
  val rename : string -> string -> unit
>>
    
    rename old new changes the name of a file from old to new.
  

<<
  val link : string -> string -> unit
>>
    
    link source dest creates a hard link named dest to the file named source.
  

File permissions and ownership
==============================
  

<<
  type access_permission =
    | R_OK
>>
   
    Read permission 
   
<<
    | W_OK
>>
   
    Write permission 
   
<<
    | X_OK
>>
   
    Execution permission 
   
<<
    | F_OK
>>
   
    File exists 
    
    Flags for the Unix.access[21.1*Note Section 21-1::] call.
  

<<
  val chmod : string -> file_perm -> unit
>>
    
    Change the permissions of the named file.
  

<<
  val fchmod : file_descr -> file_perm -> unit
>>
    
    Change the permissions of an opened file.
  

<<
  val chown : string -> int -> int -> unit
>>
    
    Change the owner uid and owner gid of the named file.
  

<<
  val fchown : file_descr -> int -> int -> unit
>>
    
    Change the owner uid and owner gid of an opened file.
  

<<
  val umask : int -> int
>>
    
    Set the process's file mode creation mask, and return the previous mask.
  

<<
  val access : string -> access_permission list -> unit
>>
    
    Check that the process has the given permissions over the named file. Raise
   Unix_error otherwise.
  

Operations on file descriptors
==============================
  

<<
  val dup : file_descr -> file_descr
>>
    
    Return a new file descriptor referencing the same file as the given
   descriptor.
  

<<
  val dup2 : file_descr -> file_descr -> unit
>>
    
    dup2 fd1 fd2 duplicates fd1 to fd2, closing fd2 if already opened.
  

<<
  val set_nonblock : file_descr -> unit
>>
    
    Set the "non-blocking" flag on the given descriptor. When the non-blocking
   flag is set, reading on a descriptor on which there is temporarily no data
   available raises the EAGAIN or EWOULDBLOCK error instead of blocking;
   writing on a descriptor on which there is temporarily no room for writing
   also raises EAGAIN or EWOULDBLOCK.
  

<<
  val clear_nonblock : file_descr -> unit
>>
    
    Clear the "non-blocking" flag on the given descriptor. See
   Unix.set_nonblock[21.1*Note Section 21-1::].
  

<<
  val set_close_on_exec : file_descr -> unit
>>
    
    Set the "close-on-exec" flag on the given descriptor. A descriptor with the
   close-on-exec flag is automatically closed when the current process starts
   another program with one of the exec functions.
  

<<
  val clear_close_on_exec : file_descr -> unit
>>
    
    Clear the "close-on-exec" flag on the given descriptor. See
   Unix.set_close_on_exec[21.1].
  

Directories
===========
  

<<
  val mkdir : string -> file_perm -> unit
>>
    
    Create a directory with the given permissions.
  

<<
  val rmdir : string -> unit
>>
    
    Remove an empty directory.
  

<<
  val chdir : string -> unit
>>
    
    Change the process working directory.
  

<<
  val getcwd : unit -> string
>>
    
    Return the name of the current working directory.
  

<<
  val chroot : string -> unit
>>
    
    Change the process root directory.
  

<<
  type dir_handle 
>>
    
    The type of descriptors over opened directories.
  

<<
  val opendir : string -> dir_handle
>>
    
    Open a descriptor on a directory
  

<<
  val readdir : dir_handle -> string
>>
    
    Return the next entry in a directory.
   Raises End_of_file when the end of the directory has been reached.
  

<<
  val rewinddir : dir_handle -> unit
>>
    
    Reposition the descriptor to the beginning of the directory
  

<<
  val closedir : dir_handle -> unit
>>
    
    Close a directory descriptor.
  

Pipes and redirections
======================
  

<<
  val pipe : unit -> file_descr * file_descr
>>
    
    Create a pipe. The first component of the result is opened for reading,
   that's the exit to the pipe. The second component is opened for writing,
   that's the entrance to the pipe.
  

<<
  val mkfifo : string -> file_perm -> unit
>>
    
    Create a named pipe with the given permissions.
  

High-level process and redirection management
=============================================
  

<<
  val create_process :
    string ->
    string array -> file_descr -> file_descr -> file_descr -> int
>>
    
    create_process prog args new_stdin new_stdout new_stderr forks a new
   process that executes the program in file prog, with arguments args. The pid
   of the new process is returned immediately; the new process executes
   concurrently with the current process. The standard input and outputs of the
   new process are connected to the descriptors new_stdin, new_stdout and
   new_stderr. Passing e.g. stdout for new_stdout prevents the redirection and
   causes the new process to have the same standard output as the current
   process. The executable file prog is searched in the path. The new process
   has the same environment as the current process.
  

<<
  val create_process_env :
    string ->
    string array ->
    string array -> file_descr -> file_descr -> file_descr -> int
>>
    
    create_process_env prog args env new_stdin new_stdout new_stderr works as
   Unix.create_process[21.1*Note Section 21-1::], except
   that the extra argument env specifies the environment passed to the program.
  

<<
  val open_process_in : string -> Pervasives.in_channel
>>
    
    High-level pipe and process management. This function runs the given
   command in parallel with the program. The standard output of the command is
   redirected to a pipe, which can be read via the returned input channel. The
   command is interpreted by the shell /bin/sh (cf. system).
  

<<
  val open_process_out : string -> Pervasives.out_channel
>>
    
    Same as
   Unix.open_process_in[21.1], but redirect the standard input of the command to a pipe. Data written
   to the returned output channel is sent to the standard input of the command.
   Warning: writes on output channels are buffered, hence be careful to call
   Pervasives.flush[19.2*Note Section 19-2::] at the right times to
   ensure correct synchronization.
  

<<
  val open_process : string -> Pervasives.in_channel * Pervasives.out_channel
>>
    
    Same as
   Unix.open_process_out[21.1], but redirects both the standard input and standard output of the
   command to pipes connected to the two returned channels. The input channel
   is connected to the output of the command, and the output channel to the
   input of the command.
  

<<
  val open_process_full :
    string ->
    string array ->
    Pervasives.in_channel * Pervasives.out_channel * Pervasives.in_channel
>>
    
    Similar to Unix.open_process[21.1*Note Section 21-1::],
   but the second argument specifies the environment passed to the command. The
   result is a triple of channels connected respectively to the standard
   output, standard input, and standard error of the command.
  

<<
  val close_process_in : Pervasives.in_channel -> process_status
>>
    
    Close channels opened by
   Unix.open_process_in[21.1], wait for the associated command to terminate, and return its
   termination status.
  

<<
  val close_process_out : Pervasives.out_channel -> process_status
>>
    
    Close channels opened by
   Unix.open_process_out[21.1], wait for the associated command to terminate, and return its
   termination status.
  

<<
  val close_process :
    Pervasives.in_channel * Pervasives.out_channel -> process_status
>>
    
    Close channels opened by
   Unix.open_process[21.1*Note Section 21-1::], wait for
   the associated command to terminate, and return its termination status.
  

<<
  val close_process_full :
    Pervasives.in_channel * Pervasives.out_channel * Pervasives.in_channel ->
    process_status
>>
    
    Close channels opened by
   Unix.open_process_full[21.1], wait for the associated command to terminate, and return its
   termination status.
  

Symbolic links
==============
  

<<
  val symlink : string -> string -> unit
>>
    
    symlink source dest creates the file dest as a symbolic link to the file
   source.
  

<<
  val readlink : string -> string
>>
    
    Read the contents of a link.
  

Polling
=======
  

<<
  val select :
    file_descr list ->
    file_descr list ->
    file_descr list ->
    float -> file_descr list * file_descr list * file_descr list
>>
    
    Wait until some input/output operations become possible on some channels.
   The three list arguments are, respectively, a set of descriptors to check
   for reading (first argument), for writing (second argument), or for
   exceptional conditions (third argument). The fourth argument is the maximal
   timeout, in seconds; a negative fourth argument means no timeout (unbounded
   wait). The result is composed of three sets of descriptors: those ready for
   reading (first component), ready for writing (second component), and over
   which an exceptional condition is pending (third component).
  

Locking
=======
  

<<
  type lock_command =
    | F_ULOCK
>>
   
    Unlock a region 
   
<<
    | F_LOCK
>>
   
    Lock a region for writing, and block if already locked 
   
<<
    | F_TLOCK
>>
   
    Lock a region for writing, or fail if already locked 
   
<<
    | F_TEST
>>
   
    Test a region for other process locks 
   
<<
    | F_RLOCK
>>
   
    Lock a region for reading, and block if already locked 
   
<<
    | F_TRLOCK
>>
   
    Lock a region for reading, or fail if already locked 
    
    Commands for Unix.lockf[21.1*Note Section 21-1::].
  

<<
  val lockf : file_descr -> lock_command -> int -> unit
>>
    
    lockf fd cmd size puts a lock on a region of the file opened as fd. The
   region starts at the current read/write position for fd (as set by
   Unix.lseek[21.1*Note Section 21-1::]), and extends size bytes forward if
   size is positive, size bytes backwards if size is negative, or to the end of
   the file if size is zero. A write lock prevents any other process from
   acquiring a read or write lock on the region. A read lock prevents any other
   process from acquiring a write lock on the region, but lets other processes
   acquire read locks on it.
   The F_LOCK and F_TLOCK commands attempts to put a write lock on the
   specified region. The F_RLOCK and F_TRLOCK commands attempts to put a read
   lock on the specified region. If one or several locks put by another process
   prevent the current process from acquiring the lock, F_LOCK and F_RLOCK
   block until these locks are removed, while F_TLOCK and F_TRLOCK fail
   immediately with an exception. The F_ULOCK removes whatever locks the
   current process has on the specified region. Finally, the F_TEST command
   tests whether a write lock can be acquired on the specified region, without
   actually putting a lock. It returns immediately if successful, or fails
   otherwise.
  

Signals
=======
  
  Note: installation of signal handlers is performed via the functions
Sys.signal[20.34*Note Section 20-34::] and
Sys.set_signal[20.34*Note Section 20-34::].

<<
  val kill : int -> int -> unit
>>
    
    kill pid sig sends signal number sig to the process with id pid.
  

<<
  type sigprocmask_command =
    | SIG_SETMASK
    | SIG_BLOCK
    | SIG_UNBLOCK
>>
   

<<
  val sigprocmask : sigprocmask_command -> int list -> int list
>>
    
    sigprocmask cmd sigs changes the set of blocked signals. If cmd is
   SIG_SETMASK, blocked signals are set to those in the list sigs. If cmd is
   SIG_BLOCK, the signals in sigs are added to the set of blocked signals. If
   cmd is SIG_UNBLOCK, the signals in sigs are removed from the set of blocked
   signals. sigprocmask returns the set of previously blocked signals.
  

<<
  val sigpending : unit -> int list
>>
    
    Return the set of blocked signals that are currently pending.
  

<<
  val sigsuspend : int list -> unit
>>
    
    sigsuspend sigs atomically sets the blocked signals to sigs and waits for a
   non-ignored, non-blocked signal to be delivered. On return, the blocked
   signals are reset to their initial value.
  

<<
  val pause : unit -> unit
>>
    
    Wait until a non-ignored, non-blocked signal is delivered.
  

Time functions
==============
  

<<
  type process_times = {
    tms_utime : float ;
>>
   
    User time for the process 
   
<<
    tms_stime : float ;
>>
   
    System time for the process 
   
<<
    tms_cutime : float ;
>>
   
    User time for the children processes 
   
<<
    tms_cstime : float ;
>>
   
    System time for the children processes 
   
<<
  }
>>
    
    The execution times (CPU times) of a process.
  

<<
  type tm = {
    tm_sec : int ;
>>
   
    Seconds 0..60 
   
<<
    tm_min : int ;
>>
   
    Minutes 0..59 
   
<<
    tm_hour : int ;
>>
   
    Hours 0..23 
   
<<
    tm_mday : int ;
>>
   
    Day of month 1..31 
   
<<
    tm_mon : int ;
>>
   
    Month of year 0..11 
   
<<
    tm_year : int ;
>>
   
    Year - 1900 
   
<<
    tm_wday : int ;
>>
   
    Day of week (Sunday is 0) 
   
<<
    tm_yday : int ;
>>
   
    Day of year 0..365 
   
<<
    tm_isdst : bool ;
>>
   
    Daylight time savings in effect 
   
<<
  }
>>
    
    The type representing wallclock time and calendar date.
  

<<
  val time : unit -> float
>>
    
    Return the current time since 00:00:00 GMT, Jan. 1, 1970, in seconds.
  

<<
  val gettimeofday : unit -> float
>>
    
    Same as Unix.time[21.1*Note Section 21-1::], but with resolution better
   than 1 second.
  

<<
  val gmtime : float -> tm
>>
    
    Convert a time in seconds, as returned by
   Unix.time[21.1*Note Section 21-1::], into a date and a time. Assumes UTC
   (Coordinated Universal Time), also known as GMT.
  

<<
  val localtime : float -> tm
>>
    
    Convert a time in seconds, as returned by
   Unix.time[21.1*Note Section 21-1::], into a date and a time. Assumes the
   local time zone.
  

<<
  val mktime : tm -> float * tm
>>
    
    Convert a date and time, specified by the tm argument, into a time in
   seconds, as returned by Unix.time[21.1*Note Section 21-1::]. The tm_isdst,
   tm_wday and tm_yday fields of tm are ignored. Also return a normalized copy
   of the given tm record, with the tm_wday, tm_yday, and tm_isdst fields
   recomputed from the other fields, and the other fields normalized (so that,
   e.g., 40 October is changed into 9 November). The tm argument is interpreted
   in the local time zone.
  

<<
  val alarm : int -> int
>>
    
    Schedule a SIGALRM signal after the given number of seconds.
  

<<
  val sleep : int -> unit
>>
    
    Stop execution for the given number of seconds.
  

<<
  val times : unit -> process_times
>>
    
    Return the execution times of the process.
  

<<
  val utimes : string -> float -> float -> unit
>>
    
    Set the last access time (second arg) and last modification time (third
   arg) for a file. Times are expressed in seconds from 00:00:00 GMT, Jan. 1,
   1970. A time of 0.0 is interpreted as the current time.
  

<<
  type interval_timer =
    | ITIMER_REAL
>>
   
    decrements in real time, and sends the signal SIGALRM when expired. 
   
<<
    | ITIMER_VIRTUAL
>>
   
    decrements in process virtual time, and sends SIGVTALRM when expired. 
   
<<
    | ITIMER_PROF
>>
   
    (for profiling) decrements both when the process is running and when the
   system is running on behalf of the process; it sends SIGPROF when expired. 
    
    The three kinds of interval timers.
  

<<
  type interval_timer_status = {
    it_interval : float ;
>>
   
    Period 
   
<<
    it_value : float ;
>>
   
    Current value of the timer 
   
<<
  }
>>
    
    The type describing the status of an interval timer
  

<<
  val getitimer : interval_timer -> interval_timer_status
>>
    
    Return the current status of the given interval timer.
  

<<
  val setitimer :
    interval_timer ->
    interval_timer_status -> interval_timer_status
>>
    
    setitimer t s sets the interval timer t and returns its previous status.
   The s argument is interpreted as follows: s.it_value, if nonzero, is the
   time to the next timer expiration; s.it_interval, if nonzero, specifies a
   value to be used in reloading it_value when the timer expires. Setting
   s.it_value to zero disable the timer. Setting s.it_interval to zero causes
   the timer to be disabled after its next expiration.
  

User id, group id
=================
  

<<
  val getuid : unit -> int
>>
    
    Return the user id of the user executing the process.
  

<<
  val geteuid : unit -> int
>>
    
    Return the effective user id under which the process runs.
  

<<
  val setuid : int -> unit
>>
    
    Set the real user id and effective user id for the process.
  

<<
  val getgid : unit -> int
>>
    
    Return the group id of the user executing the process.
  

<<
  val getegid : unit -> int
>>
    
    Return the effective group id under which the process runs.
  

<<
  val setgid : int -> unit
>>
    
    Set the real group id and effective group id for the process.
  

<<
  val getgroups : unit -> int array
>>
    
    Return the list of groups to which the user executing the process belongs.
  

<<
  val setgroups : int array -> unit
>>
    
    setgroups groups sets the supplementary group IDs for the calling process.
   Appropriate privileges are required.
  

<<
  val initgroups : string -> int -> unit
>>
    
    initgroups user group initializes the group access list by reading the
   group database /etc/group and using all groups of which user is a member.
   The additional group group is also added to the list.
  

<<
  type passwd_entry = {
    pw_name : string ;
    pw_passwd : string ;
    pw_uid : int ;
    pw_gid : int ;
    pw_gecos : string ;
    pw_dir : string ;
    pw_shell : string ;
  }
>>
    
    Structure of entries in the passwd database.
  

<<
  type group_entry = {
    gr_name : string ;
    gr_passwd : string ;
    gr_gid : int ;
    gr_mem : string array ;
  }
>>
    
    Structure of entries in the groups database.
  

<<
  val getlogin : unit -> string
>>
    
    Return the login name of the user executing the process.
  

<<
  val getpwnam : string -> passwd_entry
>>
    
    Find an entry in passwd with the given name, or raise Not_found.
  

<<
  val getgrnam : string -> group_entry
>>
    
    Find an entry in group with the given name, or raise Not_found.
  

<<
  val getpwuid : int -> passwd_entry
>>
    
    Find an entry in passwd with the given user id, or raise Not_found.
  

<<
  val getgrgid : int -> group_entry
>>
    
    Find an entry in group with the given group id, or raise Not_found.
  

Internet addresses
==================
  

<<
  type inet_addr 
>>
    
    The abstract type of Internet addresses.
  

<<
  val inet_addr_of_string : string -> inet_addr
>>
    
    Conversion from the printable representation of an Internet address to its
   internal representation. The argument string consists of 4 numbers separated
   by periods (XXX.YYY.ZZZ.TTT) for IPv4 addresses, and up to 8 numbers
   separated by colons for IPv6 addresses. Raise Failure when given a string
   that does not match these formats.
  

<<
  val string_of_inet_addr : inet_addr -> string
>>
    
    Return the printable representation of the given Internet address. See
   Unix.inet_addr_of_string[21.1] for a description of the printable representation.
  

<<
  val inet_addr_any : inet_addr
>>
    
    A special IPv4 address, for use only with bind, representing all the
   Internet addresses that the host machine possesses.
  

<<
  val inet_addr_loopback : inet_addr
>>
    
    A special IPv4 address representing the host machine (127.0.0.1).
  

<<
  val inet6_addr_any : inet_addr
>>
    
    A special IPv6 address, for use only with bind, representing all the
   Internet addresses that the host machine possesses.
  

<<
  val inet6_addr_loopback : inet_addr
>>
    
    A special IPv6 address representing the host machine (::1).
  

Sockets
=======
  

<<
  type socket_domain =
    | PF_UNIX
>>
   
    Unix domain 
   
<<
    | PF_INET
>>
   
    Internet domain (IPv4) 
   
<<
    | PF_INET6
>>
   
    Internet domain (IPv6) 
    
    The type of socket domains. Not all platforms support IPv6 sockets (type
   PF_INET6).
  

<<
  type socket_type =
    | SOCK_STREAM
>>
   
    Stream socket 
   
<<
    | SOCK_DGRAM
>>
   
    Datagram socket 
   
<<
    | SOCK_RAW
>>
   
    Raw socket 
   
<<
    | SOCK_SEQPACKET
>>
   
    Sequenced packets socket 
    
    The type of socket kinds, specifying the semantics of communications.
  

<<
  type sockaddr =
    | ADDR_UNIX of string
    | ADDR_INET of inet_addr * int
>>
   
    The type of socket addresses. ADDR_UNIX name is a socket address in the
   Unix domain; name is a file name in the file system. ADDR_INET(addr,port) is
   a socket address in the Internet domain; addr is the Internet address of the
   machine, and port is the port number. 
   

<<
  val socket : socket_domain -> socket_type -> int -> file_descr
>>
    
    Create a new socket in the given domain, and with the given kind. The third
   argument is the protocol type; 0 selects the default protocol for that kind
   of sockets.
  

<<
  val domain_of_sockaddr : sockaddr -> socket_domain
>>
    
    Return the socket domain adequate for the given socket address.
  

<<
  val socketpair :
    socket_domain ->
    socket_type -> int -> file_descr * file_descr
>>
    
    Create a pair of unnamed sockets, connected together.
  

<<
  val accept : file_descr -> file_descr * sockaddr
>>
    
    Accept connections on the given socket. The returned descriptor is a socket
   connected to the client; the returned address is the address of the
   connecting client.
  

<<
  val bind : file_descr -> sockaddr -> unit
>>
    
    Bind a socket to an address.
  

<<
  val connect : file_descr -> sockaddr -> unit
>>
    
    Connect a socket to an address.
  

<<
  val listen : file_descr -> int -> unit
>>
    
    Set up a socket for receiving connection requests. The integer argument is
   the maximal number of pending requests.
  

<<
  type shutdown_command =
    | SHUTDOWN_RECEIVE
>>
   
    Close for receiving 
   
<<
    | SHUTDOWN_SEND
>>
   
    Close for sending 
   
<<
    | SHUTDOWN_ALL
>>
   
    Close both 
    
    The type of commands for shutdown.
  

<<
  val shutdown : file_descr -> shutdown_command -> unit
>>
    
    Shutdown a socket connection. SHUTDOWN_SEND as second argument causes reads
   on the other end of the connection to return an end-of-file condition.
   SHUTDOWN_RECEIVE causes writes on the other end of the connection to return
   a closed pipe condition (SIGPIPE signal).
  

<<
  val getsockname : file_descr -> sockaddr
>>
    
    Return the address of the given socket.
  

<<
  val getpeername : file_descr -> sockaddr
>>
    
    Return the address of the host connected to the given socket.
  

<<
  type msg_flag =
    | MSG_OOB
    | MSG_DONTROUTE
    | MSG_PEEK
>>
   
    The flags for Unix.recv[21.1*Note Section 21-1::],
   Unix.recvfrom[21.1*Note Section 21-1::],
   Unix.send[21.1*Note Section 21-1::] and
   Unix.sendto[21.1*Note Section 21-1::]. 
   

<<
  val recv : file_descr -> string -> int -> int -> msg_flag list -> int
>>
    
    Receive data from a connected socket.
  

<<
  val recvfrom :
    file_descr ->
    string -> int -> int -> msg_flag list -> int * sockaddr
>>
    
    Receive data from an unconnected socket.
  

<<
  val send : file_descr -> string -> int -> int -> msg_flag list -> int
>>
    
    Send data over a connected socket.
  

<<
  val sendto :
    file_descr ->
    string -> int -> int -> msg_flag list -> sockaddr -> int
>>
    
    Send data over an unconnected socket.
  

Socket options
==============
  

<<
  type socket_bool_option =
    | SO_DEBUG
>>
   
    Record debugging information 
   
<<
    | SO_BROADCAST
>>
   
    Permit sending of broadcast messages 
   
<<
    | SO_REUSEADDR
>>
   
    Allow reuse of local addresses for bind 
   
<<
    | SO_KEEPALIVE
>>
   
    Keep connection active 
   
<<
    | SO_DONTROUTE
>>
   
    Bypass the standard routing algorithms 
   
<<
    | SO_OOBINLINE
>>
   
    Leave out-of-band data in line 
   
<<
    | SO_ACCEPTCONN
>>
   
    Report whether socket listening is enabled 
   
<<
    | TCP_NODELAY
>>
   
    Control the Nagle algorithm for TCP sockets 
   
<<
    | IPV6_ONLY
>>
   
    Forbid binding an IPv6 socket to an IPv4 address 
    
    The socket options that can be consulted with
   Unix.getsockopt[21.1*Note Section 21-1::] and modified with
   Unix.setsockopt[21.1*Note Section 21-1::]. These options have a
   boolean (true/false) value.
  

<<
  type socket_int_option =
    | SO_SNDBUF
>>
   
    Size of send buffer 
   
<<
    | SO_RCVBUF
>>
   
    Size of received buffer 
   
<<
    | SO_ERROR
>>
   
    Deprecated. Use
   Unix.getsockopt_error[21.1*Note Section 21-1::]
   instead. 
   
<<
    | SO_TYPE
>>
   
    Report the socket type 
   
<<
    | SO_RCVLOWAT
>>
   
    Minimum number of bytes to process for input operations 
   
<<
    | SO_SNDLOWAT
>>
   
    Minimum number of bytes to process for output operations 
    
    The socket options that can be consulted with
   Unix.getsockopt_int[21.1*Note Section 21-1::] and
   modified with
   Unix.setsockopt_int[21.1*Note Section 21-1::]. These
   options have an integer value.
  

<<
  type socket_optint_option =
    | SO_LINGER
>>
   
    Whether to linger on closed connections that have data present, and for how
   long (in seconds) 
    
    The socket options that can be consulted with
   Unix.getsockopt_optint[21.1*Note Section 21-1::]
   and modified with
   Unix.setsockopt_optint[21.1*Note Section 21-1::].
   These options have a value of type int option, with None meaning "disabled".
  

<<
  type socket_float_option =
    | SO_RCVTIMEO
>>
   
    Timeout for input operations 
   
<<
    | SO_SNDTIMEO
>>
   
    Timeout for output operations 
    
    The socket options that can be consulted with
   Unix.getsockopt_float[21.1*Note Section 21-1::] and
   modified with
   Unix.setsockopt_float[21.1*Note Section 21-1::].
   These options have a floating-point value representing a time in seconds.
   The value 0 means infinite timeout.
  

<<
  val getsockopt : file_descr -> socket_bool_option -> bool
>>
    
    Return the current status of a boolean-valued option in the given socket.
  

<<
  val setsockopt : file_descr -> socket_bool_option -> bool -> unit
>>
    
    Set or clear a boolean-valued option in the given socket.
  

<<
  val getsockopt_int : file_descr -> socket_int_option -> int
>>
    
    Same as Unix.getsockopt[21.1*Note Section 21-1::] for an
   integer-valued socket option.
  

<<
  val setsockopt_int : file_descr -> socket_int_option -> int -> unit
>>
    
    Same as Unix.setsockopt[21.1*Note Section 21-1::] for an
   integer-valued socket option.
  

<<
  val getsockopt_optint : file_descr -> socket_optint_option -> int option
>>
    
    Same as Unix.getsockopt[21.1*Note Section 21-1::] for a socket
   option whose value is an int option.
  

<<
  val setsockopt_optint :
    file_descr -> socket_optint_option -> int option -> unit
>>
    
    Same as Unix.setsockopt[21.1*Note Section 21-1::] for a socket
   option whose value is an int option.
  

<<
  val getsockopt_float : file_descr -> socket_float_option -> float
>>
    
    Same as Unix.getsockopt[21.1*Note Section 21-1::] for a socket
   option whose value is a floating-point number.
  

<<
  val setsockopt_float : file_descr -> socket_float_option -> float -> unit
>>
    
    Same as Unix.setsockopt[21.1*Note Section 21-1::] for a socket
   option whose value is a floating-point number.
  

<<
  val getsockopt_error : file_descr -> error option
>>
    
    Return the error condition associated with the given socket, and clear it.
  

High-level network connection functions
=======================================
  

<<
  val open_connection :
    sockaddr -> Pervasives.in_channel * Pervasives.out_channel
>>
    
    Connect to a server at the given address. Return a pair of buffered
   channels connected to the server. Remember to call
   Pervasives.flush[19.2*Note Section 19-2::] on the output channel at
   the right times to ensure correct synchronization.
  

<<
  val shutdown_connection : Pervasives.in_channel -> unit
>>
    
    "Shut down" a connection established with
   Unix.open_connection[21.1*Note Section 21-1::]; that
   is, transmit an end-of-file condition to the server reading on the other
   side of the connection.
  

<<
  val establish_server :
    (Pervasives.in_channel -> Pervasives.out_channel -> unit) ->
    sockaddr -> unit
>>
    
    Establish a server on the given address. The function given as first
   argument is called for each connection with two buffered channels connected
   to the client. A new process is created for each connection. The function
   Unix.establish_server[21.1*Note Section 21-1::]
   never returns normally.
  

Host and protocol databases
===========================
  

<<
  type host_entry = {
    h_name : string ;
    h_aliases : string array ;
    h_addrtype : socket_domain ;
    h_addr_list : inet_addr array ;
  }
>>
    
    Structure of entries in the hosts database.
  

<<
  type protocol_entry = {
    p_name : string ;
    p_aliases : string array ;
    p_proto : int ;
  }
>>
    
    Structure of entries in the protocols database.
  

<<
  type service_entry = {
    s_name : string ;
    s_aliases : string array ;
    s_port : int ;
    s_proto : string ;
  }
>>
    
    Structure of entries in the services database.
  

<<
  val gethostname : unit -> string
>>
    
    Return the name of the local host.
  

<<
  val gethostbyname : string -> host_entry
>>
    
    Find an entry in hosts with the given name, or raise Not_found.
  

<<
  val gethostbyaddr : inet_addr -> host_entry
>>
    
    Find an entry in hosts with the given address, or raise Not_found.
  

<<
  val getprotobyname : string -> protocol_entry
>>
    
    Find an entry in protocols with the given name, or raise Not_found.
  

<<
  val getprotobynumber : int -> protocol_entry
>>
    
    Find an entry in protocols with the given protocol number, or raise
   Not_found.
  

<<
  val getservbyname : string -> string -> service_entry
>>
    
    Find an entry in services with the given name, or raise Not_found.
  

<<
  val getservbyport : int -> string -> service_entry
>>
    
    Find an entry in services with the given service number, or raise
   Not_found.
  

<<
  type addr_info = {
    ai_family : socket_domain ;
>>
   
    Socket domain 
   
<<
    ai_socktype : socket_type ;
>>
   
    Socket type 
   
<<
    ai_protocol : int ;
>>
   
    Socket protocol number 
   
<<
    ai_addr : sockaddr ;
>>
   
    Address 
   
<<
    ai_canonname : string ;
>>
   
    Canonical host name 
   
<<
  }
>>
    
    Address information returned by
   Unix.getaddrinfo[21.1*Note Section 21-1::].
  

<<
  type getaddrinfo_option =
    | AI_FAMILY of socket_domain
>>
   
    Impose the given socket domain 
   
<<
    | AI_SOCKTYPE of socket_type
>>
   
    Impose the given socket type 
   
<<
    | AI_PROTOCOL of int
>>
   
    Impose the given protocol 
   
<<
    | AI_NUMERICHOST
>>
   
    Do not call name resolver, expect numeric IP address 
   
<<
    | AI_CANONNAME
>>
   
    Fill the ai_canonname field of the result 
   
<<
    | AI_PASSIVE
>>
   
    Set address to "any" address for use with
   Unix.bind[21.1*Note Section 21-1::] 
    
    Options to Unix.getaddrinfo[21.1*Note Section 21-1::].
  

<<
  val getaddrinfo :
    string -> string -> getaddrinfo_option list -> addr_info list
>>
    
    getaddrinfo host service opts returns a list of
   Unix.addr_info[21.1*Note Section 21-1::] records
   describing socket parameters and addresses suitable for communicating with
   the given host and service. The empty list is returned if the host or
   service names are unknown, or the constraints expressed in opts cannot be
   satisfied.
   host is either a host name or the string representation of an IP address.
   host can be given as the empty string; in this case, the "any" address or
   the "loopback" address are used, depending whether opts contains AI_PASSIVE.
   service is either a service name or the string representation of a port
   number. service can be given as the empty string; in this case, the port
   field of the returned addresses is set to 0. opts is a possibly empty list
   of options that allows the caller to force a particular socket domain (e.g.
   IPv6 only or IPv4 only) or a particular socket type (e.g. TCP only or UDP
   only).
  

<<
  type name_info = {
    ni_hostname : string ;
>>
   
    Name or IP address of host 
   
<<
    ni_service : string ;
  }
>>
    
    Name of service or port number
  
  Host and service information returned by
Unix.getnameinfo[21.1*Note Section 21-1::].

<<
  type getnameinfo_option =
    | NI_NOFQDN
>>
   
    Do not qualify local host names 
   
<<
    | NI_NUMERICHOST
>>
   
    Always return host as IP address 
   
<<
    | NI_NAMEREQD
>>
   
    Fail if host name cannot be determined 
   
<<
    | NI_NUMERICSERV
>>
   
    Always return service as port number 
   
<<
    | NI_DGRAM
>>
   
    Consider the service as UDP-based instead of the default TCP 
    
    Options to Unix.getnameinfo[21.1*Note Section 21-1::].
  

<<
  val getnameinfo : sockaddr -> getnameinfo_option list -> name_info
>>
    
    getnameinfo addr opts returns the host name and service name corresponding
   to the socket address addr. opts is a possibly empty list of options that
   governs how these names are obtained. Raise Not_found if an error occurs.
  

Terminal interface
==================
  
  The following functions implement the POSIX standard terminal interface. They
provide control over asynchronous communication ports and pseudo-terminals.
Refer to the termios man page for a complete description.

<<
  type terminal_io = {
    mutable c_ignbrk : bool ;
>>
   
    Ignore the break condition. 
   
<<
    mutable c_brkint : bool ;
>>
   
    Signal interrupt on break condition. 
   
<<
    mutable c_ignpar : bool ;
>>
   
    Ignore characters with parity errors. 
   
<<
    mutable c_parmrk : bool ;
>>
   
    Mark parity errors. 
   
<<
    mutable c_inpck : bool ;
>>
   
    Enable parity check on input. 
   
<<
    mutable c_istrip : bool ;
>>
   
    Strip 8th bit on input characters. 
   
<<
    mutable c_inlcr : bool ;
>>
   
    Map NL to CR on input. 
   
<<
    mutable c_igncr : bool ;
>>
   
    Ignore CR on input. 
   
<<
    mutable c_icrnl : bool ;
>>
   
    Map CR to NL on input. 
   
<<
    mutable c_ixon : bool ;
>>
   
    Recognize XON/XOFF characters on input. 
   
<<
    mutable c_ixoff : bool ;
>>
   
    Emit XON/XOFF chars to control input flow. 
   
<<
    mutable c_opost : bool ;
>>
   
    Enable output processing. 
   
<<
    mutable c_obaud : int ;
>>
   
    Output baud rate (0 means close connection). 
   
<<
    mutable c_ibaud : int ;
>>
   
    Input baud rate. 
   
<<
    mutable c_csize : int ;
>>
   
    Number of bits per character (5-8). 
   
<<
    mutable c_cstopb : int ;
>>
   
    Number of stop bits (1-2). 
   
<<
    mutable c_cread : bool ;
>>
   
    Reception is enabled. 
   
<<
    mutable c_parenb : bool ;
>>
   
    Enable parity generation and detection. 
   
<<
    mutable c_parodd : bool ;
>>
   
    Specify odd parity instead of even. 
   
<<
    mutable c_hupcl : bool ;
>>
   
    Hang up on last close. 
   
<<
    mutable c_clocal : bool ;
>>
   
    Ignore modem status lines. 
   
<<
    mutable c_isig : bool ;
>>
   
    Generate signal on INTR, QUIT, SUSP. 
   
<<
    mutable c_icanon : bool ;
>>
   
    Enable canonical processing (line buffering and editing) 
   
<<
    mutable c_noflsh : bool ;
>>
   
    Disable flush after INTR, QUIT, SUSP. 
   
<<
    mutable c_echo : bool ;
>>
   
    Echo input characters. 
   
<<
    mutable c_echoe : bool ;
>>
   
    Echo ERASE (to erase previous character). 
   
<<
    mutable c_echok : bool ;
>>
   
    Echo KILL (to erase the current line). 
   
<<
    mutable c_echonl : bool ;
>>
   
    Echo NL even if c_echo is not set. 
   
<<
    mutable c_vintr : char ;
>>
   
    Interrupt character (usually ctrl-C). 
   
<<
    mutable c_vquit : char ;
>>
   
    Quit character (usually ctrl-\). 
   
<<
    mutable c_verase : char ;
>>
   
    Erase character (usually DEL or ctrl-H). 
   
<<
    mutable c_vkill : char ;
>>
   
    Kill line character (usually ctrl-U). 
   
<<
    mutable c_veof : char ;
>>
   
    End-of-file character (usually ctrl-D). 
   
<<
    mutable c_veol : char ;
>>
   
    Alternate end-of-line char. (usually none). 
   
<<
    mutable c_vmin : int ;
>>
   
    Minimum number of characters to read before the read request is satisfied. 
   
<<
    mutable c_vtime : int ;
>>
   
    Maximum read wait (in 0.1s units). 
   
<<
    mutable c_vstart : char ;
>>
   
    Start character (usually ctrl-Q). 
   
<<
    mutable c_vstop : char ;
>>
   
    Stop character (usually ctrl-S). 
   
<<
  }
>>
   

<<
  val tcgetattr : file_descr -> terminal_io
>>
    
    Return the status of the terminal referred to by the given file descriptor.
  

<<
  type setattr_when =
    | TCSANOW
    | TCSADRAIN
    | TCSAFLUSH
>>
   

<<
  val tcsetattr : file_descr -> setattr_when -> terminal_io -> unit
>>
    
    Set the status of the terminal referred to by the given file descriptor.
   The second argument indicates when the status change takes place:
   immediately (TCSANOW), when all pending output has been transmitted
   (TCSADRAIN), or after flushing all input that has been received but not read
   (TCSAFLUSH). TCSADRAIN is recommended when changing the output parameters;
   TCSAFLUSH, when changing the input parameters.
  

<<
  val tcsendbreak : file_descr -> int -> unit
>>
    
    Send a break condition on the given file descriptor. The second argument is
   the duration of the break, in 0.1s units; 0 means standard duration (0.25s).
  

<<
  val tcdrain : file_descr -> unit
>>
    
    Waits until all output written on the given file descriptor has been
   transmitted.
  

<<
  type flush_queue =
    | TCIFLUSH
    | TCOFLUSH
    | TCIOFLUSH
>>
   

<<
  val tcflush : file_descr -> flush_queue -> unit
>>
    
    Discard data written on the given file descriptor but not yet transmitted,
   or data received but not yet read, depending on the second argument:
   TCIFLUSH flushes data received but not read, TCOFLUSH flushes data written
   but not transmitted, and TCIOFLUSH flushes both.
  

<<
  type flow_action =
    | TCOOFF
    | TCOON
    | TCIOFF
    | TCION
>>
   

<<
  val tcflow : file_descr -> flow_action -> unit
>>
    
    Suspend or restart reception or transmission of data on the given file
   descriptor, depending on the second argument: TCOOFF suspends output, TCOON
   restarts output, TCIOFF transmits a STOP character to suspend input, and
   TCION transmits a START character to restart input.
  

<<
  val setsid : unit -> int
>>
    
    Put the calling process in a new session and detach it from its controlling
   terminal.
  
