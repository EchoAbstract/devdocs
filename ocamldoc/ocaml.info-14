This file has been translated from LaTeX by HeVeA.

Node: Section 20-2,	Next: Section 20-3,	Prev: Section 20-1,	Up: Chapter 20
  

20.2   Module Array : Array operations.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  
  

<<
  val length : 'a array -> int
>>
    
    Return the length (number of elements) of the given array.
  

<<
  val get : 'a array -> int -> 'a
>>
    
    Array.get a n returns the element number n of array a. The first element
   has number 0. The last element has number Array.length a - 1. You can also
   write a.(n) instead of Array.get a n.
   Raise Invalid_argument "index out of bounds" if n is outside the range 0 to
   (Array.length a - 1).
  

<<
  val set : 'a array -> int -> 'a -> unit
>>
    
    Array.set a n x modifies array a in place, replacing element number n with
   x. You can also write a.(n) <- x instead of Array.set a n x.
   Raise Invalid_argument "index out of bounds" if n is outside the range 0 to
   Array.length a - 1.
  

<<
  val make : int -> 'a -> 'a array
>>
    
    Array.make n x returns a fresh array of length n, initialized with x. All
   the elements of this new array are initially physically equal to x (in the
   sense of the == predicate). Consequently, if x is mutable, it is shared
   among all elements of the array, and modifying x through one of the array
   entries will modify all other entries at the same time.
   Raise Invalid_argument if n < 0 or n > Sys.max_array_length. If the value of
   x is a floating-point number, then the maximum size is only
   Sys.max_array_length / 2.
  

<<
  val create : int -> 'a -> 'a array
>>
    
    Deprecated. Array.create is an alias for
   Array.make[20.2*Note Section 20-2::]. 
  

<<
  val init : int -> (int -> 'a) -> 'a array
>>
    
    Array.init n f returns a fresh array of length n, with element number i
   initialized to the result of f i. In other terms, Array.init n f tabulates
   the results of f applied to the integers 0 to n-1.
   Raise Invalid_argument if n < 0 or n > Sys.max_array_length. If the return
   type of f is float, then the maximum size is only Sys.max_array_length / 2.
  

<<
  val make_matrix : int -> int -> 'a -> 'a array array
>>
    
    Array.make_matrix dimx dimy e returns a two-dimensional array (an array of
   arrays) with first dimension dimx and second dimension dimy. All the
   elements of this new matrix are initially physically equal to e. The element
   (x,y) of a matrix m is accessed with the notation m.(x).(y).
   Raise Invalid_argument if dimx or dimy is negative or greater than
   Sys.max_array_length. If the value of e is a floating-point number, then the
   maximum size is only Sys.max_array_length / 2.
  

<<
  val create_matrix : int -> int -> 'a -> 'a array array
>>
    
    Deprecated. Array.create_matrix is an alias for
   Array.make_matrix[20.2*Note Section 20-2::]. 
  

<<
  val append : 'a array -> 'a array -> 'a array
>>
    
    Array.append v1 v2 returns a fresh array containing the concatenation of
   the arrays v1 and v2.
  

<<
  val concat : 'a array list -> 'a array
>>
    
    Same as Array.append, but concatenates a list of arrays.
  

<<
  val sub : 'a array -> int -> int -> 'a array
>>
    
    Array.sub a start len returns a fresh array of length len, containing the
   elements number start to start + len - 1 of array a.
   Raise Invalid_argument "Array.sub" if start and len do not designate a valid
   subarray of a; that is, if start < 0, or len < 0, or start + len >
   Array.length a.
  

<<
  val copy : 'a array -> 'a array
>>
    
    Array.copy a returns a copy of a, that is, a fresh array containing the
   same elements as a.
  

<<
  val fill : 'a array -> int -> int -> 'a -> unit
>>
    
    Array.fill a ofs len x modifies the array a in place, storing x in elements
   number ofs to ofs + len - 1.
   Raise Invalid_argument "Array.fill" if ofs and len do not designate a valid
   subarray of a.
  

<<
  val blit : 'a array -> int -> 'a array -> int -> int -> unit
>>
    
    Array.blit v1 o1 v2 o2 len copies len elements from array v1, starting at
   element number o1, to array v2, starting at element number o2. It works
   correctly even if v1 and v2 are the same array, and the source and
   destination chunks overlap.
   Raise Invalid_argument "Array.blit" if o1 and len do not designate a valid
   subarray of v1, or if o2 and len do not designate a valid subarray of v2.
  

<<
  val to_list : 'a array -> 'a list
>>
    
    Array.to_list a returns the list of all the elements of a.
  

<<
  val of_list : 'a list -> 'a array
>>
    
    Array.of_list l returns a fresh array containing the elements of l.
  

<<
  val iter : ('a -> unit) -> 'a array -> unit
>>
    
    Array.iter f a applies function f in turn to all the elements of a. It is
   equivalent to f a.(0); f a.(1); ...; f a.(Array.length a - 1); ().
  

<<
  val map : ('a -> 'b) -> 'a array -> 'b array
>>
    
    Array.map f a applies function f to all the elements of a, and builds an
   array with the results returned by f: [| f a.(0); f a.(1); ...; f
   a.(Array.length a - 1) |].
  

<<
  val iteri : (int -> 'a -> unit) -> 'a array -> unit
>>
    
    Same as Array.iter[20.2*Note Section 20-2::], but the function is
   applied to the index of the element as first argument, and the element
   itself as second argument.
  

<<
  val mapi : (int -> 'a -> 'b) -> 'a array -> 'b array
>>
    
    Same as Array.map[20.2*Note Section 20-2::], but the function is applied
   to the index of the element as first argument, and the element itself as
   second argument.
  

<<
  val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b array -> 'a
>>
    
    Array.fold_left f x a computes f (... (f (f x a.(0)) a.(1)) ...) a.(n-1),
   where n is the length of the array a.
  

<<
  val fold_right : ('a -> 'b -> 'b) -> 'a array -> 'b -> 'b
>>
    
    Array.fold_right f a x computes f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...)),
   where n is the length of the array a.
  

Sorting
=======
  

<<
  val sort : ('a -> 'a -> int) -> 'a array -> unit
>>
    
    Sort an array in increasing order according to a comparison function. The
   comparison function must return 0 if its arguments compare as equal, a
   positive integer if the first is greater, and a negative integer if the
   first is smaller (see below for a complete specification). For example,
   Pervasives.compare[19.2*Note Section 19-2::] is a suitable
   comparison function, provided there are no floating-point NaN values in the
   data. After calling Array.sort, the array is sorted in place in increasing
   order. Array.sort is guaranteed to run in constant heap space and (at most)
   logarithmic stack space.
   The current implementation uses Heap Sort. It runs in constant stack space.
   Specification of the comparison function: Let a be the array and cmp the
   comparison function. The following must be true for all x, y, z in a :
     
      - cmp x y > 0 if and only if cmp y x < 0 
      - if cmp x y >= 0 and cmp y z >= 0 then cmp x z >= 0 
   
   When Array.sort returns, a contains the same elements as before, reordered
   in such a way that for all i and j valid indices of a :
     
      - cmp a.(i) a.(j) >= 0 if and only if i >= j 
   
  

<<
  val stable_sort : ('a -> 'a -> int) -> 'a array -> unit
>>
    
    Same as Array.sort[20.2*Note Section 20-2::], but the sorting algorithm
   is stable (i.e. elements that compare equal are kept in their original
   order) and not guaranteed to run in constant heap space.
   The current implementation uses Merge Sort. It uses n/2 words of heap space,
   where n is the length of the array. It is usually faster than the current
   implementation of Array.sort[20.2*Note Section 20-2::].
  

<<
  val fast_sort : ('a -> 'a -> int) -> 'a array -> unit
>>
    
    Same as Array.sort[20.2*Note Section 20-2::] or
   Array.stable_sort[20.2*Note Section 20-2::], whichever
   is faster on typical input.
  
   

Node: Section 20-3,	Next: Section 20-4,	Prev: Section 20-2,	Up: Chapter 20
  

20.3   Module Buffer : Extensible string buffers.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  This module implements string buffers that automatically expand as necessary.
It provides accumulative concatenation of strings in quasi-linear time (instead
of quadratic time when strings are concatenated pairwise).
  
  

<<
  type t 
>>
    
    The abstract type of buffers.
  

<<
  val create : int -> t
>>
    
    create n returns a fresh buffer, initially empty. The n parameter is the
   initial size of the internal string that holds the buffer contents. That
   string is automatically reallocated when more than n characters are stored
   in the buffer, but shrinks back to n characters when reset is called. For
   best performance, n should be of the same order of magnitude as the number
   of characters that are expected to be stored in the buffer (for instance, 80
   for a buffer that holds one output line). Nothing bad will happen if the
   buffer grows beyond that limit, however. In doubt, take n = 16 for instance.
   If n is not between 1 and
   Sys.max_string_length[20.34], it will be clipped to that interval.
  

<<
  val contents : t -> string
>>
    
    Return a copy of the current contents of the buffer. The buffer itself is
   unchanged.
  

<<
  val sub : t -> int -> int -> string
>>
    
    Buffer.sub b off len returns (a copy of) the substring of the current
   contents of the buffer b starting at offset off of length len bytes. May
   raise Invalid_argument if out of bounds request. The buffer itself is
   unaffected.
  

<<
  val blit : t -> int -> string -> int -> int -> unit
>>
    
    Buffer.blit src srcoff dst dstoff len copies len characters from the
   current contents of the buffer src, starting at offset srcoff to string dst,
   starting at character dstoff.
   Raise Invalid_argument if srcoff and len do not designate a valid substring
   of src, or if dstoff and len do not designate a valid substring of dst.
   Since: 3.11.2
  

<<
  val nth : t -> int -> char
>>
    
    get the n-th character of the buffer. Raise Invalid_argument if index out
   of bounds
  

<<
  val length : t -> int
>>
    
    Return the number of characters currently contained in the buffer.
  

<<
  val clear : t -> unit
>>
    
    Empty the buffer.
  

<<
  val reset : t -> unit
>>
    
    Empty the buffer and deallocate the internal string holding the buffer
   contents, replacing it with the initial internal string of length n that was
   allocated by Buffer.create[20.3*Note Section 20-3::] n. For long-lived
   buffers that may have grown a lot, reset allows faster reclamation of the
   space used by the buffer.
  

<<
  val add_char : t -> char -> unit
>>
    
    add_char b c appends the character c at the end of the buffer b.
  

<<
  val add_string : t -> string -> unit
>>
    
    add_string b s appends the string s at the end of the buffer b.
  

<<
  val add_substring : t -> string -> int -> int -> unit
>>
    
    add_substring b s ofs len takes len characters from offset ofs in string s
   and appends them at the end of the buffer b.
  

<<
  val add_substitute : t -> (string -> string) -> string -> unit
>>
    
    add_substitute b f s appends the string pattern s at the end of the buffer
   b with substitution. The substitution process looks for variables into the
   pattern and substitutes each variable name by its value, as obtained by
   applying the mapping f to the variable name. Inside the string pattern, a
   variable name immediately follows a non-escaped $ character and is one of
   the following:
     
      - a non empty sequence of alphanumeric or _ characters, 
      - an arbitrary sequence of characters enclosed by a pair of matching
      parentheses or curly brackets. An escaped $ character is a $ that
      immediately follows a backslash character; it then stands for a plain $.
      Raise Not_found if the closing character of a parenthesized variable
      cannot be found. 
   
  

<<
  val add_buffer : t -> t -> unit
>>
    
    add_buffer b1 b2 appends the current contents of buffer b2 at the end of
   buffer b1. b2 is not modified.
  

<<
  val add_channel : t -> Pervasives.in_channel -> int -> unit
>>
    
    add_channel b ic n reads exactly n character from the input channel ic and
   stores them at the end of buffer b. Raise End_of_file if the channel
   contains fewer than n characters.
  

<<
  val output_buffer : Pervasives.out_channel -> t -> unit
>>
    
    output_buffer oc b writes the current contents of buffer b on the output
   channel oc.
  
   

Node: Section 20-4,	Next: Section 20-5,	Prev: Section 20-3,	Up: Chapter 20
  

20.4   Module Callback : Registering Caml values with the C runtime.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  This module allows Caml values to be registered with the C runtime under a
symbolic name, so that C code can later call back registered Caml functions, or
raise registered Caml exceptions.
  
  

<<
  val register : string -> 'a -> unit
>>
    
    Callback.register n v registers the value v under the name n. C code can
   later retrieve a handle to v by calling caml_named_value(n).
  

<<
  val register_exception : string -> exn -> unit
>>
    
    Callback.register_exception n exn registers the exception contained in the
   exception value exn under the name n. C code can later retrieve a handle to
   the exception by calling caml_named_value(n). The exception value thus
   obtained is suitable for passign as first argument to raise_constant or
   raise_with_arg.
  
   

Node: Section 20-5,	Next: Section 20-6,	Prev: Section 20-4,	Up: Chapter 20
  

20.5   Module Char : Character operations.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  
  

<<
  val code : char -> int
>>
    
    Return the ASCII code of the argument.
  

<<
  val chr : int -> char
>>
    
    Return the character with the given ASCII code. Raise Invalid_argument
   "Char.chr" if the argument is outside the range 0--255.
  

<<
  val escaped : char -> string
>>
    
    Return a string representing the given character, with special characters
   escaped following the lexical conventions of Objective Caml.
  

<<
  val lowercase : char -> char
>>
    
    Convert the given character to its equivalent lowercase character.
  

<<
  val uppercase : char -> char
>>
    
    Convert the given character to its equivalent uppercase character.
  

<<
  type t = char 
>>
    
    An alias for the type of characters.
  

<<
  val compare : t -> t -> int
>>
    
    The comparison function for characters, with the same specification as
   Pervasives.compare[19.2*Note Section 19-2::]. Along with the type
   t, this function compare allows the module Char to be passed as argument to
   the functors Set.Make[20.28*Note Section 20-28::] and
   Map.Make[20.18*Note Section 20-18::].
  
   

Node: Section 20-6,	Next: Section 20-7,	Prev: Section 20-5,	Up: Chapter 20
  

20.6   Module Complex : Complex numbers.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  This module provides arithmetic operations on complex numbers. Complex
numbers are represented by their real and imaginary parts (cartesian
representation). Each part is represented by a double-precision floating-point
number (type float).
  
  

<<
  type t = {
    re : float ;
    im : float ;
  }
>>
    
    The type of complex numbers. re is the real part and im the imaginary part.
  

<<
  val zero : t
>>
    
    The complex number 0.
  

<<
  val one : t
>>
    
    The complex number 1.
  

<<
  val i : t
>>
    
    The complex number i.
  

<<
  val neg : t -> t
>>
    
    Unary negation.
  

<<
  val conj : t -> t
>>
    
    Conjugate: given the complex x + i.y, returns x - i.y.
  

<<
  val add : t -> t -> t
>>
    
    Addition
  

<<
  val sub : t -> t -> t
>>
    
    Subtraction
  

<<
  val mul : t -> t -> t
>>
    
    Multiplication
  

<<
  val inv : t -> t
>>
    
    Multiplicative inverse (1/z).
  

<<
  val div : t -> t -> t
>>
    
    Division
  

<<
  val sqrt : t -> t
>>
    
    Square root. The result x + i.y is such that x > 0 or x = 0 and y >= 0.
   This function has a discontinuity along the negative real axis.
  

<<
  val norm2 : t -> float
>>
    
    Norm squared: given x + i.y, returns x^2 + y^2.
  

<<
  val norm : t -> float
>>
    
    Norm: given x + i.y, returns sqrt(x^2 + y^2).
  

<<
  val arg : t -> float
>>
    
    Argument. The argument of a complex number is the angle in the complex
   plane between the positive real axis and a line passing through zero and the
   number. This angle ranges from -pi to pi. This function has a discontinuity
   along the negative real axis.
  

<<
  val polar : float -> float -> t
>>
    
    polar norm arg returns the complex having norm norm and argument arg.
  

<<
  val exp : t -> t
>>
    
    Exponentiation. exp z returns e to the z power.
  

<<
  val log : t -> t
>>
    
    Natural logarithm (in base e).
  

<<
  val pow : t -> t -> t
>>
    
    Power function. pow z1 z2 returns z1 to the z2 power.
  
   

Node: Section 20-7,	Next: Section 20-8,	Prev: Section 20-6,	Up: Chapter 20
  

20.7   Module Digest : MD5 message digest.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  This module provides functions to compute 128-bit "digests" of
arbitrary-length strings or files. The digests are of cryptographic quality: it
is very hard, given a digest, to forge a string having that digest. The
algorithm used is MD5.
  
  

<<
  type t = string 
>>
    
    The type of digests: 16-character strings.
  

<<
  val string : string -> t
>>
    
    Return the digest of the given string.
  

<<
  val substring : string -> int -> int -> t
>>
    
    Digest.substring s ofs len returns the digest of the substring of s
   starting at character number ofs and containing len characters.
  

<<
  val channel : Pervasives.in_channel -> int -> t
>>
    
    If len is nonnegative, Digest.channel ic len reads len characters from
   channel ic and returns their digest, or raises End_of_file if end-of-file is
   reached before len characters are read. If len is negative, Digest.channel
   ic len reads all characters from ic until end-of-file is reached and return
   their digest.
  

<<
  val file : string -> t
>>
    
    Return the digest of the file whose name is given.
  

<<
  val output : Pervasives.out_channel -> t -> unit
>>
    
    Write a digest on the given output channel.
  

<<
  val input : Pervasives.in_channel -> t
>>
    
    Read a digest from the given input channel.
  

<<
  val to_hex : t -> string
>>
    
    Return the printable hexadecimal representation of the given digest.
  
   

Node: Section 20-8,	Next: Section 20-9,	Prev: Section 20-7,	Up: Chapter 20
  

20.8   Module Filename : Operations on file names.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  
  

<<
  val current_dir_name : string
>>
    
    The conventional name for the current directory (e.g. . in Unix).
  

<<
  val parent_dir_name : string
>>
    
    The conventional name for the parent of the current directory (e.g. .. in
   Unix).
  

<<
  val dir_sep : string
>>
    
    The directory separator (e.g. / in Unix).
   Since: 3.11.2
  

<<
  val concat : string -> string -> string
>>
    
    concat dir file returns a file name that designates file file in directory
   dir.
  

<<
  val is_relative : string -> bool
>>
    
    Return true if the file name is relative to the current directory, false if
   it is absolute (i.e. in Unix, starts with /).
  

<<
  val is_implicit : string -> bool
>>
    
    Return true if the file name is relative and does not start with an
   explicit reference to the current directory (./ or ../ in Unix), false if it
   starts with an explicit reference to the root directory or the current
   directory.
  

<<
  val check_suffix : string -> string -> bool
>>
    
    check_suffix name suff returns true if the filename name ends with the
   suffix suff.
  

<<
  val chop_suffix : string -> string -> string
>>
    
    chop_suffix name suff removes the suffix suff from the filename name. The
   behavior is undefined if name does not end with the suffix suff.
  

<<
  val chop_extension : string -> string
>>
    
    Return the given file name without its extension. The extension is the
   shortest suffix starting with a period and not including a directory
   separator, .xyz for instance.
   Raise Invalid_argument if the given name does not contain an extension.
  

<<
  val basename : string -> string
>>
    
    Split a file name into directory name / base file name. concat (dirname
   name) (basename name) returns a file name which is equivalent to name.
   Moreover, after setting the current directory to dirname name (with
   Sys.chdir[20.34*Note Section 20-34::]), references to basename name (which
   is a relative file name) designate the same file as name before the call to
   Sys.chdir[20.34*Note Section 20-34::].
   The result is not specified if the argument is not a valid file name (for
   example, under Unix if there is a NUL character in the string).
  

<<
  val dirname : string -> string
>>
    
    See Filename.basename[20.8*Note Section 20-8::].
  

<<
  val temp_file : ?temp_dir:string -> string -> string -> string
>>
    
    temp_file prefix suffix returns the name of a fresh temporary file in the
   temporary directory. The base name of the temporary file is formed by
   concatenating prefix, then a suitably chosen integer number, then suffix.
   The optional argument temp_dir indicates the temporary directory to use,
   defaulting to
   Filename.temp_dir_name[20.8]. The temporary file is created empty, with permissions 0o600
   (readable and writable only by the file owner). The file is guaranteed to be
   different from any other file that existed when temp_file was called.
   Before 3.11.2 no ?temp_dir optional argument
  

<<
  val open_temp_file :
    ?mode:Pervasives.open_flag list ->
    ?temp_dir:string -> string -> string -> string * Pervasives.out_channel
>>
    
    Same as Filename.temp_file[20.8*Note Section 20-8::],
   but returns both the name of a fresh temporary file, and an output channel
   opened (atomically) on this file. This function is more secure than
   temp_file: there is no risk that the temporary file will be modified (e.g.
   replaced by a symbolic link) before the program opens it. The optional
   argument mode is a list of additional flags to control the opening of the
   file. It can contain one or several of Open_append, Open_binary, and
   Open_text. The default is [Open_text] (open in text mode).
   Before 3.11.2 no ?temp_dir optional argument
  

<<
  val temp_dir_name : string
>>
    
    The name of the temporary directory: Under Unix, the value of the TMPDIR
   environment variable, or "/tmp" if the variable is not set. Under Windows,
   the value of the TEMP environment variable, or "." if the variable is not
   set.
   Since: 3.09.1
  

<<
  val quote : string -> string
>>
    
    Return a quoted version of a file name, suitable for use as one argument in
   a command line, escaping all meta-characters. Warning: under Windows, the
   output is only suitable for use with programs that follow the standard
   Windows quoting conventions.
  
   

Node: Section 20-9,	Next: Section 20-10,	Prev: Section 20-8,	Up: Chapter 20
  

20.9   Module Format : Pretty printing.
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  This module implements a pretty-printing facility to format text within
"pretty-printing boxes". The pretty-printer breaks lines at specified break
hints, and indents lines according to the box structure.
  For a gentle introduction to the basics of pretty-printing using Format, read
http://caml.inria.fr/resources/doc/guides/format.html[http://caml.inria.fr/reso
urces/doc/guides/format.html].
  You may consider this module as providing an extension to the printf facility
to provide automatic line breaking. The addition of pretty-printing annotations
to your regular printf formats gives you fancy indentation and line breaks.
Pretty-printing annotations are described below in the documentation of the
function Format.fprintf[20.9*Note Section 20-9::].
  You may also use the explicit box management and printing functions provided
by this module. This style is more basic but more verbose than the fprintf
concise formats.
  For instance, the sequence open_box 0; print_string "x ="; print_space (); 
print_int 1; close_box (); print_newline () that prints x = 1 within a
pretty-printing box, can be abbreviated as printf "@[%s@ %i@]@." "x =" 1, or
even shorter printf "@[x =@ %i@]@." 1.
  Rule of thumb for casual users of this library:
  
   - use simple boxes (as obtained by open_box 0); 
   - use simple break hints (as obtained by print_cut () that outputs a simple
   break hint, or by print_space () that outputs a space indicating a break
   hint); 
   - once a box is opened, display its material with basic printing functions
   (e. g. print_int and print_string); 
   - when the material for a box has been printed, call close_box () to close
   the box; 
   - at the end of your routine, flush the pretty-printer to display all the
   remaining material, e.g. evaluate print_newline (). 
  
  The behaviour of pretty-printing commands is unspecified if there is no
opened pretty-printing box. Each box opened via one of the open_ functions
below must be closed using close_box for proper formatting. Otherwise, some of
the material printed in the boxes may not be output, or may be formatted
incorrectly.
  In case of interactive use, the system closes all opened boxes and flushes
all pending text (as with the print_newline function) after each phrase. Each
phrase is therefore executed in the initial state of the pretty-printer.
  Warning: the material output by the following functions is delayed in the
pretty-printer queue in order to compute the proper line breaking. Hence, you
should not mix calls to the printing functions of the basic I/O system with
calls to the functions of this module: this could result in some strange output
seemingly unrelated with the evaluation order of printing commands.
  
  

Boxes
=====
  

<<
  val open_box : int -> unit
>>
    
    open_box d opens a new pretty-printing box with offset d. This box is the
   general purpose pretty-printing box. Material in this box is displayed
   "horizontal or vertical": break hints inside the box may lead to a new line,
   if there is no more room on the line to print the remainder of the box, or
   if a new line may lead to a new indentation (demonstrating the indentation
   of the box). When a new line is printed in the box, d is added to the
   current indentation.
  

<<
  val close_box : unit -> unit
>>
    
    Closes the most recently opened pretty-printing box.
  

Formatting functions
====================
  

<<
  val print_string : string -> unit
>>
    
    print_string str prints str in the current box.
  

<<
  val print_as : int -> string -> unit
>>
    
    print_as len str prints str in the current box. The pretty-printer formats
   str as if it were of length len.
  

<<
  val print_int : int -> unit
>>
    
    Prints an integer in the current box.
  

<<
  val print_float : float -> unit
>>
    
    Prints a floating point number in the current box.
  

<<
  val print_char : char -> unit
>>
    
    Prints a character in the current box.
  

<<
  val print_bool : bool -> unit
>>
    
    Prints a boolean in the current box.
  

Break hints
===========
  

<<
  val print_space : unit -> unit
>>
    
    print_space () is used to separate items (typically to print a space
   between two words). It indicates that the line may be split at this point.
   It either prints one space or splits the line. It is equivalent to
   print_break 1 0.
  

<<
  val print_cut : unit -> unit
>>
    
    print_cut () is used to mark a good break position. It indicates that the
   line may be split at this point. It either prints nothing or splits the
   line. This allows line splitting at the current point, without printing
   spaces or adding indentation. It is equivalent to print_break 0 0.
  

<<
  val print_break : int -> int -> unit
>>
    
    Inserts a break hint in a pretty-printing box. print_break nspaces offset
   indicates that the line may be split (a newline character is printed) at
   this point, if the contents of the current box does not fit on the current
   line. If the line is split at that point, offset is added to the current
   indentation. If the line is not split, nspaces spaces are printed.
  

<<
  val print_flush : unit -> unit
>>
    
    Flushes the pretty printer: all opened boxes are closed, and all pending
   text is displayed.
  

<<
  val print_newline : unit -> unit
>>
    
    Equivalent to print_flush followed by a new line.
  

<<
  val force_newline : unit -> unit
>>
    
    Forces a newline in the current box. Not the normal way of pretty-printing,
   you should prefer break hints.
  

<<
  val print_if_newline : unit -> unit
>>
    
    Executes the next formatting command if the preceding line has just been
   split. Otherwise, ignore the next formatting command.
  

Margin
======
  

<<
  val set_margin : int -> unit
>>
    
    set_margin d sets the value of the right margin to d (in characters): this
   value is used to detect line overflows that leads to split lines. Nothing
   happens if d is smaller than 2. If d is too large, the right margin is set
   to the maximum admissible value (which is greater than 10^10).
  

<<
  val get_margin : unit -> int
>>
    
    Returns the position of the right margin.
  

Maximum indentation limit
=========================
  

<<
  val set_max_indent : int -> unit
>>
    
    set_max_indent d sets the value of the maximum indentation limit to d (in
   characters): once this limit is reached, boxes are rejected to the left, if
   they do not fit on the current line. Nothing happens if d is smaller than 2.
   If d is too large, the limit is set to the maximum admissible value (which
   is greater than 10^10).
  

<<
  val get_max_indent : unit -> int
>>
    
    Return the value of the maximum indentation limit (in characters).
  

Formatting depth: maximum number of boxes allowed before ellipsis
=================================================================
  

<<
  val set_max_boxes : int -> unit
>>
    
    set_max_boxes max sets the maximum number of boxes simultaneously opened.
   Material inside boxes nested deeper is printed as an ellipsis (more
   precisely as the text returned by get_ellipsis_text ()). Nothing happens if
   max is smaller than 2.
  

<<
  val get_max_boxes : unit -> int
>>
    
    Returns the maximum number of boxes allowed before ellipsis.
  

<<
  val over_max_boxes : unit -> bool
>>
    
    Tests if the maximum number of boxes allowed have already been opened.
  

Advanced formatting
===================
  

<<
  val open_hbox : unit -> unit
>>
    
    open_hbox () opens a new pretty-printing box. This box is "horizontal": the
   line is not split in this box (new lines may still occur inside boxes nested
   deeper).
  

<<
  val open_vbox : int -> unit
>>
    
    open_vbox d opens a new pretty-printing box with offset d. This box is
   "vertical": every break hint inside this box leads to a new line. When a new
   line is printed in the box, d is added to the current indentation.
  

<<
  val open_hvbox : int -> unit
>>
    
    open_hvbox d opens a new pretty-printing box with offset d. This box is
   "horizontal-vertical": it behaves as an "horizontal" box if it fits on a
   single line, otherwise it behaves as a "vertical" box. When a new line is
   printed in the box, d is added to the current indentation.
  

<<
  val open_hovbox : int -> unit
>>
    
    open_hovbox d opens a new pretty-printing box with offset d. This box is
   "horizontal or vertical": break hints inside this box may lead to a new
   line, if there is no more room on the line to print the remainder of the
   box. When a new line is printed in the box, d is added to the current
   indentation.
  

Tabulations
===========
  

<<
  val open_tbox : unit -> unit
>>
    
    Opens a tabulation box.
  

<<
  val close_tbox : unit -> unit
>>
    
    Closes the most recently opened tabulation box.
  

<<
  val print_tbreak : int -> int -> unit
>>
    
    Break hint in a tabulation box. print_tbreak spaces offset moves the
   insertion point to the next tabulation (spaces being added to this
   position). Nothing occurs if insertion point is already on a tabulation
   mark. If there is no next tabulation on the line, then a newline is printed
   and the insertion point moves to the first tabulation of the box. If a new
   line is printed, offset is added to the current indentation.
  

<<
  val set_tab : unit -> unit
>>
    
    Sets a tabulation mark at the current insertion point.
  

<<
  val print_tab : unit -> unit
>>
    
    print_tab () is equivalent to print_tbreak 0 0.
  

Ellipsis
========
  

<<
  val set_ellipsis_text : string -> unit
>>
    
    Set the text of the ellipsis printed when too many boxes are opened (a
   single dot, ., by default).
  

<<
  val get_ellipsis_text : unit -> string
>>
    
    Return the text of the ellipsis.
  

Semantics Tags
==============
   

<<
  type tag = string 
>>
   
  Semantics tags (or simply tags) are used to decorate printed entities for
user's defined purposes, e.g. setting font and giving size indications for a
display device, or marking delimitation of semantics entities (e.g. HTML or TeX
elements or terminal escape sequences).
  By default, those tags do not influence line breaking calculation: the tag
"markers" are not considered as part of the printing material that drives line
breaking (in other words, the length of those strings is considered as zero for
line breaking).
  Thus, tag handling is in some sense transparent to pretty-printing and does
not interfere with usual pretty-printing. Hence, a single pretty printing
routine can output both simple "verbatim" material or richer decorated output
depending on the treatment of tags. By default, tags are not active, hence the
output is not decorated with tag information. Once set_tags is set to true, the
pretty printer engine honours tags and decorates the output accordingly.
  When a tag has been opened (or closed), it is both and successively "printed"
and "marked". Printing a tag means calling a formatter specific function with
the name of the tag as argument: that "tag printing" function can then print
any regular material to the formatter (so that this material is enqueued as
usual in the formatter queue for further line-breaking computation). Marking a
tag means to output an arbitrary string (the "tag marker"), directly into the
output device of the formatter. Hence, the formatter specific "tag marking"
function must return the tag marker string associated to its tag argument.
Being flushed directly into the output device of the formatter, tag marker
strings are not considered as part of the printing material that drives line
breaking (in other words, the length of the strings corresponding to tag
markers is considered as zero for line breaking). In addition, advanced users
may take advantage of the specificity of tag markers to be precisely output
when the pretty printer has already decided where to break the lines, and
precisely when the queue is flushed into the output device.
  In the spirit of HTML tags, the default tag marking functions output tags
enclosed in "<" and ">": hence, the opening marker of tag t is "<t>" and the
closing marker "</t>".
  Default tag printing functions just do nothing.
  Tag marking and tag printing functions are user definable and can be set by
calling set_formatter_tag_functions.

<<
  val open_tag : tag -> unit
>>
    
    open_tag t opens the tag named t; the print_open_tag function of the
   formatter is called with t as argument; the tag marker mark_open_tag t will
   be flushed into the output device of the formatter.
  

<<
  val close_tag : unit -> unit
>>
    
    close_tag () closes the most recently opened tag t. In addition, the
   print_close_tag function of the formatter is called with t as argument. The
   marker mark_close_tag t will be flushed into the output device of the
   formatter.
  

<<
  val set_tags : bool -> unit
>>
    
    set_tags b turns on or off the treatment of tags (default is off).
  

<<
  val set_print_tags : bool -> unit
>>
   

<<
  val set_mark_tags : bool -> unit
>>
    
    set_print_tags b turns on or off the printing of tags, while set_mark_tags
   b turns on or off the output of tag markers.
  

<<
  val get_print_tags : unit -> bool
>>
   

<<
  val get_mark_tags : unit -> bool
>>
    
    Return the current status of tags printing and tags marking.
  

Redirecting the standard formatter output
=========================================
  

<<
  val set_formatter_out_channel : Pervasives.out_channel -> unit
>>
    
    Redirect the pretty-printer output to the given channel. (All the output
   functions of the standard formatter are set to the default output functions
   printing to the given channel.)
  

<<
  val set_formatter_output_functions :
    (string -> int -> int -> unit) -> (unit -> unit) -> unit
>>
    
    set_formatter_output_functions out flush redirects the relevant
   pretty-printer output functions to the functions out and flush.
   The out function performs the pretty-printer string output. It is called
   with a string s, a start position p, and a number of characters n; it is
   supposed to output characters p to p + n - 1 of s. The flush function is
   called whenever the pretty-printer is flushed (via conversion %!,
   pretty-printing indications @? or @., or using low level function
   print_flush or print_newline).
  

<<
  val get_formatter_output_functions :
    unit -> (string -> int -> int -> unit) * (unit -> unit)
>>
    
    Return the current output functions of the pretty-printer.
  

Changing the meaning of standard formatter pretty printing
==========================================================
   
  The Format module is versatile enough to let you completely redefine the
meaning of pretty printing: you may provide your own functions to define how to
handle indentation, line breaking, and even printing of all the characters that
have to be printed!

<<
  val set_all_formatter_output_functions :
    out:(string -> int -> int -> unit) ->
    flush:(unit -> unit) ->
    newline:(unit -> unit) -> spaces:(int -> unit) -> unit
>>
    
    set_all_formatter_output_functions out flush outnewline outspace redirects
   the pretty-printer output to the functions out and flush as described in
   set_formatter_output_functions. In addition, the pretty-printer function
   that outputs a newline is set to the function outnewline and the function
   that outputs indentation spaces is set to the function outspace.
   This way, you can change the meaning of indentation (which can be something
   else than just printing space characters) and the meaning of new lines
   opening (which can be connected to any other action needed by the
   application at hand). The two functions outspace and outnewline are normally
   connected to out and flush: respective default values for outspace and
   outnewline are out (String.make n ' ') 0 n and out "\n" 0 1.
  

<<
  val get_all_formatter_output_functions :
    unit ->
    (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
    (int -> unit)
>>
    
    Return the current output functions of the pretty-printer, including line
   breaking and indentation functions. Useful to record the current setting and
   restore it afterwards.
  

Changing the meaning of printing semantics tags
===============================================
   

<<
  type formatter_tag_functions = {
    mark_open_tag : tag -> string ;
    mark_close_tag : tag -> string ;
    print_open_tag : tag -> unit ;
    print_close_tag : tag -> unit ;
  }
>>
    
    The tag handling functions specific to a formatter: mark versions are the
   "tag marking" functions that associate a string marker to a tag in order for
   the pretty-printing engine to flush those markers as 0 length tokens in the
   output device of the formatter. print versions are the "tag printing"
   functions that can perform regular printing when a tag is closed or opened.
  

<<
  val set_formatter_tag_functions : formatter_tag_functions -> unit
>>
   
  set_formatter_tag_functions tag_funs changes the meaning of opening and
closing tags to use the functions in tag_funs.
  When opening a tag name t, the string t is passed to the opening tag marking
function (the mark_open_tag field of the record tag_funs), that must return the
opening tag marker for that name. When the next call to close_tag () happens,
the tag name t is sent back to the closing tag marking function (the
mark_close_tag field of record tag_funs), that must return a closing tag marker
for that name.
  The print_ field of the record contains the functions that are called at tag
opening and tag closing time, to output regular material in the pretty-printer
queue.

<<
  val get_formatter_tag_functions : unit -> formatter_tag_functions
>>
    
    Return the current tag functions of the pretty-printer.
  

Multiple formatted output
=========================
  

<<
  type formatter 
>>
    
    Abstract data corresponding to a pretty-printer (also called a formatter)
   and all its machinery.
   Defining new pretty-printers permits unrelated output of material in
   parallel on several output channels. All the parameters of a pretty-printer
   are local to this pretty-printer: margin, maximum indentation limit, maximum
   number of boxes simultaneously opened, ellipsis, and so on, are specific to
   each pretty-printer and may be fixed independently. Given a
   Pervasives.out_channel output channel oc, a new formatter writing to that
   channel is simply obtained by calling formatter_of_out_channel oc.
   Alternatively, the make_formatter function allocates a new formatter with
   explicit output and flushing functions (convenient to output material to
   strings for instance).
  

<<
  val formatter_of_out_channel : Pervasives.out_channel -> formatter
>>
    
    formatter_of_out_channel oc returns a new formatter that writes to the
   corresponding channel oc.
  

<<
  val std_formatter : formatter
>>
    
    The standard formatter used by the formatting functions above. It is
   defined as formatter_of_out_channel stdout.
  

<<
  val err_formatter : formatter
>>
    
    A formatter to use with formatting functions below for output to standard
   error. It is defined as formatter_of_out_channel stderr.
  

<<
  val formatter_of_buffer : Buffer.t -> formatter
>>
    
    formatter_of_buffer b returns a new formatter writing to buffer b. As
   usual, the formatter has to be flushed at the end of pretty printing, using
   pp_print_flush or pp_print_newline, to display all the pending material.
  

<<
  val stdbuf : Buffer.t
>>
    
    The string buffer in which str_formatter writes.
  

<<
  val str_formatter : formatter
>>
    
    A formatter to use with formatting functions below for output to the stdbuf
   string buffer. str_formatter is defined as formatter_of_buffer stdbuf.
  

<<
  val flush_str_formatter : unit -> string
>>
    
    Returns the material printed with str_formatter, flushes the formatter and
   resets the corresponding buffer.
  

<<
  val make_formatter :
    (string -> int -> int -> unit) -> (unit -> unit) -> formatter
>>
    
    make_formatter out flush returns a new formatter that writes according to
   the output function out, and the flushing function flush. For instance, a
   formatter to the Pervasives.out_channel oc is returned by make_formatter
   (Pervasives.output oc) (fun () -> Pervasives.flush oc).
  

Basic functions to use with formatters
======================================
  

<<
  val pp_open_hbox : formatter -> unit -> unit
>>
   

<<
  val pp_open_vbox : formatter -> int -> unit
>>
   

<<
  val pp_open_hvbox : formatter -> int -> unit
>>
   

<<
  val pp_open_hovbox : formatter -> int -> unit
>>
   

<<
  val pp_open_box : formatter -> int -> unit
>>
   

<<
  val pp_close_box : formatter -> unit -> unit
>>
   

<<
  val pp_open_tag : formatter -> string -> unit
>>
   

<<
  val pp_close_tag : formatter -> unit -> unit
>>
   

<<
  val pp_print_string : formatter -> string -> unit
>>
   

<<
  val pp_print_as : formatter -> int -> string -> unit
>>
   

<<
  val pp_print_int : formatter -> int -> unit
>>
   

<<
  val pp_print_float : formatter -> float -> unit
>>
   

<<
  val pp_print_char : formatter -> char -> unit
>>
   

<<
  val pp_print_bool : formatter -> bool -> unit
>>
   

<<
  val pp_print_break : formatter -> int -> int -> unit
>>
   

<<
  val pp_print_cut : formatter -> unit -> unit
>>
   

<<
  val pp_print_space : formatter -> unit -> unit
>>
   

<<
  val pp_force_newline : formatter -> unit -> unit
>>
   

<<
  val pp_print_flush : formatter -> unit -> unit
>>
   

<<
  val pp_print_newline : formatter -> unit -> unit
>>
   

<<
  val pp_print_if_newline : formatter -> unit -> unit
>>
   

<<
  val pp_open_tbox : formatter -> unit -> unit
>>
   

<<
  val pp_close_tbox : formatter -> unit -> unit
>>
   

<<
  val pp_print_tbreak : formatter -> int -> int -> unit
>>
   

<<
  val pp_set_tab : formatter -> unit -> unit
>>
   

<<
  val pp_print_tab : formatter -> unit -> unit
>>
   

<<
  val pp_set_tags : formatter -> bool -> unit
>>
   

<<
  val pp_set_print_tags : formatter -> bool -> unit
>>
   

<<
  val pp_set_mark_tags : formatter -> bool -> unit
>>
   

<<
  val pp_get_print_tags : formatter -> unit -> bool
>>
   

<<
  val pp_get_mark_tags : formatter -> unit -> bool
>>
   

<<
  val pp_set_margin : formatter -> int -> unit
>>
   

<<
  val pp_get_margin : formatter -> unit -> int
>>
   

<<
  val pp_set_max_indent : formatter -> int -> unit
>>
   

<<
  val pp_get_max_indent : formatter -> unit -> int
>>
   

<<
  val pp_set_max_boxes : formatter -> int -> unit
>>
   

<<
  val pp_get_max_boxes : formatter -> unit -> int
>>
   

<<
  val pp_over_max_boxes : formatter -> unit -> bool
>>
   

<<
  val pp_set_ellipsis_text : formatter -> string -> unit
>>
   

<<
  val pp_get_ellipsis_text : formatter -> unit -> string
>>
   

<<
  val pp_set_formatter_out_channel :
    formatter -> Pervasives.out_channel -> unit
>>
   

<<
  val pp_set_formatter_output_functions :
    formatter -> (string -> int -> int -> unit) -> (unit -> unit) -> unit
>>
   

<<
  val pp_get_formatter_output_functions :
    formatter -> unit -> (string -> int -> int -> unit) * (unit -> unit)
>>
   

<<
  val pp_set_all_formatter_output_functions :
    formatter ->
    out:(string -> int -> int -> unit) ->
    flush:(unit -> unit) ->
    newline:(unit -> unit) -> spaces:(int -> unit) -> unit
>>
   

<<
  val pp_get_all_formatter_output_functions :
    formatter ->
    unit ->
    (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
    (int -> unit)
>>
   

<<
  val pp_set_formatter_tag_functions :
    formatter -> formatter_tag_functions -> unit
>>
   

<<
  val pp_get_formatter_tag_functions :
    formatter -> unit -> formatter_tag_functions
>>
    
    These functions are the basic ones: usual functions operating on the
   standard formatter are defined via partial evaluation of these primitives.
   For instance, print_string is equal to pp_print_string std_formatter.
  

printf like functions for pretty-printing.
==========================================
  

<<
  val fprintf : formatter -> ('a, formatter, unit) Pervasives.format -> 'a
>>
   
  fprintf ff fmt arg1 ... argN formats the arguments arg1 to argN according to
the format string fmt, and outputs the resulting string on the formatter ff.
  The format fmt is a character string which contains three types of objects:
plain characters and conversion specifications as specified in the Printf
module, and pretty-printing indications specific to the Format module.
  The pretty-printing indication characters are introduced by a @ character,
and their meanings are:
  
   - @[: open a pretty-printing box. The type and offset of the box may be
   optionally specified with the following syntax: the < character, followed by
   an optional box type indication, then an optional integer offset, and the
   closing > character. Box type is one of h, v, hv, b, or hov, which stand
   respectively for an horizontal box, a vertical box, an "horizontal-vertical"
   box, or an "horizontal or vertical" box (b standing for an "horizontal or
   vertical" box demonstrating indentation and hov standing for a
   regular"horizontal or vertical" box). For instance, @[<hov 2> opens an
   "horizontal or vertical" box with indentation 2 as obtained with open_hovbox
   2. For more details about boxes, see the various box opening functions
   open_*box. 
   - @]: close the most recently opened pretty-printing box. 
   - @,: output a good break as with print_cut (). 
   - @ : output a space, as with print_space (). 
   - @\n: force a newline, as with force_newline (). 
   - @;: output a good break as with print_break. The nspaces and offset
   parameters of the break may be optionally specified with the following
   syntax: the < character, followed by an integer nspaces value, then an
   integer offset, and a closing > character. If no parameters are provided,
   the good break defaults to a space. 
   - @?: flush the pretty printer as with print_flush (). This is equivalent to
   the conversion %!. 
   - @.: flush the pretty printer and output a new line, as with print_newline
   (). 
   - @<n>: print the following item as if it were of length n. Hence, printf
   "@<0>%s" arg is equivalent to print_as 0 arg. If @<n> is not followed by a
   conversion specification, then the following character of the format is
   printed as if it were of length n. 
   - @{: open a tag. The name of the tag may be optionally specified with the
   following syntax: the < character, followed by an optional string
   specification, and the closing > character. The string specification is any
   character string that does not contain the closing character '>'. If
   omitted, the tag name defaults to the empty string. For more details about
   tags, see the functions open_tag and close_tag. 
   - @}: close the most recently opened tag. 
   - @@: print a plain @ character. 
  
  Example: printf "@[%s@ %d@]@." "x =" 1 is equivalent to open_box ();
print_string "x ="; print_space ();  print_int 1; close_box (); print_newline
(). It prints x = 1 within a pretty-printing box.

<<
  val printf : ('a, formatter, unit) Pervasives.format -> 'a
>>
    
    Same as fprintf above, but output on std_formatter.
  

<<
  val eprintf : ('a, formatter, unit) Pervasives.format -> 'a
>>
    
    Same as fprintf above, but output on err_formatter.
  

<<
  val sprintf : ('a, unit, string) Pervasives.format -> 'a
>>
    
    Same as printf above, but instead of printing on a formatter, returns a
   string containing the result of formatting the arguments. Note that the
   pretty-printer queue is flushed at the end of each call to sprintf.
   In case of multiple and related calls to sprintf to output material on a
   single string, you should consider using fprintf with the predefined
   formatter str_formatter and call flush_str_formatter () to get the final
   result.
   Alternatively, you can use Format.fprintf with a formatter writing to a
   buffer of your own: flushing the formatter and the buffer at the end of
   pretty-printing returns the desired string.
  

<<
  val ifprintf : formatter -> ('a, formatter, unit) Pervasives.format -> 'a
>>
    
    Same as fprintf above, but does not print anything. Useful to ignore some
   material when conditionally printing.
   Since: 3.10.0
  
  Formatted output functions with continuations.

<<
  val kfprintf :
    (formatter -> 'a) ->
    formatter -> ('b, formatter, unit, 'a) Pervasives.format4 -> 'b
>>
    
    Same as fprintf above, but instead of returning immediately, passes the
   formatter to its first argument at the end of printing.
  

<<
  val ikfprintf :
    (formatter -> 'a) ->
    formatter -> ('b, formatter, unit, 'a) Pervasives.format4 -> 'b
>>
    
    Same as kfprintf above, but does not print anything. Useful to ignore some
   material when conditionally printing.
   Since: 3.12.0
  

<<
  val ksprintf :
    (string -> 'a) -> ('b, unit, string, 'a) Pervasives.format4 -> 'b
>>
    
    Same as sprintf above, but instead of returning the string, passes it to
   the first argument.
  

Deprecated
==========
  

<<
  val bprintf : Buffer.t -> ('a, formatter, unit) Pervasives.format -> 'a
>>
    
    Deprecated and error prone function. Do not use it.
   If you need to print to some buffer b, you must first define a formatter
   writing to b, using let to_b = formatter_of_buffer b; then use regular calls
   to Format.fprintf on formatter to_b.
  

<<
  val kprintf :
    (string -> 'a) -> ('b, unit, string, 'a) Pervasives.format4 -> 'b
>>
    
    Deprecated name. A synonym for ksprintf.
  
   
