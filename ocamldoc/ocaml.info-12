This file has been translated from LaTeX by HeVeA.

Node: Subsection 18-5-2,	Next: Section 18-6,	Prev: Subsection 18-5-1,	Up: Section 18-5
  

18.5.2   Low-level interface
============================
  
  We now give the GC rules corresponding to the low-level allocation functions
caml_alloc_small and caml_alloc_shr. You can ignore those rules if you stick to
the simplified allocation function caml_alloc.
  Rule 5   After a structured block (a block with tag less than No_scan_tag) is
allocated with the low-level functions, all fields of this block must be filled
with well-formed values before the next allocation operation. If the block has
been allocated with caml_alloc_small, filling is performed by direct assignment
to the fields of the block: 
<<
          Field(v, n) = v_n;
>>
   If the block has been allocated with caml_alloc_shr, filling is performed
through the caml_initialize function: 
<<
          caml_initialize(&Field(v, n), v_n);
>>
   
  
  The next allocation can trigger a garbage collection. The garbage collector
assumes that all structured blocks contain well-formed values. Newly created
blocks contain random data, which generally do not represent well-formed
values.
  If you really need to allocate before the fields can receive their final
value, first initialize with a constant value (e.g. Val_unit), then allocate,
then modify the fields with the correct value (see rule 6).
  Rule 6   Direct assignment to a field of a block, as in 
<<
          Field(v, n) = w;
>>
   is safe only if v is a block newly allocated by caml_alloc_small; that is,
if no allocation took place between the  allocation of v and the assignment to
the field. In all other cases, never assign directly. If the block has just
been allocated by caml_alloc_shr, use caml_initialize to assign a value to a
field for the first time: 
<<
          caml_initialize(&Field(v, n), w);
>>
   Otherwise, you are updating a field that previously contained a well-formed
value; then, call the caml_modify function: 
<<
          caml_modify(&Field(v, n), w);
>>
   
  
  To illustrate the rules above, here is a C function that builds and returns a
list containing the two integers given as parameters. First, we write it using
the simplified allocation functions: 
<<value alloc_list_int(int i1, int i2)
  {
    CAMLparam0 ();
    CAMLlocal2 (result, r);
  
    r = caml_alloc(2, 0);                   /* Allocate a cons cell */
    Store_field(r, 0, Val_int(i2));         /* car = the integer i2 */
    Store_field(r, 1, Val_int(0));          /* cdr = the empty list [] */
    result = caml_alloc(2, 0);              /* Allocate the other cons cell */
    Store_field(result, 0, Val_int(i1));    /* car = the integer i1 */
    Store_field(result, 1, r);              /* cdr = the first cons cell */
    CAMLreturn (result);
  }
>>
  Here, the registering of result is not strictly needed, because no allocation
takes place after it gets its value, but it's easier and safer to simply
register all the local variables that have type value.
  Here is the same function written using the low-level allocation functions.
We notice that the cons cells are small blocks and can be allocated with
caml_alloc_small, and filled by direct assignments on their fields. 
<<value alloc_list_int(int i1, int i2)
  {
    CAMLparam0 ();
    CAMLlocal2 (result, r);
  
    r = caml_alloc_small(2, 0);                  /* Allocate a cons cell */
    Field(r, 0) = Val_int(i2);              /* car = the integer i2 */
    Field(r, 1) = Val_int(0);               /* cdr = the empty list [] */
    result = caml_alloc_small(2, 0);        /* Allocate the other cons cell */
    Field(result, 0) = Val_int(i1);         /* car = the integer i1 */
    Field(result, 1) = r;                   /* cdr = the first cons cell */
    CAMLreturn (result);
  }
>>
  In the two examples above, the list is built bottom-up. Here is an alternate
way, that proceeds top-down. It is less efficient, but illustrates the use of
caml_modify. 
<<value alloc_list_int(int i1, int i2)
  {
    CAMLparam0 ();
    CAMLlocal2 (tail, r);
  
    r = caml_alloc_small(2, 0);             /* Allocate a cons cell */
    Field(r, 0) = Val_int(i1);              /* car = the integer i1 */
    Field(r, 1) = Val_int(0);               /* A dummy value
    tail = caml_alloc_small(2, 0);          /* Allocate the other cons cell */
    Field(tail, 0) = Val_int(i2);           /* car = the integer i2 */
    Field(tail, 1) = Val_int(0);            /* cdr = the empty list [] */
    caml_modify(&Field(r, 1), tail);        /* cdr of the result = tail */
    CAMLreturn (r);
  }
>>
  It would be incorrect to perform Field(r, 1) = tail directly, because the
allocation of tail has taken place since r was allocated.

Node: Section 18-6,	Next: Section 18-7,	Prev: Section 18-5,	Up: Chapter 18
  

18.6   A complete example
*=*=*=*=*=*=*=*=*=*=*=*=*

   
  This section outlines how the functions from the Unix curses library can be
made available to Objective Caml programs. First of all, here is the interface
curses.mli that declares the curses primitives and data types: 
<<type window                   (* The type "window" remains abstract *)
  external initscr: unit -> window = "curses_initscr"
  external endwin: unit -> unit = "curses_endwin"
  external refresh: unit -> unit = "curses_refresh"
  external wrefresh : window -> unit = "curses_wrefresh"
  external newwin: int -> int -> int -> int -> window = "curses_newwin"
  external addch: char -> unit = "curses_addch"
  external mvwaddch: window -> int -> int -> char -> unit = "curses_mvwaddch"
  external addstr: string -> unit = "curses_addstr"
  external mvwaddstr: window -> int -> int -> string -> unit =
"curses_mvwaddstr"
  (* lots more omitted *)
>>
  To compile this interface: 
<<        ocamlc -c curses.mli
>>
  
  To implement these functions, we just have to provide the stub code; the core
functions are already implemented in the curses library. The stub code file,
curses_stubs.c, looks like this: 
<<#include <curses.h>
  #include <caml/mlvalues.h>
  #include <caml/memory.h>
  #include <caml/alloc.h>
  #include <caml/custom.h>
  
  /* Encapsulation of opaque window handles (of type WINDOW *)
     as Caml custom blocks. */
  
  static struct custom_operations curses_window_ops = {
    "fr.inria.caml.curses_windows",
    custom_finalize_default,
    custom_compare_default,
    custom_hash_default,
    custom_serialize_default,
    custom_deserialize_default
  };
  
  /* Accessing the WINDOW * part of a Caml custom block */
  #define Window_val(v) (*((WINDOW **) Data_custom_val(v)))
  
  /* Allocating a Caml custom block to hold the given WINDOW * */
  static value alloc_window(WINDOW * w)
  {
    value v = alloc_custom(&curses_window_ops, sizeof(WINDOW *), 0, 1);
    Window_val(v) = w;
    return v;
  }
  
  value caml_curses_initscr(value unit)
  {
    CAMLparam1 (unit);
    CAMLreturn (alloc_window(initscr()));
  }
  
  value caml_curses_endwin(value unit)
  {
    CAMLparam1 (unit);
    endwin();
    CAMLreturn (Val_unit);
  }
  
  value caml_curses_refresh(value unit)
  {
    CAMLparam1 (unit);
    refresh();
    CAMLreturn (Val_unit);
  }
  
  value caml_curses_wrefresh(value win)
  {
    CAMLparam1 (win);
    wrefresh(Window_val(win));
    CAMLreturn (Val_unit);
  }
  
  value caml_curses_newwin(value nlines, value ncols, value x0, value y0)
  {
    CAMLparam4 (nlines, ncols, x0, y0);
    CAMLreturn (alloc_window(newwin(Int_val(nlines), Int_val(ncols),
                                    Int_val(x0), Int_val(y0))));
  }
  
  value caml_curses_addch(value c)
  {
    CAMLparam1 (c);
    addch(Int_val(c));            /* Characters are encoded like integers */
    CAMLreturn (Val_unit);
  }
  
  value caml_curses_mvwaddch(value win, value x, value y, value c)
  {
    CAMLparam4 (win, x, y, c);
    mvwaddch(Window_val(win), Int_val(x), Int_val(y), Int_val(c));
    CAMLreturn (Val_unit);
  }
  
  value caml_curses_addstr(value s)
  {
    CAMLparam1 (s);
    addstr(String_val(s));
    CAMLreturn (Val_unit);
  }
  
  value caml_curses_mvwaddstr(value win, value x, value y, value s)
  {
    CAMLparam4 (win, x, y, s);
    mvwaddstr(Window_val(win), Int_val(x), Int_val(y), String_val(s));
    CAMLreturn (Val_unit);
  }
  
  /* This goes on for pages. */
>>
  
  The file curses_stubs.c can be compiled with: 
<<        cc -c -I`ocamlc -where` curses.c
>>
  or, even simpler, 
<<        ocamlc -c curses.c
>>
  (When passed a .c file, the ocamlc command simply calls the C compiler on
that file, with the right -I option.)
  Now, here is a sample Caml program test.ml that uses the curses module: 
<<open Curses
  let main_window = initscr () in
  let small_window = newwin 10 5 20 10 in
    mvwaddstr main_window 10 2 "Hello";
    mvwaddstr small_window 4 3 "world";
    refresh();
    Unix.sleep 5;
    endwin()
>>
  To compile and link this program, run: 
<<        ocamlc -custom -o test unix.cma test.ml curses_stubs.o -cclib
-lcurses
>>
  (On some machines, you may need to put -cclib -ltermcap or -cclib -lcurses
-cclib -ltermcap instead of -cclib -lcurses.)

Node: Section 18-7,	Next: Subsection 18-7-1,	Prev: Section 18-6,	Up: Chapter 18
  

18.7   Advanced topic: callbacks from C to Caml
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

    
  So far, we have described how to call C functions from Caml. In this section,
we show how C functions can call Caml functions, either as callbacks (Caml
calls C which calls Caml), or because the main program is written in C.
* Menu:

* Subsection 18-7-1::	Applying Caml closures from C
* Subsection 18-7-2::	Registering Caml closures for use in C functions
* Subsection 18-7-3::	Registering Caml exceptions for use in C functions
* Subsection 18-7-4::	Main program in C
* Subsection 18-7-5::	Embedding the Caml code in the C code


Node: Subsection 18-7-1,	Next: Subsection 18-7-2,	Prev: Section 18-7,	Up: Section 18-7
  

18.7.1   Applying Caml closures from C
======================================
   
  C functions can apply Caml functional values (closures) to Caml values. The
following functions are provided to perform the applications: 
  
   - caml_callback(f, a) applies the functional value f to the value a and
   return the value returned by f. 
   - caml_callback2(f, a, b) applies the functional value f (which is assumed
   to be a curried Caml function with two arguments) to a and b. 
   - caml_callback3(f, a, b, c) applies the functional value f (a curried Caml
   function with three arguments) to a, b and c. 
   - caml_callbackN(f, n, args) applies the functional value f to the n
   arguments contained in the array of values args. 
   If the function f does not return, but raises an exception that escapes the
scope of the application, then this exception is propagated to the next
enclosing Caml code, skipping over the C code. That is, if a Caml function f
calls a C function g that calls back a Caml function h that raises a stray
exception, then the execution of g is interrupted and the exception is
propagated back into f.
  If the C code wishes to catch exceptions escaping the Caml function, it can
use the functions caml_callback_exn, caml_callback2_exn, caml_callback3_exn,
caml_callbackN_exn. These functions take the same arguments as their non-_exn
counterparts, but catch escaping exceptions and return them to the C code. The
return value v of the caml_callback*_exn functions must be tested with the
macro Is_exception_result(v). If the macro returns "false", no exception
occured, and v is the value returned by the Caml function. If
Is_exception_result(v) returns "true", an exception escaped, and its value (the
exception descriptor) can be recovered using Extract_exception(v).

Node: Subsection 18-7-2,	Next: Subsection 18-7-3,	Prev: Subsection 18-7-1,	Up: Section 18-7
  

18.7.2   Registering Caml closures for use in C functions
=========================================================
  
  The main difficulty with the callback functions described above is obtaining
a closure to the Caml function to be called. For this purpose, Objective Caml
provides a simple registration mechanism, by which Caml code can register Caml
functions under some global name, and then C code can retrieve the
corresponding closure by this global name.
  On the Caml side, registration is performed by evaluating Callback.register n
v. Here, n is the global name (an arbitrary string) and v the Caml value. For
instance: 
<<    let f x = print_string "f is applied to "; print_int x; print_newline()
      let _ = Callback.register "test function" f
>>
  
  On the C side, a pointer to the value registered under name n is obtained by
calling caml_named_value(n). The returned pointer must then be dereferenced to
recover the actual Caml value. If no value is registered under the name n, the
null pointer is returned. For example, here is a C wrapper that calls the Caml
function f above: 
<<    void call_caml_f(int arg)
      {
          caml_callback(*caml_named_value("test function"), Val_int(arg));
      }
>>
  
  The pointer returned by caml_named_value is constant and can safely be cached
in a C variable to avoid repeated name lookups. On the other hand, the value
pointed to can change during garbage collection and must always be recomputed
at the point of use. Here is a more efficient variant of call_caml_f above that
calls caml_named_value only once: 
<<    void call_caml_f(int arg)
      {
          static value * closure_f = NULL;
          if (closure_f == NULL) {
              /* First time around, look up by name */
              closure_f = caml_named_value("test function");
          }
          caml_callback(*closure_f, Val_int(arg));
      }
>>
  

Node: Subsection 18-7-3,	Next: Subsection 18-7-4,	Prev: Subsection 18-7-2,	Up: Section 18-7
  

18.7.3   Registering Caml exceptions for use in C functions
===========================================================
   
  The registration mechanism described above can also be used to communicate
exception identifiers from Caml to C. The Caml code registers the exception by
evaluating Callback.register_exception n exn, where n is an arbitrary name and
exn is an exception value of the exception to register. For example: 
<<    exception Error of string
      let _ = Callback.register_exception "test exception" (Error "any string")
>>
  The C code can then recover the exception identifier using caml_named_value
and pass it as first argument to the functions raise_constant, raise_with_arg,
and raise_with_string (described in section 18.4.5*Note Subsection 18-4-5::)
to actually raise the exception. For example, here is a C function that raises
the Error exception with the given argument: 
<<    void raise_error(char * msg)
      {
          caml_raise_with_string(*caml_named_value("test exception"), msg);
      }
>>
  

Node: Subsection 18-7-4,	Next: Subsection 18-7-5,	Prev: Subsection 18-7-3,	Up: Section 18-7
  

18.7.4   Main program in C
==========================
   
  In normal operation, a mixed Caml/C program starts by executing the Caml
initialization code, which then may proceed to call C functions. We say that
the main program is the Caml code. In some applications, it is desirable that
the C code plays the role of the main program, calling Caml functions when
needed. This can be achieved as follows: 
  
   - The C part of the program must provide a main function, which will
   override the default main function provided by the Caml runtime system.
   Execution will start in the user-defined main function just like for a
   regular C program.
 
   - At some point, the C code must call caml_main(argv) to initialize the Caml
   code. The argv argument is a C array of strings (type char **), terminated
   with a NULL pointer, which represents the command-line arguments, as passed
   as second argument to main. The Caml array Sys.argv will be initialized from
   this parameter. For the bytecode compiler, argv[0] and argv[1] are also
   consulted to find the file containing the bytecode.
 
   - The call to caml_main initializes the Caml runtime system, loads the
   bytecode (in the case of the bytecode compiler), and executes the
   initialization code of the Caml program. Typically, this initialization code
   registers callback functions using Callback.register. Once the Caml
   initialization code is complete, control returns to the C code that called
   caml_main.
 
   - The C code can then invoke Caml functions using the callback mechanism
   (see section 18.7.1*Note Subsection 18-7-1::). 
  

Node: Subsection 18-7-5,	Next: Section 18-8,	Prev: Subsection 18-7-4,	Up: Section 18-7
  

18.7.5   Embedding the Caml code in the C code
==============================================
   
  The bytecode compiler in custom runtime mode (ocamlc -custom) normally
appends the bytecode to the executable file containing the custom runtime. This
has two consequences. First, the final linking step must be performed by
ocamlc. Second, the Caml runtime library must be able to find the name of the
executable file from the command-line arguments. When using caml_main(argv) as
in section 18.7.4*Note Subsection 18-7-4::, this means that argv[0] or argv[1] must
contain the executable file name.
  An alternative is to embed the bytecode in the C code. The -output-obj option
to ocamlc is provided for this purpose. It causes the ocamlc compiler to output
a C object file (.o file, .obj under Windows) containing the bytecode for the
Caml part of the program, as well as a caml_startup function. The C object file
produced by ocamlc -output-obj can then be linked with C code using the
standard C compiler, or stored in a C library.
  The caml_startup function must be called from the main C program in order to
initialize the Caml runtime and execute the Caml initialization code. Just like
caml_main, it takes one argv parameter containing the command-line parameters.
Unlike caml_main, this argv parameter is used only to initialize Sys.argv, but
not for finding the name of the executable file.
  The -output-obj option can also be used to obtain the C source file. More
interestingly, the same option can also produce directly a shared library (.so
file, .dll under Windows) that contains the Caml code, the Caml runtime system
and any other static C code given to ocamlc (.o, .a, respectively, .obj, .lib).
This use of -output-obj is very similar to a normal linking step, but instead
of producing a main program that automatically runs the Caml code, it produces
a shared library that can run the Caml code on demand. The three possible
behaviors of -output-obj are selected according to the extension of the
resulting file (given with -o).
  The native-code compiler ocamlopt also supports the -output-obj option,
causing it to output a C object file or a shared library containing the native
code for all Caml modules on the command-line, as well as the Caml startup
code. Initialization is performed by calling caml_startup as in the case of the
bytecode compiler.
  For the final linking phase, in addition to the object file produced by
-output-obj, you will have to provide the Objective Caml runtime library
(libcamlrun.a for bytecode, libasmrun.a for native-code), as well as all C
libraries that are required by the Caml libraries used. For instance, assume
the Caml part of your program uses the Unix library. With ocamlc, you should
do: 
<<
          ocamlc -output-obj -o camlcode.o unix.cma other .cmo and .cma files
          cc -o myprog C objects and libraries \
             camlcode.o -L/usr/local/lib/ocaml -lunix -lcamlrun
>>
   With ocamlopt, you should do: 
<<
          ocamlopt -output-obj -o camlcode.o unix.cmxa other .cmx and .cmxa
files
          cc -o myprog C objects and libraries \
             camlcode.o -L/usr/local/lib/ocaml -lunix -lasmrun
>>
  
  The shared libraries produced by ocamlc -output-obj or by ocamlopt
-output-obj already contains the Objective Caml runtime library as well as all
the needed C libraries.
 Warning:
   On some ports, special options are required on the final linking phase that
links together the object file produced by the -output-obj option and the
remainder of the program. Those options are shown in the configuration file
config/Makefile generated during compilation of Objective Caml, as the
variables BYTECCLINKOPTS (for object files produced by ocamlc -output-obj) and
NATIVECCLINKOPTS (for object files produced by ocamlopt -output-obj).
Currently, the only ports that require special attention are: 
  
   - Alpha under Digital Unix / Tru64 Unix with gcc: object files produced by
   ocamlc -output-obj must be linked with the gcc options -Wl,-T,12000000
   -Wl,-D,14000000. This is not necessary for object files produced by ocamlopt
   -output-obj. 
   - Windows NT: the object file produced by Objective Caml have been compiled
   with the /MD flag, and therefore all other object files linked with it
   should also be compiled with /MD. 
  

Node: Section 18-8,	Next: Section 18-9,	Prev: Section 18-7,	Up: Chapter 18
  

18.8   Advanced example with callbacks
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  This section illustrates the callback facilities described in
section 18.7*Note Section 18-7::. We are going to package some Caml
functions in such a way that they can be linked with C code and called from C
just like any C functions. The Caml functions are defined in the following
mod.ml Caml source:
<<(* File mod.ml -- some ``useful'' Caml functions *)
  
  let rec fib n = if n < 2 then 1 else fib(n-1) + fib(n-2)
  
  let format_result n = Printf.sprintf "Result is: %d\n" n
  
  (* Export those two functions to C *)
  
  let _ = Callback.register "fib" fib
  let _ = Callback.register "format_result" format_result
>>
  
  Here is the C stub code for calling these functions from C:
<</* File modwrap.c -- wrappers around the Caml functions */
  
  #include <stdio.h>
  #include <string.h>
  #include <caml/mlvalues.h>
  #include <caml/callback.h>
  
  int fib(int n)
  {
    static value * fib_closure = NULL;
    if (fib_closure == NULL) fib_closure = caml_named_value("fib");
    return Int_val(caml_callback(*fib_closure, Val_int(n)));
  }
  
  char * format_result(int n)
  {
    static value * format_result_closure = NULL;
    if (format_result_closure == NULL)
      format_result_closure = caml_named_value("format_result");
    return strdup(String_val(caml_callback(*format_result_closure,
Val_int(n))));
    /* We copy the C string returned by String_val to the C heap
       so that it remains valid after garbage collection. */
  }
>>
  
  We now compile the Caml code to a C object file and put it in a C library
along with the stub code in modwrap.c and the Caml runtime system: 
<<        ocamlc -custom -output-obj -o modcaml.o mod.ml
          ocamlc -c modwrap.c
          cp /usr/local/lib/ocaml/libcamlrun.a mod.a
          ar r mod.a modcaml.o modwrap.o
>>
  (One can also use ocamlopt -output-obj instead of ocamlc -custom -output-obj.
In this case, replace libcamlrun.a (the bytecode runtime library) by
libasmrun.a (the native-code runtime library).)
  Now, we can use the two functions fib and format_result in any C program,
just like regular C functions. Just remember to call caml_startup once before.
<</* File main.c -- a sample client for the Caml functions */
  
  #include <stdio.h>
  
  int main(int argc, char ** argv)
  {
    int result;
  
    /* Initialize Caml code */
    caml_startup(argv);
    /* Do some computation */
    result = fib(10);
    printf("fib(10) = %s\n", format_result(result));
    return 0;
  }
>>
  
  To build the whole program, just invoke the C compiler as follows: 
<<        cc -o prog main.c mod.a -lcurses
>>
  (On some machines, you may need to put -ltermcap or -lcurses -ltermcap
instead of -lcurses.)

Node: Section 18-9,	Next: Subsection 18-9-1,	Prev: Section 18-8,	Up: Chapter 18
  

18.9   Advanced topic: custom blocks
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

    
  Blocks with tag Custom_tag contain both arbitrary user data and a pointer to
a C struct, with type struct custom_operations, that associates user-provided
finalization, comparison, hashing, serialization and deserialization functions
to this block.
* Menu:

* Subsection 18-9-1::	The struct custom_operations
* Subsection 18-9-2::	Allocating custom blocks
* Subsection 18-9-3::	Accessing custom blocks
* Subsection 18-9-4::	Writing custom serialization and deserialization functions
* Subsection 18-9-5::	Choosing identifiers
* Subsection 18-9-6::	Finalized blocks


Node: Subsection 18-9-1,	Next: Subsection 18-9-2,	Prev: Section 18-9,	Up: Section 18-9
  

18.9.1   The struct custom_operations
=====================================
  
  The struct custom_operations is defined in <caml/custom.h> and contains the
following fields: 
  
   - char *identifier
 A zero-terminated character string serving as an identifier for serialization
   and deserialization operations.
 
   - void  (*finalize)(value v)
 The finalize field contains a pointer to a C function that is called when the
   block becomes unreachable and is about to be reclaimed. The block is passed
   as first argument to the function. The finalize field can also be
   custom_finalize_default to indicate that no finalization function is
   associated with the block.
 
   - int (*compare)(value v1, value v2)
 The compare field contains a pointer to a C function that is called whenever
   two custom blocks are compared using Caml's generic comparison operators (=,
   <>, <=, >=, <, > and compare). The C function should return 0 if the data
   contained in the two blocks are structurally equal, a negative integer if
   the data from the first block is less than the data from the second block,
   and a positive integer if the data from the first block is greater than the
   data from the second block.
 The compare field can be set to custom_compare_default; this default
   comparison function simply raises Failure.
 
   - long (*hash)(value v)
 The hash field contains a pointer to a C function that is called whenever
   Caml's generic hash operator (see module Hashtbl) is applied to a custom
   block. The C function can return an arbitrary long integer representing the
   hash value of the data contained in the given custom block. The hash value
   must be compatible with the compare function, in the sense that two
   structurally equal data (that is, two custom blocks for which compare
   returns 0) must have the same hash value.
 The hash field can be set to custom_hash_default, in which case the custom
   block is ignored during hash computation.
 
   - void (*serialize)(value v, unsigned long * wsize_32, unsigned long *
   wsize_64)
 The serialize field contains a pointer to a C function that is called whenever
   the custom block needs to be serialized (marshaled) using the Caml functions
   output_value or Marshal.to_.... For a custom block, those functions first
   write the identifier of the block (as given by the identifier field) to the
   output stream, then call the user-provided serialize function. That function
   is responsible for writing the data contained in the custom block, using the
   serialize_... functions defined in <caml/intext.h> and listed below. The
   user-provided serialize function must then store in its wsize_32 and
   wsize_64 parameters the sizes in bytes of the data part of the custom block
   on a 32-bit architecture and on a 64-bit architecture, respectively.
 The serialize field can be set to custom_serialize_default, in which case the
   Failure exception is raised when attempting to serialize the custom block.
 
   - unsigned long (*deserialize)(void * dst)
 The deserialize field contains a pointer to a C function that is called
   whenever a custom block with identifier identifier needs to be deserialized
   (un-marshaled) using the Caml functions input_value or Marshal.from_....
   This user-provided function is responsible for reading back the data written
   by the serialize operation, using the deserialize_... functions defined in
   <caml/intext.h> and listed below. It must then rebuild the data part of the
   custom block and store it at the pointer given as the dst argument. Finally,
   it returns the size in bytes of the data part of the custom block. This size
   must be identical to the wsize_32 result of the serialize operation if the
   architecture is 32 bits, or wsize_64 if the architecture is 64 bits.
 The deserialize field can be set to custom_deserialize_default to indicate
   that deserialization is not supported. In this case, do not register the
   struct custom_operations with the deserializer using
   register_custom_operations (see below). 
  
  Note: the finalize, compare, hash, serialize and deserialize functions
attached to custom block descriptors must never trigger a garbage collection.
Within these functions, do not call any of the Caml allocation functions, and
do not perform a callback into Caml code. Do not use CAMLparam to register the
parameters to these functions, and do not use CAMLreturn to return the result.

Node: Subsection 18-9-2,	Next: Subsection 18-9-3,	Prev: Subsection 18-9-1,	Up: Section 18-9
  

18.9.2   Allocating custom blocks
=================================
  
  Custom blocks must be allocated via the caml_alloc_custom function.
caml_alloc_custom(ops, size, used, max) returns a fresh custom block, with room
for size bytes of user data, and whose associated operations are given by ops
(a pointer to a struct custom_operations, usually statically allocated as a C
global variable). 
  The two parameters used and max are used to control the speed of garbage
collection when the finalized object contains pointers to out-of-heap
resources. Generally speaking, the Caml incremental major collector adjusts its
speed relative to the allocation rate of the program. The faster the program
allocates, the harder the GC works in order to reclaim quickly unreachable
blocks and avoid having large amount of "floating garbage" (unreferenced
objects that the GC has not yet collected).
  Normally, the allocation rate is measured by counting the in-heap size of
allocated blocks. However, it often happens that finalized objects contain
pointers to out-of-heap memory blocks and other resources (such as file
descriptors, X Windows bitmaps, etc.). For those blocks, the in-heap size of
blocks is not a good measure of the quantity of resources allocated by the
program.
  The two arguments used and max give the GC an idea of how much out-of-heap
resources are consumed by the finalized block being allocated: you give the
amount of resources allocated to this object as parameter used, and the maximum
amount that you want to see in floating garbage as parameter max. The units are
arbitrary: the GC cares only about the ratio used / max.
  For instance, if you are allocating a finalized block holding an X Windows
bitmap of w by h pixels, and you'd rather not have more than 1 mega-pixels of
unreclaimed bitmaps, specify used = w * h and max = 1000000.
  Another way to describe the effect of the used and max parameters is in terms
of full GC cycles. If you allocate many custom blocks with used / max = 1 / N,
the GC will then do one full cycle (examining every object in the heap and
calling finalization functions on those that are unreachable) every N
allocations. For instance, if used = 1 and max = 1000, the GC will do one full
cycle at least every 1000 allocations of custom blocks.
  If your finalized blocks contain no pointers to out-of-heap resources, or if
the previous discussion made little sense to you, just take used = 0 and max =
1. But if you later find that the finalization functions are not called "often
enough", consider increasing the used / max ratio.

Node: Subsection 18-9-3,	Next: Subsection 18-9-4,	Prev: Subsection 18-9-2,	Up: Section 18-9
  

18.9.3   Accessing custom blocks
================================
  
  The data part of a custom block v can be accessed via the pointer
Data_custom_val(v). This pointer has type void * and should be cast to the
actual type of the data stored in the custom block.
  The contents of custom blocks are not scanned by the garbage collector, and
must therefore not contain any pointer inside the Caml heap. In other terms,
never store a Caml value in a custom block, and do not use Field, Store_field
nor caml_modify to access the data part of a custom block. Conversely, any C
data structure (not containing heap pointers) can be stored in a custom block.

Node: Subsection 18-9-4,	Next: Subsection 18-9-5,	Prev: Subsection 18-9-3,	Up: Section 18-9
  

18.9.4   Writing custom serialization and deserialization functions
===================================================================
  
  The following functions, defined in <caml/intext.h>, are provided to write
and read back the contents of custom blocks in a portable way. Those functions
handle endianness conversions when e.g. data is written on a little-endian
machine and read back on a big-endian machine.
                                         
            -------------------------------------------------------
            |        Function        |           Action           |
            -------------------------------------------------------
            | caml_serialize_int_1   |Write a 1-byte integer      |
            |caml_serialize_int_2    |Write a 2-byte integer      |
            |caml_serialize_int_4    |Write a 4-byte integer      |
            |caml_serialize_int_8    |Write a 8-byte integer      |
            |caml_serialize_float_4  |Write a 4-byte float        |
            |caml_serialize_float_8  |Write a 8-byte float        |
            |caml_serialize_block_1  |Write an array of 1-byte    |
            |                        |quantities                  |
            |caml_serialize_block_2  |Write an array of 2-byte    |
            |                        |quantities                  |
            |caml_serialize_block_4  |Write an array of 4-byte    |
            |                        |quantities                  |
            |caml_serialize_block_8  |Write an array of 8-byte    |
            |                        |quantities                  |
            |caml_deserialize_uint_1 |Read an unsigned 1-byte     |
            |                        |integer                     |
            |caml_deserialize_sint_1 |Read a signed 1-byte integer|
            |                        |                            |
            |caml_deserialize_uint_2 |Read an unsigned 2-byte     |
            |                        |integer                     |
            |caml_deserialize_sint_2 |Read a signed 2-byte integer|
            |                        |                            |
            |caml_deserialize_uint_4 |Read an unsigned 4-byte     |
            |                        |integer                     |
            |caml_deserialize_sint_4 |Read a signed 4-byte integer|
            |                        |                            |
            |caml_deserialize_uint_8 |Read an unsigned 8-byte     |
            |                        |integer                     |
            |caml_deserialize_sint_8 |Read a signed 8-byte integer|
            |                        |                            |
            |caml_deserialize_float_4|Read a 4-byte float         |
            |caml_deserialize_float_8|Read an 8-byte float        |
            |caml_deserialize_block_1|Read an array of 1-byte     |
            |                        |quantities                  |
            |caml_deserialize_block_2|Read an array of 2-byte     |
            |                        |quantities                  |
            |caml_deserialize_block_4|Read an array of 4-byte     |
            |                        |quantities                  |
            |caml_deserialize_block_8|Read an array of 8-byte     |
            |                        |quantities                  |
            |caml_deserialize_error  |Signal an error during      |
            |                        |deserialization; input_value|
            |                        |or Marshal.from_... raise a |
            |                        |Failure exception after     |
            |                        |cleaning up their internal  |
            |                        |data structures             |
            -------------------------------------------------------
  
  Serialization functions are attached to the custom blocks to which they
apply. Obviously, deserialization functions cannot be attached this way, since
the custom block does not exist yet when deserialization begins! Thus, the
struct custom_operations that contain deserialization functions must be
registered with the deserializer in advance, using the
register_custom_operations function declared in <caml/custom.h>.
Deserialization proceeds by reading the identifier off the input stream,
allocating a custom block of the size specified in the input stream, searching
the registered struct custom_operation blocks for one with the same identifier,
and calling its deserialize function to fill the data part of the custom block.

Node: Subsection 18-9-5,	Next: Subsection 18-9-6,	Prev: Subsection 18-9-4,	Up: Section 18-9
  

18.9.5   Choosing identifiers
=============================
  
  Identifiers in struct custom_operations must be chosen carefully, since they
must identify uniquely the data structure for serialization and deserialization
operations. In particular, consider including a version number in the
identifier; this way, the format of the data can be changed later, yet
backward-compatible deserialisation functions can be provided.
  Identifiers starting with _ (an underscore character) are reserved for the
Objective Caml runtime system; do not use them for your custom data. We
recommend to use a URL (http://mymachine.mydomain.com/mylibrary/version-number)
or a Java-style package name (com.mydomain.mymachine.mylibrary.version-number)
as identifiers, to minimize the risk of identifier collision.

Node: Subsection 18-9-6,	Next: Section 18-10,	Prev: Subsection 18-9-5,	Up: Section 18-9
  

18.9.6   Finalized blocks
=========================
  
  Custom blocks generalize the finalized blocks that were present in Objective
Caml prior to version 3.00. For backward compatibility, the format of custom
blocks is compatible with that of finalized blocks, and the alloc_final
function is still available to allocate a custom block with a given
finalization function, but default comparison, hashing and serialization
functions. caml_alloc_final(n, f, used, max) returns a fresh custom block of
size n words, with finalization function f. The first word is reserved for
storing the custom operations; the other n-1 words are available for your data.
The two parameters used and max are used to control the speed of garbage
collection, as described for caml_alloc_custom.

Node: Section 18-10,	Next: Subsection 18-10-1,	Prev: Section 18-9,	Up: Chapter 18
  

18.10   Advanced topic: multithreading
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  Using multiple threads (shared-memory concurrency) in a mixed Caml/C
application requires special precautions, which are described in this section.
* Menu:

* Subsection 18-10-1::	Registering threads created from C
* Subsection 18-10-2::	Parallel execution of long-running C code


Node: Subsection 18-10-1,	Next: Subsection 18-10-2,	Prev: Section 18-10,	Up: Section 18-10
  

18.10.1   Registering threads created from C
============================================
  
  Callbacks from C to Caml are possible only if the calling thread is known to
the Caml run-time system. Threads created from Caml (through the Thread.create
function of the system threads library) are automatically known to the run-time
system. If the application creates additional threads from C and wishes to
callback into Caml code from these threads, it must first register them with
the run-time system. The following functions are declared in the include file
<caml/threads.h>.
  
  
   - caml_c_thread_register() registers the calling thread with the Caml
   run-time system. Returns 1 on success, 0 on error. Registering an
   already-register thread does nothing and returns 0. 
   - caml_c_thread_unregister() must be called before the thread terminates, to
   unregister it from the Caml run-time system. Returns 1 on success, 0 on
   error. If the calling thread was not previously registered, does nothing and
   returns 0. 
  

Node: Subsection 18-10-2,	Next: Section 18-11,	Prev: Subsection 18-10-1,	Up: Section 18-10
  

18.10.2   Parallel execution of long-running C code
===================================================
  
  The Caml run-time system is not reentrant: at any time, at most one thread
can be executing Caml code or C code that uses the Caml run-time system.
Technically, this is enforced by a "master lock" that any thread must hold
while executing such code.
  When Caml calls the C code implementing a primitive, the master lock is held,
therefore the C code has full access to the facilities of the run-time system.
However, no other thread can execute Caml code concurrently with the C code of
the primitive.
  If a C primitive runs for a long time or performs potentially blocking
input-output operations, it can explicitly release the master lock, enabling
other Caml threads to run concurrently with its operations. The C code must
re-acquire the master lock before returning to Caml. This is achieved with the
following functions, declared in  the include file <caml/threads.h>.
  
  
   - caml_release_runtime_system() The calling thread releases the master lock
   and other Caml resources, enabling other threads to run Caml code in
   parallel with the execution of the calling thread.  
   - caml_acquire_runtime_system() The calling thread re-acquires the master
   lock and other Caml resources. It may block until no other thread uses the
   Caml run-time system. 
  
  After caml_release_runtime_system() was called and until
caml_acquire_runtime_system() is called, the C code must not access any Caml
data, nor call any function of the run-time system, nor call back into Caml
code. Consequently, arguments provided by Caml to the C primitive must be
copied into C data structures before calling caml_release_runtime_system(), and
results to be returned to Caml must be encoded as Caml values after
caml_acquire_runtime_system() returns.
  Example: the following C primitive invokes gethostbyname to find the IP
address of a host name. The gethostbyname function can block for a long time,
so we choose to release the Caml run-time system while it is running. 
<<CAMLprim stub_gethostbyname(value vname)
  {
    CAMLparam1 (vname);
    CAMLlocal1 (vres);
    struct hostent * h;
  
    /* Copy the string argument to a C string, allocated outside the
       Caml heap. */
    name = stat_alloc(caml_string_length(vname) + 1);
    strcpy(name, String_val(vname));
    /* Release the Caml run-time system */
    caml_release_runtime_system();
    /* Resolve the name */
    h = gethostbyname(name);
    /* Re-acquire the Caml run-time system */
    caml_acquire_runtime_system();
    /* Encode the relevant fields of h as the Caml value vres */
    ... /* Omitted */
    /* Return to Caml */
    CAMLreturn (vres);
  }
>>
  
  Callbacks from C to Caml must be performed while holding the master lock to
the Caml run-time system. This is naturally the case if the callback is
performed by a C primitive that did not release the run-time system. If the C
primitive released the run-time system previously, or the callback is performed
from other C code that was not invoked from Caml (e.g. an event loop in a GUI
application), the run-time system must be acquired before the callback and
released after: 
<<  caml_acquire_runtime_system();
    /* Resolve Caml function vfun to be invoked */
    /* Build Caml argument varg to the callback */
    vres = callback(vfun, varg);
    /* Copy relevant parts of result vres to C data structures */
    caml_release_runtime_system();
>>
  
  Note: the acquire and release functions described above were introduced in
OCaml 3.12. Older code uses the following historical names, declared in
<caml/signals.h>: 
  
   - caml_enter_blocking_section as an alias for caml_release_runtime_system 
   - caml_leave_blocking_section as an alias for caml_acquire_runtime_system 
   Intuition: a "blocking section" is a piece of C code that does not use the
Caml run-time system, typically a blocking input/output operation.

Node: Section 18-11,	Next: Part IV,	Prev: Section 18-10,	Up: Chapter 18
  

18.11   Building mixed C/Caml libraries: ocamlmklib
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
  The ocamlmklib command facilitates the construction of libraries containing
both Caml code and C code, and usable both in static linking and dynamic
linking modes. This command is available under Windows since OCaml 3.11 and
under other operating systems since OCaml 3.03.
  The ocamlmklib command takes three kinds of arguments: 
  
   - Caml source files and object files (.cmo, .cmx, .ml) comprising the Caml
   part of the library; 
   - C object files (.o, .a, respectively, .obj, .lib) comprising the C part of
   the library; 
   - Support libraries for the C part (-llib). 
   It generates the following outputs: 
  
   - A Caml bytecode library .cma incorporating the .cmo and .ml Caml files
   given as arguments, and automatically referencing the C library generated
   with the C object files. 
   - A Caml native-code library .cmxa incorporating the .cmx and .ml Caml files
   given as arguments, and automatically referencing the C library generated
   with the C object files. 
   - If dynamic linking is supported on the target platform, a .so
   (respectively, .dll) shared library built from the C object files given as
   arguments, and automatically referencing the support libraries. 
   - A C static library .a(respectively, .lib) built from the C object files. 
   In addition, the following options are recognized: 
  
 -cclib, -ccopt, -I, -linkall  These options are passed as is to ocamlc or
   ocamlopt. See the documentation of these commands. 
 -pthread, -rpath, -R, -Wl,-rpath, -Wl,-R  These options are passed as is to
   the C compiler. Refer to the documentation of the C compiler. 
 -custom  Force the construction of a statically linked library only, even if
   dynamic linking is supported. 
 -failsafe  Fall back to building a statically linked library if a problem
   occurs while building the shared library (e.g. some of the support libraries
   are not available as shared libraries). 
 -Ldir  Add dir to the search path for support libraries (-llib). 
 -ocamlc cmd  Use cmd instead of ocamlc to call the bytecode compiler. 
 -ocamlopt cmd  Use cmd instead of ocamlopt to call the native-code compiler. 
 -o output  Set the name of the generated Caml library. ocamlmklib will
   generate output.cma and/or output.cmxa. If not specified, defaults to a. 
 -oc outputc  Set the name of the generated C library. ocamlmklib will generate
   liboutputc.so (if shared libraries are supported) and liboutputc.a. If not
   specified, defaults to the output name given with -o. 
  
 Example
   Consider a Caml interface to the standard libz C library for reading and
writing compressed files. Assume this library resides in /usr/local/zlib. This
interface is composed of a Caml part zip.cmo/zip.cmx and a C part zipstubs.o
containing the stub code around the libz entry points. The following command
builds the Caml libraries zip.cma and zip.cmxa, as well as the companion C
libraries dllzip.so and libzip.a: 
<<ocamlmklib -o zip zip.cmo zip.cmx zipstubs.o -lz -L/usr/local/zlib
>>
  If shared libraries are supported, this performs the following commands: 
<<ocamlc -a -o zip.cma zip.cmo -dllib -lzip \
          -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
  ocamlopt -a -o zip.cmxa zip.cmx -cclib -lzip \
          -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
  gcc -shared -o dllzip.so zipstubs.o -lz -L/usr/local/zlib
  ar rc libzip.a zipstubs.o
>>
  If shared libraries are not supported, the following commands are performed
instead: 
<<ocamlc -a -custom -o zip.cma zip.cmo -cclib -lzip \
          -cclib -lz -ccopt -L/usr/local/zlib
  ocamlopt -a -o zip.cmxa zip.cmx -lzip \
          -cclib -lz -ccopt -L/usr/local/zlib
  ar rc libzip.a zipstubs.o
>>
  Instead of building simultaneously the bytecode library, the native-code
library and the C libraries, ocamlmklib can be called three times to build each
separately. Thus, 
<<ocamlmklib -o zip zip.cmo -lz -L/usr/local/zlib
>>
  builds the bytecode library zip.cma, and 
<<ocamlmklib -o zip zip.cmx -lz -L/usr/local/zlib
>>
  builds the native-code library zip.cmxa, and 
<<ocamlmklib -o zip zipstubs.o -lz -L/usr/local/zlib
>>
  builds the C libraries dllzip.so and libzip.a. Notice that the support
libraries (-lz) and the corresponding options (-L/usr/local/zlib) must be given
on all three invocations of ocamlmklib, because they are needed at different
times depending on whether shared libraries are supported.

Node: Part IV,	Next: Chapter 19,	Prev: Chapter 18,	Up: Top
  

                                   Part: IV
                                   ********
                           The Objective Caml library
                          ***************************
    
* Menu:

* Chapter 19::	The core library
* Chapter 20::	The standard library
* Chapter 21::	The unix library: Unix system calls
* Chapter 22::	The num library: arbitrary-precision rational arithmetic
* Chapter 23::	The str library: regular expressions and string processing
* Chapter 24::	The threads library
* Chapter 25::	The graphics library
* Chapter 26::	The dbm library: access to NDBM databases
* Chapter 27::	The dynlink library: dynamic loading and linking of object files
* Chapter 28::	The LablTk library: Tcl/Tk GUI interface
* Chapter 29::	The bigarray library

