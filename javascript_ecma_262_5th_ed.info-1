これは javascript_ecma_262_5th_ed.info、es5.texi より makeinfo
バージョン 4.8 によって作成されました。


File: javascript_ecma_262_5th_ed.info,  Node: Top,  Up: (dir)

ECMAScript Language Specification (ECMA-262 5th Edition)
********************************************************

*This is _not_ the official ECMAScript Language Specification.*

   The official specification is the PDF document located at
http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf
(http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf).

   This HTML version was created from the original PDF version by a
preposterous concatenation of hacks. It very likely contains errors and
the official standard and errata are of course definitive. For
copyright information, see ECMA's legal disclaimer (#ecma-disclaimer)
in the document itself.

   This version was created by Jason Orendorff and incorporates the
official errata
(http://wiki.ecmascript.org/lib/exe/fetch.php?id=es3.1%3Aes3.1_proposal_working_draft&cache=cache&media=resources:es5_errata_7-31-10.pdf)
as of 31 July 2010.

   Last updated: 5 November 2010.

   PDF page 1

* Menu:

* ECMA-262 5th Edition / December 2009 ECMAScript Language Specification::
* Contents::
* Introduction::
* 1 Scope::
* 2 Conformance::
* 3 Normative references::
* 4 Overview::
* 41 Web Scripting::
* 42 Language Overview::
* 421 Objects::
* 422 The Strict Variant of ECMAScript::
* 43 Definitions::
* 431 type::
* 432 primitive value::
* 433 object::
* 434 constructor::
* 435 prototype::
* 436 native object::
* 437 built-in object::
* 438 host object::
* 439 undefined value::
* 4310 Undefined type::
* 4311 null value::
* 4312 Null type::
* 4313 Boolean value::
* 4314 Boolean type::
* 4315 Boolean object::
* 4316 String value::
* 4317 String type::
* 4318 String object::
* 4319 Number value::
* 4320 Number type::
* 4321 Number object::
* 4322 Infinity::
* 4323 NaN::
* 4324 function::
* 4325 built-in function::
* 4326 property::
* 4327 method::
* 4328 built-in method::
* 4329 attribute::
* 4330 own property::
* 4331 inherited property::
* 5 Notational Conventions::
* 51 Syntactic and Lexical Grammars::
* 511 Context-Free Grammars::
* 512 The Lexical and RegExp Grammars::
* 513 The Numeric String Grammar::
* 514 The Syntactic Grammar::
* 515 The JSON Grammar::
* 516 Grammar Notation::
* 52 Algorithm Conventions::
* 6 Source Text::
* 7 Lexical Conventions::
* 71 Unicode Format-Control Characters::
* 72 White Space::
* 73 Line Terminators::
* 74 Comments::
* 75 Tokens::
* 76 Identifier Names and Identifiers::
* 761 Reserved Words::
* 7611 Keywords::
* 7612 Future Reserved Words::
* 77 Punctuators::
* 78 Literals::
* 781 Null Literals::
* 782 Boolean Literals::
* 783 Numeric Literals::
* 784 String Literals::
* 785 Regular Expression Literals::
* 79 Automatic Semicolon Insertion::
* 791 Rules of Automatic Semicolon Insertion::
* 792 Examples of Automatic Semicolon Insertion::
* 8 Types::
* 81 The Undefined Type::
* 82 The Null Type::
* 83 The Boolean Type::
* 84 The String Type::
* 85 The Number Type::
* 86 The Object Type::
* 861 Property Attributes::
* 862 Object Internal Properties and Methods::
* 87 The Reference Specification Type::
* 871 GetValue V::
* 872 PutValue V W::
* 88 The List Specification Type::
* 89 The Completion Specification Type::
* 810 The Property Descriptor and Property Identifier Specification Types::
* 8101 IsAccessorDescriptor  Desc ::
* 8102 IsDataDescriptor  Desc ::
* 8103 IsGenericDescriptor  Desc ::
* 8104 FromPropertyDescriptor  Desc ::
* 8105 ToPropertyDescriptor  Obj ::
* 811 The Lexical Environment and Environment Record Specification Types::
* 812 Algorithms for Object Internal Methods::
* 8121 [[GetOwnProperty]] P::
* 8122 [[GetProperty]] P::
* 8123 [[Get]] P::
* 8124 [[CanPut]] P::
* 8125 [[Put]]  P V Throw ::
* 8126 [[HasProperty]] P::
* 8127 [[Delete]] P Throw::
* 8128 [[DefaultValue]] hint::
* 8129 [[DefineOwnProperty]] P Desc Throw::
* 9 Type Conversion and Testing::
* 91 ToPrimitive::
* 92 ToBoolean::
* 93 ToNumber::
* 931 ToNumber Applied to the String Type::
* 94 ToInteger::
* 95 ToInt32 Signed 32 Bit Integer::
* 96 ToUint32 Unsigned 32 Bit Integer::
* 97 ToUint16 Unsigned 16 Bit Integer::
* 98 ToString::
* 981 ToString Applied to the Number Type::
* 99 ToObject::
* 910 CheckObjectCoercible::
* 911 IsCallable::
* 912 The SameValue Algorithm::
* 10 Executable Code and Execution Contexts::
* 101 Types of Executable Code::
* 1011 Strict Mode Code::
* 102 Lexical Environments::
* 1021 Environment Records::
* 10211 Declarative Environment Records::
* 102111 HasBindingN::
* 102112 CreateMutableBinding N D::
* 102113 SetMutableBindingNVS::
* 102114 GetBindingValueNS::
* 102115 DeleteBinding N::
* 102116 ImplicitThisValue::
* 102117 CreateImmutableBinding N::
* 102118 InitializeImmutableBinding NV::
* 10212 Object Environment Records::
* 102121 HasBindingN::
* 102122 CreateMutableBinding N D::
* 102123 SetMutableBinding NVS::
* 102124 GetBindingValueNS::
* 102125 DeleteBindingN::
* 102126 ImplicitThisValue::
* 1022 Lexical Environment Operations::
* 10221 GetIdentifierReference lex name strict::
* 10222 NewDeclarativeEnvironmentE::
* 10223 NewObjectEnvironment O E::
* 1023 The Global Environment::
* 103 Execution Contexts::
* 1031 Identifier Resolution::
* 104 Establishing an Execution Context::
* 1041 Entering Global Code::
* 10411 Initial Global Execution Context::
* 1042 Entering Eval Code::
* 10421 Strict Mode Restrictions::
* 1043 Entering Function Code::
* 105 Declaration Binding Instantiation::
* 106 Arguments Object::
* 11 Expressions::
* 111 Primary Expressions::
* 1111 The this Keyword::
* 1112 Identifier Reference::
* 1113 Literal Reference::
* 1114 Array Initialiser::
* 1115 Object Initialiser::
* 1116 The Grouping Operator::
* 112 Left-Hand-Side Expressions::
* 1121 Property Accessors::
* 1122 The new Operator::
* 1123 Function Calls::
* 1124 Argument Lists::
* 1125 Function Expressions::
* 113 Postfix Expressions::
* 1131 Postfix Increment Operator::
* 1132 Postfix Decrement Operator::
* 114 Unary Operators::
* 1141 The delete Operator::
* 1142 The void Operator::
* 1143 The typeof Operator::
* 1144 Prefix Increment Operator::
* 1145 Prefix Decrement Operator::
* 1146 Unary + Operator::
* 1147 Unary - Operator::
* 1148 Bitwise NOT Operator  ~ ::
* 1149 Logical NOT Operator  ! ::
* 115 Multiplicative Operators::
* 1151 Applying the * Operator::
* 1152 Applying the / Operator::
* 1153 Applying the % Operator::
* 116 Additive Operators::
* 1161 The Addition operator  + ::
* 1162 The Subtraction Operator  - ::
* 1163 Applying the Additive Operators to Numbers::
* 117 Bitwise Shift Operators::
* 1171 The Left Shift Operator  << ::
* 1172 The Signed Right Shift Operator  >> ::
* 1173 The Unsigned Right Shift Operator  >>> ::
* 118 Relational Operators::
* 1181 The Less-than Operator  < ::
* 1182 The Greater-than Operator  > ::
* 1183 The Less-than-or-equal Operator  <= ::
* 1184 The Greater-than-or-equal Operator  >= ::
* 1185 The Abstract Relational Comparison Algorithm::
* 1186 The instanceof operator::
* 1187 The in operator::
* 119 Equality Operators::
* 1191 The Equals Operator  == ::
* 1192 The Does-not-equals Operator  != ::
* 1193 The Abstract Equality Comparison Algorithm::
* 1194 The Strict Equals Operator  === ::
* 1195 The Strict Does-not-equal Operator  !== ::
* 1196 The Strict Equality Comparison Algorithm::
* 1110 Binary Bitwise Operators::
* 1111 Binary Logical Operators::
* 1112 Conditional Operator  ?  ::
* 1113 Assignment Operators::
* 11131 Simple Assignment  = ::
* 11132 Compound Assignment  <var>op</var>= ::
* 1114 Comma Operator   ::
* 12 Statements::
* 121 Block::
* 122 Variable Statement::
* 1221 Strict Mode Restrictions::
* 123 Empty Statement::
* 124 Expression Statement::
* 125 The if Statement::
* 126 Iteration Statements::
* 1261 The do–while Statement::
* 1262 The while Statement::
* 1263 The for Statement::
* 1264 The for–in Statement::
* 127 The continue Statement::
* 128 The break Statement::
* 129 The return Statement::
* 1210 The with Statement::
* 12101 Strict Mode Restrictions::
* 1211 The switch Statement::
* 1212 Labelled Statements::
* 1213 The throw Statement::
* 1214 The try Statement::
* 12141 Strict Mode Restrictions::
* 1215 The debugger statement::
* 13 Function Definition::
* 131 Strict Mode Restrictions::
* 132 Creating Function Objects::
* 1321 [[Call]]::
* 1322 [[Construct]]::
* 1323 The [[ThrowTypeError]] Function Object::
* 14 Program::
* 141 Directive Prologues and the Use Strict Directive::
* 15 Standard Built-in ECMAScript Objects::
* 151 The Global Object::
* 1511 Value Properties of the Global Object::
* 15111 NaN::
* 15112 Infinity::
* 15113 undefined::
* 1512 Function Properties of the Global Object::
* 15121 eval x::
* 151211 Direct Call to Eval::
* 15122 parseInt string  radix::
* 15123 parseFloatstring::
* 15124 isNaN number::
* 15125 isFinitenumber::
* 1513 URI Handling Function Properties::
* 15131 decodeURI encodedURI::
* 15132 decodeURIComponent encodedURIComponent::
* 15133 encodeURI uri::
* 15134 encodeURIComponent uriComponent::
* 1514 Constructor Properties of the Global Object::
* 15141 Object     ::
* 15142 Function     ::
* 15143 Array     ::
* 15144 String     ::
* 15145 Boolean     ::
* 15146 Number     ::
* 15147 Date     ::
* 15148 RegExp     ::
* 15149 Error     ::
* 151410 EvalError     ::
* 151411 RangeError     ::
* 151412 ReferenceError     ::
* 151413 SyntaxError     ::
* 151414 TypeError     ::
* 151415 URIError     ::
* 1515 Other Properties of the Global Object::
* 15151 Math::
* 15152 JSON::
* 152 Object Objects::
* 1521 The Object Constructor Called as a Function::
* 15211 Object  [ value ] ::
* 1522 The Object Constructor::
* 15221 new Object  [ value ] ::
* 1523 Properties of the Object Constructor::
* 15231 Objectprototype::
* 15232 ObjectgetPrototypeOf  O ::
* 15233 ObjectgetOwnPropertyDescriptor  O P ::
* 15234 ObjectgetOwnPropertyNames  O ::
* 15235 Objectcreate  O [ Properties] ::
* 15236 ObjectdefineProperty  O P Attributes ::
* 15237 ObjectdefineProperties  O Properties ::
* 15238 Objectseal  O ::
* 15239 Objectfreeze  O ::
* 152310 ObjectpreventExtensions  O ::
* 152311 ObjectisSealed  O ::
* 152312 ObjectisFrozen  O ::
* 152313 ObjectisExtensible  O ::
* 152314 Objectkeys  O ::
* 1524 Properties of the Object Prototype Object::
* 15241 Objectprototypeconstructor::
* 15242 ObjectprototypetoString  ::
* 15243 ObjectprototypetoLocaleString  ::
* 15244 ObjectprototypevalueOf  ::
* 15245 ObjectprototypehasOwnProperty V::
* 15246 ObjectprototypeisPrototypeOf V::
* 15247 ObjectprototypepropertyIsEnumerable V::
* 1525 Properties of Object Instances::
* 153 Function Objects::
* 1531 The Function Constructor Called as a Function::
* 15311 Function p1 p2   pn body::
* 1532 The Function Constructor::
* 15321 new Function p1 p2   pn body::
* 1533 Properties of the Function Constructor::
* 15331 Functionprototype::
* 15332 Functionlength::
* 1534 Properties of the Function Prototype Object::
* 15341 Functionprototypeconstructor::
* 15342 FunctionprototypetoString  ::
* 15343 Functionprototypeapply thisArg argArray::
* 15344 Functionprototypecall thisArg [  arg1 [  arg2  ] ] ::
* 15345 Functionprototypebind thisArg [ arg1 [ arg2 ]]::
* 153451 [[Call]]::
* 153452 [[Construct]]::
* 153453 [[HasInstance]] V::
* 1535 Properties of Function Instances::
* 15351 length::
* 15352 prototype::
* 15353 [[HasInstance]] V::
* 15354 [[Get]] P::
* 154 Array Objects::
* 1541 The Array Constructor Called as a Function::
* 15411 Array  [ item1 [  item2 [   ] ] ] ::
* 1542 The Array Constructor::
* 15421 new Array  [ item0 [  item1 [   ] ] ] ::
* 15422 new Array len::
* 1543 Properties of the Array Constructor::
* 15431 Arrayprototype::
* 15432 ArrayisArray  arg ::
* 1544 Properties of the Array Prototype Object::
* 15441 Arrayprototypeconstructor::
* 15442 ArrayprototypetoString  ::
* 15443 ArrayprototypetoLocaleString  ::
* 15444 Arrayprototypeconcat  [ item1 [  item2 [   ] ] ] ::
* 15445 Arrayprototypejoin separator::
* 15446 Arrayprototypepop  ::
* 15447 Arrayprototypepush  [ item1 [  item2 [   ] ] ] ::
* 15448 Arrayprototypereverse  ::
* 15449 Arrayprototypeshift  ::
* 154410 Arrayprototypeslice start end::
* 154411 Arrayprototypesort comparefn::
* 154412 Arrayprototypesplice start deleteCount [  item1 [  item2 [   ] ] ] ::
* 154413 Arrayprototypeunshift  [ item1 [  item2 [   ] ] ] ::
* 154414 ArrayprototypeindexOf  searchElement [  fromIndex ] ::
* 154415 ArrayprototypelastIndexOf  searchElement [  fromIndex ] ::
* 154416 Arrayprototypeevery  callbackfn [  thisArg ] ::
* 154417 Arrayprototypesome  callbackfn [  thisArg ] ::
* 154418 ArrayprototypeforEach  callbackfn [  thisArg ] ::
* 154419 Arrayprototypemap  callbackfn [  thisArg ] ::
* 154420 Arrayprototypefilter  callbackfn [  thisArg ] ::
* 154421 Arrayprototypereduce  callbackfn [  initialValue ] ::
* 154422 ArrayprototypereduceRight  callbackfn [  initialValue ] ::
* 1545 Properties of Array Instances::
* 15451 [[DefineOwnProperty]]  P Desc Throw ::
* 15452 length::
* 155 String Objects::
* 1551 The String Constructor Called as a Function::
* 15511 String  [ value ] ::
* 1552 The String Constructor::
* 15521 new String  [ value ] ::
* 1553 Properties of the String Constructor::
* 15531 Stringprototype::
* 15532 StringfromCharCode  [ char0 [  char1 [   ] ] ] ::
* 1554 Properties of the String Prototype Object::
* 15541 Stringprototypeconstructor::
* 15542 StringprototypetoString  ::
* 15543 StringprototypevalueOf  ::
* 15544 StringprototypecharAt pos::
* 15545 StringprototypecharCodeAt pos::
* 15546 Stringprototypeconcat  [ string1 [  string2 [   ] ] ] ::
* 15547 StringprototypeindexOf searchString position::
* 15548 StringprototypelastIndexOf searchString position::
* 15549 StringprototypelocaleCompare that::
* 155410 Stringprototypematch regexp::
* 155411 Stringprototypereplace searchValue replaceValue::
* 155412 Stringprototypesearch regexp::
* 155413 Stringprototypeslice start end::
* 155414 Stringprototypesplit separator limit::
* 155415 Stringprototypesubstring start end::
* 155416 StringprototypetoLowerCase  ::
* 155417 StringprototypetoLocaleLowerCase  ::
* 155418 StringprototypetoUpperCase  ::
* 155419 StringprototypetoLocaleUpperCase  ::
* 155420 Stringprototypetrim  ::
* 1555 Properties of String Instances::
* 15551 length::
* 15552 [[GetOwnProperty]]  P ::
* 156 Boolean Objects::
* 1561 The Boolean Constructor Called as a Function::
* 15611 Boolean value::
* 1562 The Boolean Constructor::
* 15621 new Boolean value::
* 1563 Properties of the Boolean Constructor::
* 15631 Booleanprototype::
* 1564 Properties of the Boolean Prototype Object::
* 15641 Booleanprototypeconstructor::
* 15642 BooleanprototypetoString  ::
* 15643 BooleanprototypevalueOf  ::
* 1565 Properties of Boolean Instances::
* 157 Number Objects::
* 1571 The Number Constructor Called as a Function::
* 15711 Number  [ value ] ::
* 1572 The Number Constructor::
* 15721 new Number  [ value ] ::
* 1573 Properties of the Number Constructor::
* 15731 Numberprototype::
* 15732 NumberMAX_VALUE::
* 15733 NumberMIN_VALUE::
* 15734 NumberNaN::
* 15735 NumberNEGATIVE_INFINITY::
* 15736 NumberPOSITIVE_INFINITY::
* 1574 Properties of the Number Prototype Object::
* 15741 Numberprototypeconstructor::
* 15742 NumberprototypetoString  [ radix ] ::
* 15743 NumberprototypetoLocaleString::
* 15744 NumberprototypevalueOf  ::
* 15745 NumberprototypetoFixed fractionDigits::
* 15746 NumberprototypetoExponential fractionDigits::
* 15747 NumberprototypetoPrecision precision::
* 1575 Properties of Number Instances::
* 158 The Math Object::
* 1581 Value Properties of the Math Object::
* 15811 E::
* 15812 LN10::
* 15813 LN2::
* 15814 LOG2E::
* 15815 LOG10E::
* 15816 PI::
* 15817 SQRT1_2::
* 15818 SQRT2::
* 1582 Function Properties of the Math Object::
* 15821 abs x::
* 15822 acos x::
* 15823 asin x::
* 15824 atan x::
* 15825 atan2 y x::
* 15826 ceil x::
* 15827 cosx::
* 15828 expx::
* 15829 floor x::
* 158210 log x::
* 158211 max  [ value1 [  value2 [   ] ] ] ::
* 158212 min  [ value1 [  value2 [   ] ] ] ::
* 158213 pow x y::
* 158214 random  ::
* 158215 round x::
* 158216 sin x::
* 158217 sqrt x::
* 158218 tan x::
* 159 Date Objects::
* 1591 Overview of Date Objects and Definitions of Abstract Operators::
* 15911 Time Values and Time Range::
* 15912 Day Number and Time within Day::
* 15913 Year Number::
* 15914 Month Number::
* 15915 Date Number::
* 15916 Week Day::
* 15917 Local Time Zone Adjustment::
* 15918 Daylight Saving Time Adjustment::
* 15919 Local Time::
* 159110 Hours Minutes Second and Milliseconds::
* 159111 MakeTime hour min sec ms::
* 159112 MakeDay year month date::
* 159113 MakeDate day time::
* 159114 TimeClip time::
* 159115 Date Time String Format::
* 1591151 Extended years::
* 1592 The Date Constructor Called as a Function::
* 15921 Date  [ year [ month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ] ] ::
* 1593 The Date Constructor::
* 15931 new Date year month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ::
* 15932 new Date value::
* 15933 new Date  ::
* 1594 Properties of the Date Constructor::
* 15941 Dateprototype::
* 15942 Dateparse string::
* 15943 DateUTC year month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ::
* 15944 Datenow  ::
* 1595 Properties of the Date Prototype Object::
* 15951 Dateprototypeconstructor::
* 15952 DateprototypetoString  ::
* 15953 DateprototypetoDateString  ::
* 15954 DateprototypetoTimeString  ::
* 15955 DateprototypetoLocaleString  ::
* 15956 DateprototypetoLocaleDateString  ::
* 15957 DateprototypetoLocaleTimeString  ::
* 15958 DateprototypevalueOf  ::
* 15959 DateprototypegetTime  ::
* 159510 DateprototypegetFullYear  ::
* 159511 DateprototypegetUTCFullYear  ::
* 159512 DateprototypegetMonth  ::
* 159513 DateprototypegetUTCMonth  ::
* 159514 DateprototypegetDate  ::
* 159515 DateprototypegetUTCDate  ::
* 159516 DateprototypegetDay  ::
* 159517 DateprototypegetUTCDay  ::
* 159518 DateprototypegetHours  ::
* 159519 DateprototypegetUTCHours  ::
* 159520 DateprototypegetMinutes  ::
* 159521 DateprototypegetUTCMinutes  ::
* 159522 DateprototypegetSeconds  ::
* 159523 DateprototypegetUTCSeconds  ::
* 159524 DateprototypegetMilliseconds  ::
* 159525 DateprototypegetUTCMilliseconds  ::
* 159526 DateprototypegetTimezoneOffset  ::
* 159527 DateprototypesetTime time::
* 159528 DateprototypesetMilliseconds ms::
* 159529 DateprototypesetUTCMilliseconds ms::
* 159530 DateprototypesetSeconds sec [ ms ] ::
* 159531 DateprototypesetUTCSeconds sec [ ms ] ::
* 159532 DateprototypesetMinutes min [ sec [ ms ] ] ::
* 159533 DateprototypesetUTCMinutes min [ sec [ ms ] ] ::
* 159534 DateprototypesetHours hour [ min [ sec [ ms ] ] ] ::
* 159535 DateprototypesetUTCHours hour [ min [ sec [ ms ] ] ] ::
* 159536 DateprototypesetDate date::
* 159537 DateprototypesetUTCDate date::
* 159538 DateprototypesetMonth month [ date ] ::
* 159539 DateprototypesetUTCMonth month [ date ] ::
* 159540 DateprototypesetFullYear year [ month [ date ] ] ::
* 159541 DateprototypesetUTCFullYear year [ month [ date ] ] ::
* 159542 DateprototypetoUTCString  ::
* 159543 DateprototypetoISOString  ::
* 159544 DateprototypetoJSON  key ::
* 1596 Properties of Date Instances::
* 1510 RegExp Regular Expression Objects::
* 15101 Patterns::
* 15102 Pattern Semantics::
* 151021 Notation::
* 151022 Pattern::
* 151023 Disjunction::
* 151024 Alternative::
* 151025 Term::
* 151026 Assertion::
* 151027 Quantifier::
* 151028 Atom::
* 151029 AtomEscape::
* 1510210 CharacterEscape::
* 1510211 DecimalEscape::
* 1510212 CharacterClassEscape::
* 1510213 CharacterClass::
* 1510214 ClassRanges::
* 1510215 NonemptyClassRanges::
* 1510216 NonemptyClassRangesNoDash::
* 1510217 ClassAtom::
* 1510218 ClassAtomNoDash::
* 1510219 ClassEscape::
* 15103 The RegExp Constructor Called as a Function::
* 151031 RegExppattern flags::
* 15104 The RegExp Constructor::
* 151041 new RegExppattern flags::
* 15105 Properties of the RegExp Constructor::
* 151051 RegExpprototype::
* 15106 Properties of the RegExp Prototype Object::
* 151061 RegExpprototypeconstructor::
* 151062 RegExpprototypeexecstring::
* 151063 RegExpprototypeteststring::
* 151064 RegExpprototypetoString::
* 15107 Properties of RegExp Instances::
* 151071 source::
* 151072 global::
* 151073 ignoreCase::
* 151074 multiline::
* 151075 lastIndex::
* 1511 Error Objects::
* 15111 The Error Constructor Called as a Function::
* 151111 Error message::
* 15112 The Error Constructor::
* 151121 new Error message::
* 15113 Properties of the Error Constructor::
* 151131 Errorprototype::
* 15114 Properties of the Error Prototype Object::
* 151141 Errorprototypeconstructor::
* 151142 Errorprototypename::
* 151143 Errorprototypemessage::
* 151144 ErrorprototypetoString  ::
* 15115 Properties of Error Instances::
* 15116 Native Error Types Used in This Standard::
* 151161 EvalError::
* 151162 RangeError::
* 151163 ReferenceError::
* 151164 SyntaxError::
* 151165 TypeError::
* 151166 URIError::
* 15117 NativeError Object Structure::
* 151171 NativeError Constructors Called as Functions::
* 151172 NativeError message::
* 151173 The NativeError Constructors::
* 151174 New NativeError message::
* 151175 Properties of the NativeError Constructors::
* 151176 NativeErrorprototype::
* 151177 Properties of the NativeError Prototype Objects::
* 151178 NativeErrorprototypeconstructor::
* 151179 NativeErrorprototypename::
* 1511710 NativeErrorprototypemessage::
* 1511711 Properties of NativeError Instances::
* 1512 The JSON Object::
* 15121 The JSON Grammar::
* 151211 The JSON Lexical Grammar::
* 151212 The JSON Syntactic Grammar::
* 15122 parse  text [  reviver ] ::
* 15123 stringify  value [  replacer [  space ] ] ::
* 16 Errors::
* Annex A informative Grammar Summary::
* A1 Lexical Grammar::
* A2 Number Conversions::
* A3 Expressions::
* A4 Statements::
* A5 Functions and Programs::
* A6 Universal Resource Identifier Character Classes::
* A7 Regular Expressions::
* A8 JSON::
* A81 JSON Lexical Grammar::
* A82 JSON Syntactic Grammar::
* Annex B informative Compatibility::
* B1 Additional Syntax::
* B11 Numeric Literals::
* B12 String Literals::
* B2 Additional Properties::
* B21 escape string::
* B22 unescape string::
* B23 Stringprototypesubstr start length::
* B24 DateprototypegetYear  ::
* B25 DateprototypesetYear year::
* B26 DateprototypetoGMTString  ::
* Annex C informative The Strict Mode of ECMAScript::
* Annex D informative Corrections and Clarifications in the 5th Edition with Possible 3rd Edition Compatibility Impact::
* Annex E informative Additions and Changes in the 5th Edition that Introduce Incompatibilities with the 3rd Edition::
* Bibliography::


File: javascript_ecma_262_5th_ed.info,  Node: ECMA-262 5th Edition / December 2009 ECMAScript Language Specification,  Next: Contents,  Prev: Top,  Up: Top

1 ECMA-262 5th Edition / December 2009 ECMAScript Language Specification
************************************************************************

Reference number ECMA-123:2009

   COPYRIGHT PROTECTED DOCUMENT © Ecma International 2009


File: javascript_ecma_262_5th_ed.info,  Node: Contents,  Next: Introduction,  Prev: ECMA-262 5th Edition / December 2009 ECMAScript Language Specification,  Up: Top

2 Contents
**********

  1. Introduction (#introduction)

  2. 1 Scope (#sec-1)

  3. 2 Conformance (#sec-2)

  4. 3 Normative references (#sec-3)

  5. 4 Overview (#sec-4)

  6. 5 Notational Conventions (#sec-5)

  7. 6 Source Text (#sec-6)

  8. 7 Lexical Conventions (#sec-7)

  9. 8 Types (#sec-8)

 10. 9 Type Conversion and Testing (#sec-9)

 11. 10 Executable Code and Execution Contexts (#sec-10)

 12. 11 Expressions (#sec-11)

 13. 12 Statements (#sec-12)

 14. 13 Function Definition (#sec-13)

 15. 14 Program (#sec-14)

 16. 15 Standard Built-in ECMAScript Objects (#sec-15)

 17. 16 Errors (#sec-16)

 18. Annex A (informative) Grammar Summary (#sec-A)

 19. Annex B (informative) Compatibility (#sec-B)

 20. Annex C (informative) The Strict Mode of ECMAScript (#sec-C)

 21. Annex D (informative) Corrections and Clarifications in the 5th
     Edition with Possible 3rd Edition Compatibility Impact (#sec-D)

 22. Annex E (informative) Additions and Changes in the 5th Edition
     that Introduce Incompatibilities with the 3rd Edition (#sec-E)

 23. Bibliography (#bibliography)


File: javascript_ecma_262_5th_ed.info,  Node: Introduction,  Next: 1 Scope,  Prev: Contents,  Up: Top

3 Introduction
**************

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft).
The language was invented by Brendan Eich at Netscape and first
appeared in that company’s Navigator 2.0 browser. It has appeared in
all subsequent browsers from Netscape and in all browsers from
Microsoft starting with Internet Explorer 3.0.

   The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

   That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under
the fast-track procedure, and approved as international standard
ISO/IEC 16262, in April 1998. The Ecma General Assembly of June 1998
approved the second edition of ECMA-262 to keep it fully aligned with
ISO/IEC 16262. Changes between the first and the second edition are
editorial in nature.

   The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for
numeric output and minor changes in anticipation of forthcoming
internationalisation facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

   Since publication of the third edition, ECMAScript has achieved
massive adoption in conjunction with the World Wide Web where it has
become the programming language that is supported by essentially all
web browsers. Significant work was done to develop a fourth edition of
ECMAScript. Although that work was not completed and not published[1
(#footnote1)] as the fourth edition of ECMAScript, it informs
continuing evolution of the language. The present fifth edition of
ECMAScript (published as ECMA-262 5th edition) codifies de facto
interpretations of the language specification that have become common
among browser implementations and adds support for new features that
have emerged since the publication of the third edition. Such features
include accessor properties, reflective creation and inspection of
objects, program control of property attributes, additional array
manipulation functions, support for the JSON (#sec-15.12) object
encoding format, and a strict mode that provides enhanced error
checking and program security.

   ECMAScript is a vibrant language and the evolution of the language
is not complete. Significant technical enhancement will continue with
future editions of this specification.

   This Ecma Standard has been adopted by the General Assembly of
December 2009.

   [1]Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.

   "DISCLAIMER

   This document and possible translations of it may be copied and
furnished to others, and derivative works that comment on or otherwise
explain it or assist in its implementation may be prepared, copied,
published, and distributed, in whole or in part, without restriction of
any kind, provided that the above copyright notice and this section are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, including by removing
the copyright notice or references to Ecma International, except as
needed for the purpose of developing any document or deliverable
produced by Ecma International (in which case the rules applied to
copyrights must be followed) or as required to translate it into
languages other than English.

   The limited permissions granted above are perpetual and will not be
revoked by Ecma International or its successors or assigns.

   This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."


File: javascript_ecma_262_5th_ed.info,  Node: 1 Scope,  Next: 2 Conformance,  Prev: Introduction,  Up: Top

4 1 (#sec-1) Scope
******************

This Standard defines the ECMAScript scripting language.


File: javascript_ecma_262_5th_ed.info,  Node: 2 Conformance,  Next: 3 Normative references,  Prev: 1 Scope,  Up: Top

5 2 (#sec-2) Conformance
************************

A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

   A conforming implementation of this International standard shall
interpret characters in conformance with the Unicode Standard, Version
3.0 or later and ISO/IEC 10646-1 with either UCS-2 or UTF-16 as the
adopted encoding form, implementation level 3. If the adopted ISO/IEC
10646-1 subset is not otherwise specified, it is presumed to be the BMP
subset, collection 300. If the adopted encoding form is not otherwise
specified, it presumed to be the UTF-16 encoding form.

   A conforming implementation of ECMAScript is permitted to provide
additional types, values, objects, properties, and functions beyond
those described in this specification. In particular, a conforming
implementation of ECMAScript is permitted to provide properties not
described in this specification, and values for those properties, for
objects that are described in this specification.

   A conforming implementation of ECMAScript is permitted to support
program and regular expression syntax not described in this
specification. In particular, a conforming implementation of ECMAScript
is permitted to support program syntax that makes use of the “future
reserved words” listed in 7.6.1.2 (#sec-7.6.1.2) of this
specification.


File: javascript_ecma_262_5th_ed.info,  Node: 3 Normative references,  Next: 4 Overview,  Prev: 2 Conformance,  Up: Top

6 3 (#sec-3) Normative references
*********************************

The following referenced documents are indispensable for the
application of this document. For dated references, only the edition
cited applies. For undated references, the latest edition of the
referenced document (including any amendments) applies.

   ISO/IEC 9899:1996, Programming Languages – C, including amendment
1 and technical corrigenda 1 and 2

   ISO/IEC 10646-1:1993, Information Technology – Universal
Multiple-Octet Coded Character Set (UCS) plus its amendments and
corrigenda


File: javascript_ecma_262_5th_ed.info,  Node: 4 Overview,  Next: 41 Web Scripting,  Prev: 3 Normative references,  Up: Top

7 4 (#sec-4) Overview
*********************

This section contains a non-normative overview of the ECMAScript
language.

   ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in
this specification for input of external data or output of computed
results. Instead, it is expected that the computational environment of
an ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific host objects, whose description and behaviour are
beyond the scope of this specification except to indicate that they may
provide certain properties that can be accessed and certain functions
that can be called from an ECMAScript program.

   ECMAScript was originally designed to be a _Web scripting language_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript can provide core scripting capabilities for a variety of
host environments, and therefore the core scripting language is
specified in this document apart from any particular host environment.

   Some of the facilities of ECMAScript are similar to those used in
other programming languages; in particular Java™, Self, and Scheme as
described in:

   Gosling, James, Bill Joy and Guy Steele. The Java™ Language
Specification. Addison Wesley Publishing Co., 1996.

   Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA ’87 Conference Proceedings, pp. 227-241, Orlando, FL, October
1987.

   IEEE Standard for the Scheme Programming Language. IEEE Std
1178-1990.


File: javascript_ecma_262_5th_ed.info,  Node: 41 Web Scripting,  Next: 42 Language Overview,  Prev: 4 Overview,  Up: Top

8 4.1 (#sec-4.1) Web Scripting
******************************

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

   A web server provides a different host environment for server-side
computation including objects representing requests, clients, and
files; and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute
computation between the client and server while providing a customised
user interface for a Web-based application.

   Each Web browser and server that supports ECMAScript supplies its
own host environment, completing the ECMAScript execution environment.


File: javascript_ecma_262_5th_ed.info,  Node: 42 Language Overview,  Next: 421 Objects,  Prev: 41 Web Scripting,  Up: Top

9 4.2 (#sec-4.2) Language Overview
**********************************

The following is an informal overview of ECMAScript—not all parts of
the language are described. This overview is not part of the standard
proper.

   ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. An ECMAScript _object_ is a collection of
_properties_ each with zero or more _attributes_ that determine how
each property can be used—for example, when the Writable attribute
for a property is set to false, any attempt by executed ECMAScript code
to change the value of the property fails. Properties are containers
that hold other objects, _primitive values_, or _functions_. A
primitive value is a member of one of the following built-in types:
*Undefined*, *Null*, *Boolean*, *Number*, and *String*; an object is a
member of the remaining built-in type *Object*; and a function is a
callable object. A function that is associated with an object via a
property is a _method_.

   ECMAScript defines a collection of _built-in objects_ that round out
the definition of ECMAScript entities. These built-in objects include
the global (#sec-15.1) object, the Object (#sec-15.2) object, the
Function (#sec-15.3) object, the Array (#sec-15.4) object, the String
(#sec-15.5) object, the Boolean (#sec-15.6) object, the Number
(#sec-15.7) object, the Math (#sec-15.8) object, the Date (#sec-15.9)
object, the RegExp (#sec-15.10) object, the

   ECMAScript also defines a set of built-in _operators_. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

   ECMAScript syntax intentionally resembles Java syntax. ECMAScript
syntax is relaxed to enable it to serve as an easy-to-use scripting
language. For example, a variable is not required to have its type
declared nor are types associated with properties, and defined
functions are not required to have their declarations appear textually
before calls to them.


File: javascript_ecma_262_5th_ed.info,  Node: 421 Objects,  Next: 422 The Strict Variant of ECMAScript,  Prev: 42 Language Overview,  Up: Top

10 4.2.1 (#sec-4.2.1) Objects
*****************************

ECMAScript does not use classes such as those in C++, Smalltalk, or
Java. Instead objects may be created in various ways including via a
literal notation or via _constructors_ which create objects and then
execute code that initialises all or part of them by assigning initial
values to their properties. Each constructor is a function that has a
property named “`prototype'” that is used to implement
_prototype-based inheritance_ and _shared properties_. Objects are
created by using constructors in `new' expressions; for example, `new
Date(2009,11)' creates a new Date object. Invoking a constructor
without using `new' has consequences that depend on the constructor.
For example, `Date()' produces a string representation of the current
date and time rather than an object.

   Every object created by a constructor has an implicit reference
(called the object’s prototype) to the value of its constructor’s
“`prototype'” property. Furthermore, a prototype may have a
non-null implicit reference to its prototype, and so on; this is called
the prototype chain. When a reference is made to a property in an
object, that reference is to the property of that name in the first
object in the prototype chain that contains a property of that name. In
other words, first the object mentioned directly is examined for such a
property; if that object contains the named property, that is the
property to which the reference refers; if that object does not contain
the named property, the prototype for that object is examined next; and
so on.

 [image src="figure-1.png" alt="An image of lots of boxes and arrows." ]
Figure 1 — Object/Prototype Relationships In a class-based
object-oriented language, in general, state is carried by instances,
methods are carried by classes, and inheritance is only of structure
and behaviour. In ECMAScript, the state and methods are carried by
objects, and structure, behaviour, and state are all inherited.

   *CF* is a constructor (and also an object). Five objects have been
created by using `new' expressions: *cf_1_*, *cf_2_*, *cf_3_*, *cf_4_*,
and *cf_5_*. Each of these objects contains properties named `q1' and
`q2'. The dashed lines represent the implicit prototype relationship;
so, for example, *cf_3_*’s prototype is *CF_p_*. The constructor,
*CF*, has two properties itself, named `P1' and `P2', which are not
visible to *CF_p_*, *cf_1_*, *cf_2_*, *cf_3_*, *cf_4_*, or *cf_5_*. The
property named `CFP1' in *CF_p_* is shared by *cf_1_*, *cf_2_*,
*cf_3_*, *cf_4_*, and *cf_5_* (but not by *CF*), as are any properties
found in *CF_p_*’s implicit prototype chain that are not named `q1',
`q2', or `CFP1'. Notice that there is no implicit prototype link
between *CF* and *CF_p_*.

   Unlike class-based object languages, properties can be added to
objects dynamically by assigning values to them. That is, constructors
are not required to name or assign values to all or any of the
constructed object’s properties. In the above diagram, one could add
a new shared property for *cf_1_*, *cf_2_*, *cf_3_*, *cf_4_*, and
*cf_5_* by assigning a new value to the property in *CF_p_*.


File: javascript_ecma_262_5th_ed.info,  Node: 422 The Strict Variant of ECMAScript,  Next: 43 Definitions,  Prev: 421 Objects,  Up: Top

11 4.2.2 (#sec-4.2.2) The Strict Variant of ECMAScript
******************************************************

The ECMAScript Language recognizes the possibility that some users of
the language may wish to restrict their usage of some features
available in the language. They might do so in the interests of
security, to avoid what they consider to be error-prone features, to
get enhanced error checking, or for other reasons of their choosing. In
support of this possibility, ECMAScript defines a strict variant of the
language. The strict variant of the language excludes some specific
syntactic and semantic features of the regular ECMAScript language and
modifies the detailed semantics of some features. The strict variant
also specifies additional error conditions that must be reported by
throwing error exceptions in situations that are not specified as
errors by the non-strict form of the language.

   The strict variant of ECMAScript is commonly referred to as the
strict mode of the language. Strict mode selection and use of the
strict mode syntax and semantics of ECMAScript is explicitly made at
the level of individual ECMAScript code units. Because strict mode is
selected at the level of a syntactic code unit, strict mode only
imposes restrictions that have local effect within such a code unit.
Strict mode does not restrict or modify any aspect of the ECMAScript
semantics that must operate consistently across multiple code units. A
complete ECMAScript program may be composed for both strict mode and
non-strict mode ECMAScript code units. In this case, strict mode only
applies when actually executing code that is defined within a strict
mode code (#sec-10.1.1) unit.

   In order to conform to this specification, an ECMAScript
implementation must implement both the full unrestricted ECMAScript
language and the strict mode variant of the ECMAScript language as
defined by this specification. In addition, an implementation must
support the combination of unrestricted and strict mode code
(#sec-10.1.1) units into a single composite program.


File: javascript_ecma_262_5th_ed.info,  Node: 43 Definitions,  Next: 431 type,  Prev: 422 The Strict Variant of ECMAScript,  Up: Top

12 4.3 (#sec-4.3) Definitions
*****************************

For the purposes of this document, the following terms and definitions
apply.


File: javascript_ecma_262_5th_ed.info,  Node: 431 type,  Next: 432 primitive value,  Prev: 43 Definitions,  Up: Top

13 4.3.1 (#sec-4.3.1) type
**************************

set of data values as defined in Clause 8 (#sec-8) of this
specification.


File: javascript_ecma_262_5th_ed.info,  Node: 432 primitive value,  Next: 433 object,  Prev: 431 type,  Up: Top

14 4.3.2 (#sec-4.3.2) primitive value
*************************************

member of one of the types Undefined, Null, Boolean, Number, or String
as defined in Clause 8 (#sec-8).

   NOTE A primitive value is a datum that is represented directly at
the lowest level of the language implementation.


File: javascript_ecma_262_5th_ed.info,  Node: 433 object,  Next: 434 constructor,  Prev: 432 primitive value,  Up: Top

15 4.3.3 (#sec-4.3.3) object
****************************

member of the type Object.

   NOTE An object is a collection of properties and has a single
prototype object. The prototype may be the null value.


File: javascript_ecma_262_5th_ed.info,  Node: 434 constructor,  Next: 435 prototype,  Prev: 433 object,  Up: Top

16 4.3.4 (#sec-4.3.4) constructor
*********************************

Function object that creates and initialises objects.

   NOTE The value of a constructor’s “`prototype'” property is a
prototype object that is used to implement inheritance and shared
properties.


File: javascript_ecma_262_5th_ed.info,  Node: 435 prototype,  Next: 436 native object,  Prev: 434 constructor,  Up: Top

17 4.3.5 (#sec-4.3.5) prototype
*******************************

object that provides shared properties for other objects.

   NOTE When a constructor creates an object, that object implicitly
references the constructor’s “`prototype'” property for the
purpose of resolving property references. The constructor’s
“`prototype'” property can be referenced by the program expression
`<var>constructor</var>.prototype', and properties added to an
object’s prototype are shared, through inheritance, by all objects
sharing the prototype. Alternatively, a new object may be created with
an explicitly specified prototype by using the Object.create
(#sec-15.2.3.5) built-in function.


File: javascript_ecma_262_5th_ed.info,  Node: 436 native object,  Next: 437 built-in object,  Prev: 435 prototype,  Up: Top

18 4.3.6 (#sec-4.3.6) native object
***********************************

object in an ECMAScript implementation whose semantics are fully
defined by this specification rather than by the host environment.

   NOTE Standard native objects are defined in this specification. Some
native objects are built-in; others may be constructed during the
course of execution of an ECMAScript program.


File: javascript_ecma_262_5th_ed.info,  Node: 437 built-in object,  Next: 438 host object,  Prev: 436 native object,  Up: Top

19 4.3.7 (#sec-4.3.7) built-in object
*************************************

object supplied by an ECMAScript implementation, independent of the
host environment, that is present at the start of the execution of an
ECMAScript program.

   NOTE Standard built-in objects are defined in this specification,
and an ECMAScript implementation may specify and define others. Every
built-in object is a native object. A built-in constructor is a
built-in object that is also a constructor.


File: javascript_ecma_262_5th_ed.info,  Node: 438 host object,  Next: 439 undefined value,  Prev: 437 built-in object,  Up: Top

20 4.3.8 (#sec-4.3.8) host object
*********************************

object supplied by the host environment to complete the execution
environment of ECMAScript.

   NOTE Any object that is not native is a host object.


File: javascript_ecma_262_5th_ed.info,  Node: 439 undefined value,  Next: 4310 Undefined type,  Prev: 438 host object,  Up: Top

21 4.3.9 (#sec-4.3.9) undefined value
*************************************

primitive value used when a variable has not been assigned a value.


File: javascript_ecma_262_5th_ed.info,  Node: 4310 Undefined type,  Next: 4311 null value,  Prev: 439 undefined value,  Up: Top

22 4.3.10 (#sec-4.3.10) Undefined type
**************************************

type whose sole value is the undefined value.


File: javascript_ecma_262_5th_ed.info,  Node: 4311 null value,  Next: 4312 Null type,  Prev: 4310 Undefined type,  Up: Top

23 4.3.11 (#sec-4.3.11) null value
**********************************

primitive value that represents the intentional absence of any object
value.


File: javascript_ecma_262_5th_ed.info,  Node: 4312 Null type,  Next: 4313 Boolean value,  Prev: 4311 null value,  Up: Top

24 4.3.12 (#sec-4.3.12) Null type
*********************************

type whose sole value is the null value.


File: javascript_ecma_262_5th_ed.info,  Node: 4313 Boolean value,  Next: 4314 Boolean type,  Prev: 4312 Null type,  Up: Top

25 4.3.13 (#sec-4.3.13) Boolean value
*************************************

member of the Boolean type.

   NOTE There are only two Boolean values, true and false.


File: javascript_ecma_262_5th_ed.info,  Node: 4314 Boolean type,  Next: 4315 Boolean object,  Prev: 4313 Boolean value,  Up: Top

26 4.3.14 (#sec-4.3.14) Boolean type
************************************

type consisting of the primitive values true and false.


File: javascript_ecma_262_5th_ed.info,  Node: 4315 Boolean object,  Next: 4316 String value,  Prev: 4314 Boolean type,  Up: Top

27 4.3.15 (#sec-4.3.15) Boolean object
**************************************

member of the Object type that is an instance of the standard built-in
Boolean (#sec-15.6) constructor.

   NOTE A Boolean object is created by using the Boolean (#sec-15.6)
constructor in a `new' expression, supplying a Boolean value as an
argument. The resulting object has an internal property whose value is
the Boolean value. A Boolean object can be coerced to a Boolean value.


File: javascript_ecma_262_5th_ed.info,  Node: 4316 String value,  Next: 4317 String type,  Prev: 4315 Boolean object,  Up: Top

28 4.3.16 (#sec-4.3.16) String value
************************************

primitive value that is a finite ordered sequence of zero or more
16-bit unsigned integer.

   NOTE A String value is a member of the String type. Each integer
value in the sequence usually represents a single 16-bit unit of UTF-16
text. However, ECMAScript does not place any restrictions or
requirements on the values except that they must be 16-bit unsigned
integers.


File: javascript_ecma_262_5th_ed.info,  Node: 4317 String type,  Next: 4318 String object,  Prev: 4316 String value,  Up: Top

29 4.3.17 (#sec-4.3.17) String type
***********************************

set of all possible String values.


File: javascript_ecma_262_5th_ed.info,  Node: 4318 String object,  Next: 4319 Number value,  Prev: 4317 String type,  Up: Top

30 4.3.18 (#sec-4.3.18) String object
*************************************

member of the Object type that is an instance of the standard built-in
String (#sec-15.5) constructor.

   NOTE A String object is created by using the String (#sec-15.5)
constructor in a `new' expression, supplying a String value as an
argument. The resulting object has an internal property whose value is
the String value. A String object can be coerced to a String value by
calling the String constructor as a function (15.5.1 (#sec-15.5.1)).


File: javascript_ecma_262_5th_ed.info,  Node: 4319 Number value,  Next: 4320 Number type,  Prev: 4318 String object,  Up: Top

31 4.3.19 (#sec-4.3.19) Number value
************************************

primitive value corresponding to a double-precision 64-bit binary
format IEEE 754 value.

   NOTE A Number value is a member of the Number type and is a direct
representation of a number.


File: javascript_ecma_262_5th_ed.info,  Node: 4320 Number type,  Next: 4321 Number object,  Prev: 4319 Number value,  Up: Top

32 4.3.20 (#sec-4.3.20) Number type
***********************************

set of all possible Number values including the special
“Not-a-Number” (NaN) values, positive infinity, and negative
infinity.


File: javascript_ecma_262_5th_ed.info,  Node: 4321 Number object,  Next: 4322 Infinity,  Prev: 4320 Number type,  Up: Top

33 4.3.21 (#sec-4.3.21) Number object
*************************************

member of the Object type that is an instance of the standard built-in
Number (#sec-15.7) constructor.

   NOTE A Number object is created by using the Number (#sec-15.7)
constructor in a `new' expression, supplying a Number value as an
argument. The resulting object has an internal property whose value is
the Number value. A Number object can be coerced to a Number value by
calling the Number constructor as a function (15.7.1 (#sec-15.7.1)).


File: javascript_ecma_262_5th_ed.info,  Node: 4322 Infinity,  Next: 4323 NaN,  Prev: 4321 Number object,  Up: Top

34 4.3.22 (#sec-4.3.22) Infinity
********************************

Number value that is the positive infinite Number value.


File: javascript_ecma_262_5th_ed.info,  Node: 4323 NaN,  Next: 4324 function,  Prev: 4322 Infinity,  Up: Top

35 4.3.23 (#sec-4.3.23) NaN
***************************

Number value that is a IEEE 754 “Not-a-Number” value.


File: javascript_ecma_262_5th_ed.info,  Node: 4324 function,  Next: 4325 built-in function,  Prev: 4323 NaN,  Up: Top

36 4.3.24 (#sec-4.3.24) function
********************************

member of the Object type that is an instance of the standard built-in
Function (#sec-15.3) constructor and that may be invoked as a
subroutine.

   NOTE In addition to its named properties, a function contains
executable code and state that determine how it behaves when invoked. A
function’s code may or may not be written in ECMAScript.


File: javascript_ecma_262_5th_ed.info,  Node: 4325 built-in function,  Next: 4326 property,  Prev: 4324 function,  Up: Top

37 4.3.25 (#sec-4.3.25) built-in function
*****************************************

built-in object that is a function.

   NOTE Examples of built-in functions include parseInt (#sec-15.1.2.2)
and Math.exp (#sec-15.8.2.8). An implementation may provide
implementation-dependent built-in functions that are not described in
this specification.


File: javascript_ecma_262_5th_ed.info,  Node: 4326 property,  Next: 4327 method,  Prev: 4325 built-in function,  Up: Top

38 4.3.26 (#sec-4.3.26) property
********************************

association between a name and a value that is a part of an object.

   NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.


File: javascript_ecma_262_5th_ed.info,  Node: 4327 method,  Next: 4328 built-in method,  Prev: 4326 property,  Up: Top

39 4.3.27 (#sec-4.3.27) method
******************************

function that is the value of a property.

   NOTE When a function is called as a method of an object, the object
is passed to the function as its this value.


File: javascript_ecma_262_5th_ed.info,  Node: 4328 built-in method,  Next: 4329 attribute,  Prev: 4327 method,  Up: Top

40 4.3.28 (#sec-4.3.28) built-in method
***************************************

method (#sec-4.3.27) that is a built-in function (#sec-4.3.25).

   NOTE Standard built-in methods are defined in this specification,
and an ECMAScript implementation may specify and provide other
additional built-in methods.


File: javascript_ecma_262_5th_ed.info,  Node: 4329 attribute,  Next: 4330 own property,  Prev: 4328 built-in method,  Up: Top

41 4.3.29 (#sec-4.3.29) attribute
*********************************

internal value that defines some characteristic of a property.


File: javascript_ecma_262_5th_ed.info,  Node: 4330 own property,  Next: 4331 inherited property,  Prev: 4329 attribute,  Up: Top

42 4.3.30 (#sec-4.3.30) own property
************************************

property that is directly contained by its object.


File: javascript_ecma_262_5th_ed.info,  Node: 4331 inherited property,  Next: 5 Notational Conventions,  Prev: 4330 own property,  Up: Top

43 4.3.31 (#sec-4.3.31) inherited property
******************************************

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype.


File: javascript_ecma_262_5th_ed.info,  Node: 5 Notational Conventions,  Next: 51 Syntactic and Lexical Grammars,  Prev: 4331 inherited property,  Up: Top

44 5 (#sec-5) Notational Conventions
************************************


File: javascript_ecma_262_5th_ed.info,  Node: 51 Syntactic and Lexical Grammars,  Next: 511 Context-Free Grammars,  Prev: 5 Notational Conventions,  Up: Top

45 5.1 (#sec-5.1) Syntactic and Lexical Grammars
************************************************


File: javascript_ecma_262_5th_ed.info,  Node: 511 Context-Free Grammars,  Next: 512 The Lexical and RegExp Grammars,  Prev: 51 Syntactic and Lexical Grammars,  Up: Top

46 5.1.1 (#sec-5.1.1) Context-Free Grammars
*******************************************

A context-free grammar consists of a number of productions. Each
production has an abstract symbol called a nonterminal as its left-hand
side, and a sequence of zero or more nonterminal and terminal symbols
as its right-hand side. For each grammar, the terminal symbols are
drawn from a specified alphabet.


File: javascript_ecma_262_5th_ed.info,  Node: 512 The Lexical and RegExp Grammars,  Next: 513 The Numeric String Grammar,  Prev: 511 Context-Free Grammars,  Up: Top

47 5.1.2 (#sec-5.1.2) The Lexical and RegExp Grammars
*****************************************************

A lexical grammar for ECMAScript is given in clause 7 (#sec-7). This
grammar has as its terminal symbols characters (Unicode code units)
that conform to the rules for SourceCharacter defined in Clause 6
(#sec-6). It defines a set of productions, starting from the goal
symbol InputElementDiv or InputElementRegExp, that describe how
sequences of such characters are translated into a sequence of input
elements.

   Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript tokens. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (7.9) (#sec-7.9). Simple white space and
single-line comments are discarded and do not appear in the stream of
input elements for the syntactic grammar. A MultiLineComment (that is,
a comment of the form “`/*...*/'” regardless of whether it spans
more than one line) is likewise simply discarded if it contains no line
terminator; but if a MultiLineComment contains one or more line
terminators, then it is replaced by a single line terminator, which
becomes part of the stream of input elements for the syntactic grammar.

   A RegExp grammar for ECMAScript is given in 15.10 (#sec-15.10). This
grammar also has as its terminal symbols the characters as defined by
SourceCharacter. It defines a set of productions, starting from the
goal symbol Pattern, that describe how sequences of characters are
translated into regular expression patterns.

   Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and
RegExp grammars share some productions.


File: javascript_ecma_262_5th_ed.info,  Node: 513 The Numeric String Grammar,  Next: 514 The Syntactic Grammar,  Prev: 512 The Lexical and RegExp Grammars,  Up: Top

48 5.1.3 (#sec-5.1.3) The Numeric String Grammar
************************************************

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols SourceCharacter.
This grammar appears in 9.3.1 (#sec-9.3.1).

   Productions of the numeric string grammar are distinguished by
having three colons “:::” as punctuation.


File: javascript_ecma_262_5th_ed.info,  Node: 514 The Syntactic Grammar,  Next: 515 The JSON Grammar,  Prev: 513 The Numeric String Grammar,  Up: Top

49 5.1.4 (#sec-5.1.4) The Syntactic Grammar
*******************************************

The syntactic grammar for ECMAScript is given in clauses 11 (#sec-11),
12 (#sec-12), 13 (#sec-13) and 14 (#sec-14). This grammar has
ECMAScript tokens defined by the lexical grammar as its terminal
symbols (5.1.2 (#sec-5.1.2)). It defines a set of productions, starting
from the goal symbol Program, that describe how sequences of tokens can
form syntactically correct ECMAScript programs.

   When a stream of characters is to be parsed as an ECMAScript
program, it is first converted to a stream of input elements by
repeated application of the lexical grammar; this stream of input
elements is then parsed by a single application of the syntactic
grammar. The program is syntactically in error if the tokens in the
stream of input elements cannot be parsed as a single instance of the
goal nonterminal Program, with no tokens left over.

   Productions of the syntactic grammar are distinguished by having
just one colon “:” as punctuation.

   The syntactic grammar as presented in clauses 11 (#sec-11), 12
(#sec-12), 13 (#sec-13) and 14 (#sec-14) is actually not a complete
account of which token sequences are accepted as correct ECMAScript
programs. Certain additional token sequences are also accepted, namely,
those that would be described by the grammar if only semicolons were
added to the sequence in certain places (such as before line terminator
characters). Furthermore, certain token sequences that are described by
the grammar are not considered acceptable if a terminator character
appears in certain “awkward” places.


File: javascript_ecma_262_5th_ed.info,  Node: 515 The JSON Grammar,  Next: 516 Grammar Notation,  Prev: 514 The Syntactic Grammar,  Up: Top

50 5.1.5 (#sec-5.1.5) The JSON Grammar
**************************************

The JSON grammar is used to translate a String describing a set of
ECMAScript objects into actual objects. The JSON grammar is given in
15.12.1 (#sec-15.12.1).

   The JSON grammar consists of the JSON lexical grammar and the JSON
syntactic grammar. The JSON lexical grammar is used to translate
character sequences into tokens and is similar to parts of the
ECMAScript lexical grammar. The JSON syntactic grammar describes how
sequences of tokens from the JSON lexical grammar can form
syntactically correct JSON object descriptions.

   Productions of the JSON lexical grammar are distinguished by having
two colons “::” as separating punctuation. The JSON lexical grammar
uses some productions from the ECMAScript lexical grammar. The JSON
syntactic grammar is similar to parts of the ECMAScript syntactic
grammar. Productions of the JSON syntactic grammar are distinguished by
using one colon “:” as separating punctuation.


File: javascript_ecma_262_5th_ed.info,  Node: 516 Grammar Notation,  Next: 52 Algorithm Conventions,  Prev: 515 The JSON Grammar,  Up: Top

51 5.1.6 (#sec-5.1.6) Grammar Notation
**************************************

Terminal symbols of the lexical and string grammars, and some of the
terminal symbols of the syntactic grammar, are shown in `fixed width'
font, both in the productions of the grammars and throughout this
specification whenever the text directly refers to such a terminal
symbol. These are to appear in a program exactly as written. All
terminal symbol characters specified in this way are to be understood
as the appropriate Unicode character from the ASCII range, as opposed
to any similar-looking characters from other Unicode ranges.

   Nonterminal symbols are shown in italic type. The definition of a
nonterminal is introduced by the name of the nonterminal being defined
followed by one or more colons. (The number of colons indicates to
which grammar the production belongs.) One or more alternative
right-hand sides for the nonterminal then follow on succeeding lines.
For example, the syntactic definition:

   WhileStatement : `while' `(' Expression `)' Statement states that
the nonterminal WhileStatement represents the token `while', followed
by a left parenthesis token, followed by an Expression, followed by a
right parenthesis token, followed by a Statement. The occurrences of
Expression and Statement are themselves nonterminals. As another
example, the syntactic definition:

   ArgumentList : AssignmentExpression ArgumentList `,'
AssignmentExpression states that an ArgumentList may represent either a
single AssignmentExpression or an ArgumentList, followed by a comma,
followed by an AssignmentExpression. This definition of ArgumentList is
recursive, that is, it is defined in terms of itself. The result is
that an ArgumentList may contain any positive number of arguments,
separated by commas, where each argument expression is an
AssignmentExpression. Such recursive definitions of nonterminals are
common.

   The subscripted suffix “_opt_”, which may appear after a
terminal or nonterminal, indicates an optional symbol. The alternative
containing the optional symbol actually specifies two right-hand sides,
one that omits the optional element and one that includes it. This
means that:

   VariableDeclaration : Identifier Initialiser_opt_ is a convenient
abbreviation for:

   VariableDeclaration : Identifier Identifier Initialiser

   IterationStatement : `for' `(' ExpressionNoIn_opt_ `;'
Expression_opt_ `;' Expression_opt_ `)' Statement is a convenient
abbreviation for:

   IterationStatement : `for' `(' `;' Expression_opt_ `;'
Expression_opt_ `)' Statement `for' `(' ExpressionNoIn `;'
Expression_opt_ `;' Expression_opt_ `)' Statement which in turn is an
abbreviation for:

   IterationStatement : `for' `(' `;' `;' Expression_opt_ `)' Statement
`for' `(' `;' Expression `;' Expression_opt_ `)' Statement `for' `('
ExpressionNoIn `;' `;' Expression_opt_ `)' Statement `for' `('
ExpressionNoIn `;' Expression `;' Expression_opt_ `)' Statement which
in turn is an abbreviation for:

   IterationStatement : `for' `(' `;' `;' `)' Statement `for' `(' `;'
`;' Expression `)' Statement `for' `(' `;' Expression `;' `)' Statement
`for' `(' `;' Expression `;' Expression `)' Statement `for' `('
ExpressionNoIn `;' `;' `)' Statement `for' `(' ExpressionNoIn `;' `;'
Expression `)' Statement `for' `(' ExpressionNoIn `;' Expression `;'
`)' Statement `for' `(' ExpressionNoIn `;' Expression `;' Expression
`)' Statement so the nonterminal IterationStatement actually has eight
alternative right-hand sides.

   If the phrase “[empty]” appears as the right-hand side of a
production, it indicates that the production’s right-hand side
contains no terminals or nonterminals.

   If the phrase “[lookahead ∉ set]” appears in the right-hand
side of a production, it indicates that the production may not be used
if the immediately following input token is a member of the given set.
The set can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. For example, given the definitions

   DecimalDigit :: one of `0' `1' `2' `3' `4' `5' `6' `7' `8' `9'
DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit the definition

   LookaheadExample :: `n' [lookahead ∉ {`1', `3', `5', `7', `9'}]
DecimalDigits DecimalDigit [lookahead ∉ DecimalDigit] matches either
the letter `n' followed by one or more decimal digits the first of
which is even, or a decimal digit not followed by another decimal digit.

   ReturnStatement : `return' [no LineTerminator here] Expression_opt_
`;' indicates that the production may not be used if a LineTerminator
occurs in the program between the `return' token and the Expression.

   Unless the presence of a LineTerminator is forbidden by a restricted
production, any number of occurrences of LineTerminator may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the program.

   When the words “one of” follow the colon(s) in a grammar
definition, they signify that each of the terminal symbols on the
following line or lines is an alternative definition. For example, the
lexical grammar for ECMAScript contains the production:

   NonZeroDigit :: one of `1  2  3  4  5  6  7  8  9' which is merely a
convenient abbreviation for:

   NonZeroDigit :: `1' `2' `3' `4' `5' `6' `7' `8' `9' When an
alternative in a production of the lexical grammar or the numeric
string grammar appears to be a multi-character token, it represents the
sequence of characters that would make up such a token.

   The right-hand side of a production may specify that certain
expansions are not permitted by using the phrase “but not” and then
indicating the expansions to be excluded. For example, the production:

   Identifier :: IdentifierName but not ReservedWord means that the
nonterminal Identifier may be replaced by any sequence of characters
that could replace IdentifierName provided that the same sequence of
characters could not replace ReservedWord.

   Finally, a few nonterminal symbols are described by a descriptive
phrase in sans-serif type in cases where it would be impractical to
list all the alternatives:

   SourceCharacter :: any Unicode code unit


File: javascript_ecma_262_5th_ed.info,  Node: 52 Algorithm Conventions,  Next: 6 Source Text,  Prev: 516 Grammar Notation,  Up: Top

52 5.2 (#sec-5.2) Algorithm Conventions
***************************************

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

   When an algorithm is to produce a value as a result, the directive
“return x” is used to indicate that the result of the algorithm is
the value of x and that the algorithm should terminate. The notation
Result(n) is used as shorthand for “the result of step n”.

   For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be
further divided into indented substeps. Outline numbering conventions
are used to identify substeps with the first level of substeps labelled
with lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

  1. Top-level step
       1. Substep.

       2. Substep
            1. Subsubstep.

            2. Subsubstep.
                 1. Subsubsubstep
                      1. Subsubsubsubstep





   A step or substep may be written as an “if” predicate that
conditions its substeps. In this case, the substeps are only applied if
the predicate is true. If a step or substep begins with the word
“else”, it is a predicate that is the negation of the preceding
“if” predicate step at the same level.

   A step may specify the iterative application of its substeps.

   Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished
from positive zero. Algorithms in this standard that model
floating-point arithmetic include explicit steps, where necessary, to
handle infinities and signed zero and to perform rounding. If a
mathematical operation or function is applied to a floating-point
number, it should be understood as being applied to the exact
mathematical value represented by that floating-point number; such a
floating-point number must be finite, and if it is +0 or −0 then the
corresponding mathematical value is simply 0.

   The mathematical function abs(x) yields the absolute value of x,
which is −x if x is negative (less than zero) and otherwise is x
itself.

   The mathematical function sign(x) yields 1 if x is positive and −1
if x is negative. The sign function is not used in this standard for
cases when x is zero.

   The notation “x modulo y” (y must be finite and nonzero)
computes a value k of the same sign as y (or zero) such that abs(k) <
abs(y) and x − k = q × y for some integer q.

   The mathematical function floor(x) yields the largest integer
(closest to positive infinity) that is not larger than x.

   NOTE floor(x) = x − (x modulo 1).

   If an algorithm is defined to “throw an exception”, execution of
the algorithm is terminated and no result is returned. The calling
algorithms are also terminated, until an algorithm step is reached that
explicitly deals with the exception, using terminology such as “If an
exception was thrown...”. Once such an algorithm step has been
encountered the exception is no longer considered to have occurred.


File: javascript_ecma_262_5th_ed.info,  Node: 6 Source Text,  Next: 7 Lexical Conventions,  Prev: 52 Algorithm Conventions,  Up: Top

53 6 (#sec-6) Source Text
*************************

ECMAScript source text is represented as a sequence of characters in
the Unicode character encoding, version 3.0 or later. The text is
expected to have been normalised to Unicode Normalised Form C (canonical

   SourceCharacter :: any Unicode code unit Throughout the rest of this
document, the phrase “code unit” and the word “character” will
be used to refer to a 16-bit unsigned value used to represent a single
16-bit unit of text. The phrase “Unicode character” will be used to
refer to the abstract linguistic or typographical unit represented by a
single Unicode scalar value (which may be longer than 16 bits and thus
may be represented by more than one code unit). The phrase “code
point” refers to such a Unicode scalar value. “Unicode character”
only refers to entities represented by single Unicode scalar values:
the components of a combining character sequence are still individual
“Unicode characters,” even though a user might think of the whole
sequence as a single character.

   In string literals, regular expression literals, and identifiers,
any character (code unit) may also be expressed as a Unicode escape
sequence consisting of six characters, namely `\u' plus four
hexadecimal digits. Within a comment, such an escape sequence is
effectively ignored as part of the comment. Within a string literal or
regular expression literal, the Unicode escape sequence contributes one
character to the value of the literal. Within an identifier, the escape
sequence contributes one character to the identifier.

   NOTE Although this document sometimes refers to a
“transformation” between a “character” within a “string”
and the 16-bit unsigned integer that is the code unit of that
character, there is actually no transformation because a
“character” within a “string” is actually represented using
that 16-bit unsigned value.

   ECMAScript differs from the Java programming language in the
behaviour of Unicode escape sequences. In a Java program, if the
Unicode escape sequence `\u000A', for example, occurs within a
single-line comment, it is interpreted as a line terminator (Unicode
character `000A' is line feed) and therefore the next character is not
part of the comment. Similarly, if the Unicode escape sequence `\u000A'
occurs within a string literal in a Java program, it is likewise
interpreted as a line terminator, which is not allowed within a string
literal—one must write `\n' instead of `\u000A' to cause a line feed
to be part of the string value of a string literal. In an ECMAScript
program, a Unicode escape sequence occurring within a comment is never
interpreted and therefore cannot contribute to termination of the
comment. Similarly, a Unicode escape sequence occurring within a string
literal in an ECMAScript program always contributes a character to the
String value of the literal and is never interpreted as a line
terminator or as a quote mark that might terminate the string literal.


File: javascript_ecma_262_5th_ed.info,  Node: 7 Lexical Conventions,  Next: 71 Unicode Format-Control Characters,  Prev: 6 Source Text,  Up: Top

54 7 (#sec-7) Lexical Conventions
*********************************

The source text of an ECMAScript program is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to
right, repeatedly taking the longest possible sequence of characters as
the next input element.

   There are two goal symbols for the lexical grammar. The
InputElementDiv symbol is used in those syntactic grammar contexts
where a leading division (`/') or division-assignment (`/=') operator
is permitted. The InputElementRegExp symbol is used in other syntactic
grammar contexts.

   NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading RegularExpressionLiteral
are permitted. This is not affected by semicolon insertion (see 7.9)
(#sec-7.9); in examples such as the following:

a = b
/hi/g.exec(c).map(d);

   where the first non-whitespace, non-comment character after a
LineTerminator is slash (`/') and the syntactic context allows division
or division-assignment, no semicolon is inserted at the LineTerminator.
That is, the above example is interpreted in the same way as:

a = b / hi / g.exec(c).map(d);

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 7 Lexical Conventions

54.1 Syntax
===========

InputElementDiv :: WhiteSpace LineTerminator Comment Token DivPunctuator
InputElementRegExp :: WhiteSpace LineTerminator Comment Token
RegularExpressionLiteral


File: javascript_ecma_262_5th_ed.info,  Node: 71 Unicode Format-Control Characters,  Next: 72 White Space,  Prev: 7 Lexical Conventions,  Up: Top

55 7.1 (#sec-7.1) Unicode Format-Control Characters
***************************************************

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK
or RIGHT-TO-LEFT MARK) are control codes used to control the formatting
of a range of text in the absence of higher-level protocols for this
(such as mark-up languages).

   It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals and regular expression
literals.

   <ZWNJ> and <ZWJ> are format-control characters that are used to make
necessary distinctions when forming words or phrases in certain
languages. In ECMAScript source text, <ZWNJ> and <ZWJ> may also be used
in an identifier after the first character.

   <BOM> is a format-control character used primarily at the start of a
text to mark it as Unicode and to allow detection of the text’s
encoding and byte order. <BOM> characters intended for this purpose can
sometimes also appear after the start of a text, for example as a
result of concatenating files. <BOM> characters are treated as white
space characters (see 7.2 (#sec-7.2)).

   The special treatment of certain format-control characters outside
of comments, string literals, and regular expression literals is
summarized in Table 1.

   Table 1 — Format-Control Character Usage Code Unit Value Name
Formal Name Usage `\u200C' Zero width non-joiner <ZWNJ> IdentifierPart
`\u200D' Zero width joiner <ZWJ> IdentifierPart `\uFEFF' Byte Order Mark
<BOM> Whitespace


File: javascript_ecma_262_5th_ed.info,  Node: 72 White Space,  Next: 73 Line Terminators,  Prev: 71 Unicode Format-Control Characters,  Up: Top

56 7.2 (#sec-7.2) White Space
*****************************

White space characters are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space characters may occur between any
two tokens and at the start or end of input. White space characters may
also occur within a StringLiteral or a RegularExpressionLiteral (where
they are considered significant characters forming part of the literal
value) or within a Comment, but cannot appear within any other kind of
token.

   The ECMAScript white space characters are listed in Table 2.

   Code Unit Value Name Formal Name \u0009 Tab <TAB> \u000B Vertical Tab
<VT> \u000C Form Feed <FF> \u0020 Space <SP> \u00A0 No-break space
<NBSP> \uFEFF Byte Order Mark <BOM> Other category “Zs” Any other
Unicode “space separator” <USP> ECMAScript implementations must
recognize all of the white space characters defined in Unicode 3.0.
Later editions of the Unicode Standard may define other white space
characters. ECMAScript implementations may recognize white space
characters from later editions of the Unicode Standard.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 72 White Space

56.1 Syntax
===========

WhiteSpace :: <TAB> <VT> <FF> <SP> <NBSP> <BOM> <USP>


File: javascript_ecma_262_5th_ed.info,  Node: 73 Line Terminators,  Next: 74 Comments,  Prev: 72 White Space,  Up: Top

57 7.3 (#sec-7.3) Line Terminators
**********************************

Like white space characters, line terminator characters are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space characters,
line terminators have some influence over the behaviour of the
syntactic grammar. In general, line terminators may occur between any
two tokens, but there are a few places where they are forbidden by the
syntactic grammar. Line terminators also affect the process of
automatic semicolon insertion (7.9) (#sec-7.9). A line terminator
cannot occur within any token except a StringLiteral. Line terminators
may only occur within a StringLiteral token as part of a
LineContinuation.

   A line terminator can occur within a MultiLineComment (7.4
(#sec-7.4)) but cannot occur within a SingleLineComment.

   Line terminators are included in the set of white space characters
that are matched by the `\s' class (#sec-15.10.2.12) in regular
expressions.

   The ECMAScript line terminator characters are listed in Table 3.

   Table 3 — Line Terminator Characters Code Unit Value Name Formal
Name `\u000A' Line Feed <LF> `\u000D' Carriage Return <CR> `\u2028'
Line separator <LS> `\u2029' Paragraph separator <PS> Only the
characters in Table 3 are treated as line terminators. Other new line
or line breaking characters are treated as white space but not as line
terminators. The character sequence <CR><LF> is commonly used as a line
terminator. It should be considered a single character for the purpose
of reporting line numbers.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 73 Line Terminators

57.1 Syntax
===========

LineTerminator :: <LF> <CR> <LS> <PS> LineTerminatorSequence :: <LF>
<CR> [lookahead ∉ (#def-lookahead-notin) <LF>] <LS> <PS> <CR> <LF>


File: javascript_ecma_262_5th_ed.info,  Node: 74 Comments,  Next: 75 Tokens,  Prev: 73 Line Terminators,  Up: Top

58 7.4 (#sec-7.4) Comments
**************************

Comments can be either single or multi-line. Multi-line comments cannot
nest.

   Because a single-line comment can contain any character except a
LineTerminator character, and because of the general rule that a token
is always as long as possible, a single-line comment always consists of
all characters from the `//' marker to the end of the line. However,
the LineTerminator at the end of the line is not considered to be part
of the single-line comment; it is recognised separately by the lexical
grammar and becomes part of the stream of input elements for the
syntactic grammar. This point is very important, because it implies
that the presence or absence of single-line comments does not affect
the process of automatic semicolon insertion (see 7.9) (#sec-7.9).

   Comments behave like white space and are discarded except that, if a
MultiLineComment contains a line terminator character, then the entire
comment is considered to be a LineTerminator for purposes of parsing by
the syntactic grammar.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 74 Comments

58.1 Syntax
===========

Comment :: MultiLineComment SingleLineComment MultiLineComment :: `/*'
MultiLineCommentChars_opt_ `*/' MultiLineCommentChars ::
MultiLineNotAsteriskChar MultiLineCommentChars_opt_ `*'
PostAsteriskCommentChars_opt_ PostAsteriskCommentChars ::
MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars_opt_ `*'
PostAsteriskCommentChars_opt_ MultiLineNotAsteriskChar ::
SourceCharacter but not asterisk `*'
MultiLineNotForwardSlashOrAsteriskChar :: SourceCharacter but not
forward-slash `/' or asterisk `*' SingleLineComment :: `//'
SingleLineCommentChars_opt_ SingleLineCommentChars ::
SingleLineCommentChar SingleLineCommentChars_opt_

   SingleLineCommentChar :: SourceCharacter but not LineTerminator


File: javascript_ecma_262_5th_ed.info,  Node: 75 Tokens,  Next: 76 Identifier Names and Identifiers,  Prev: 74 Comments,  Up: Top

59 7.5 (#sec-7.5) Tokens
************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 75 Tokens

59.1 Syntax
===========

Token :: IdentifierName Punctuator NumericLiteral StringLiteral NOTE
The DivPunctuator and RegularExpressionLiteral productions define
tokens, but are not included in the Token production.


File: javascript_ecma_262_5th_ed.info,  Node: 76 Identifier Names and Identifiers,  Next: 761 Reserved Words,  Prev: 75 Tokens,  Up: Top

60 7.6 (#sec-7.6) Identifier Names and Identifiers
**************************************************

Identifier Names are tokens that are interpreted according to the
grammar given in the “Identifiers” section of chapter 5 of the
Unicode standard, with some small modifications. An Identifier is an
IdentifierName that is not a ReservedWord (see 7.6.1 (#sec-7.6.1)). The
Unicode identifier grammar is based on both normative and informative
character categories specified by the Unicode Standard. The characters
in the specified categories in version 3.0 of the Unicode standard must
be treated as in those categories by all conforming ECMAScript
implementations.

   This standard specifies specific character additions: The dollar
sign (`$') and the underscore (`_') are permitted anywhere in an
IdentifierName.

   Unicode escape sequences are also permitted in an IdentifierName,
where they contribute a single character to the IdentifierName, as
computed by the CV of the UnicodeEscapeSequence (see 7.8.4
(#sec-7.8.4)). The `\' preceding the UnicodeEscapeSequence does not
contribute a character to the IdentifierName. A UnicodeEscapeSequence
cannot be used to put a character into an IdentifierName that would
otherwise be illegal. In other words, if a `\' UnicodeEscapeSequence
sequence were replaced by its UnicodeEscapeSequence’s CV, the result
must still be a valid IdentifierName that has the exact same sequence
of characters as the original IdentifierName. All interpretations of
identifiers within this specification are based upon their actual
characters regardless of whether or not an escape sequence was used to
contribute any particular characters.

   Two IdentifierName that are canonically equivalent according to the
Unicode standard are _not_ equal unless they are represented by the
exact same sequence of code units (in other words, conforming
ECMAScript implementations are only required to do bitwise comparison
on IdentifierName values). The intent is that the incoming source text
has been converted to normalised form C before it reaches the compiler.

   ECMAScript implementations may recognize identifier characters
defined in later editions of the Unicode Standard. If portability is a
concern, programmers should only employ identifier characters defined
in Unicode 3.0.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 76 Identifier Names and Identifiers

60.1 Syntax
===========

Identifier :: IdentifierName but not ReservedWord IdentifierName ::
IdentifierStart IdentifierName IdentifierPart

   IdentifierStart :: UnicodeLetter `$' `_' `\' UnicodeEscapeSequence
IdentifierPart :: IdentifierStart UnicodeCombiningMark UnicodeDigit
UnicodeConnectorPunctuation <ZWNJ> <ZWJ> UnicodeLetter :: any character
in the Unicode categories “Uppercase letter (Lu)”, “Lowercase
letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.
UnicodeCombiningMark :: any character in the Unicode categories
“Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”
UnicodeDigit :: any character in the Unicode category “Decimal number
(Nd)” UnicodeConnectorPunctuation :: any character in the Unicode
category “Connector punctuation (Pc)” UnicodeEscapeSequence :: see
7.8.4 (#sec-7.8.4).


File: javascript_ecma_262_5th_ed.info,  Node: 761 Reserved Words,  Next: 7611 Keywords,  Prev: 76 Identifier Names and Identifiers,  Up: Top

61 7.6.1 (#sec-7.6.1) Reserved Words
************************************

A reserved word is an IdentifierName that cannot be used as an
Identifier.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 761 Reserved Words

61.1 Syntax
===========

ReservedWord :: Keyword FutureReservedWord NullLiteral BooleanLiteral


File: javascript_ecma_262_5th_ed.info,  Node: 7611 Keywords,  Next: 7612 Future Reserved Words,  Prev: 761 Reserved Words,  Up: Top

62 7.6.1.1 (#sec-7.6.1.1) Keywords
**********************************

The following tokens are ECMAScript keywords and may not be used as
Identifiers in ECMAScript programs.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 7611 Keywords

62.1 Syntax
===========

Keyword :: one of `break' `do' `instanceof' `typeof' `case' `else'
`new' `var' `catch' `finally' `return' `void' `continue' `for' `switch'
`while' `debugger' `function' `this' `with' `default' `if' `throw' ` '
`delete' `in' `try'


File: javascript_ecma_262_5th_ed.info,  Node: 7612 Future Reserved Words,  Next: 77 Punctuators,  Prev: 7611 Keywords,  Up: Top

63 7.6.1.2 (#sec-7.6.1.2) Future Reserved Words
***********************************************

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 7612 Future Reserved Words

63.1 Syntax
===========

FutureReservedWord :: one of `class' `enum' `extends' `super' `const'
`export' `import' The following tokens are also considered to be
FutureReservedWords when they occur within strict mode code (see
10.1.1) (#sec-10.1.1). The occurrence of any of these tokens within
strict mode code (#sec-10.1.1) in any context where the occurrence of a
FutureReservedWord would produce an error must also produce an
equivalent error:

   `implements' `let' `private' `public' `yield' `interface' `package'
`protected' `static'


File: javascript_ecma_262_5th_ed.info,  Node: 77 Punctuators,  Next: 78 Literals,  Prev: 7612 Future Reserved Words,  Up: Top

64 7.7 (#sec-7.7) Punctuators
*****************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 77 Punctuators

64.1 Syntax
===========

Punctuator :: one of `{' `}' `(' `)' `[' `]' `.' `;' `,' `<' `>' `<='
`>=' `==' `!=' `===' `!==' `+' `-' `*' `%' `++' `--' `<<' `>>' `>>>'
`&' `|' `^' `!' `~' `&&' `||' `?' `:' `=' `+=' `-=' `*=' `%=' `<<='
`>>=' `>>>=' `&=' `|=' `^=' DivPunctuator :: one of `/' `/='


File: javascript_ecma_262_5th_ed.info,  Node: 78 Literals,  Next: 781 Null Literals,  Prev: 77 Punctuators,  Up: Top

65 7.8 (#sec-7.8) Literals
**************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 78 Literals

65.1 Syntax
===========

Literal :: NullLiteral BooleanLiteral NumericLiteral StringLiteral
RegularExpressionLiteral


File: javascript_ecma_262_5th_ed.info,  Node: 781 Null Literals,  Next: 782 Boolean Literals,  Prev: 78 Literals,  Up: Top

66 7.8.1 (#sec-7.8.1) Null Literals
***********************************

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 781 Null Literals

66.1 Syntax
===========

NullLiteral :: `null'


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 781 Null Literals

66.2 Semantics
==============

The value of the null literal `null' is the sole value of the Null
type, namely null.


File: javascript_ecma_262_5th_ed.info,  Node: 782 Boolean Literals,  Next: 783 Numeric Literals,  Prev: 781 Null Literals,  Up: Top

67 7.8.2 (#sec-7.8.2) Boolean Literals
**************************************

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 782 Boolean Literals

67.1 Syntax
===========

BooleanLiteral :: `true' `false'


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 782 Boolean Literals

67.2 Semantics
==============

The value of the Boolean literal `true' is a value of the Boolean type,
namely true.

   The value of the Boolean literal `false' is a value of the Boolean
type, namely false.


File: javascript_ecma_262_5th_ed.info,  Node: 783 Numeric Literals,  Next: 784 String Literals,  Prev: 782 Boolean Literals,  Up: Top

68 7.8.3 (#sec-7.8.3) Numeric Literals
**************************************

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 783 Numeric Literals

68.1 Syntax
===========

NumericLiteral :: DecimalLiteral HexIntegerLiteral DecimalLiteral ::
DecimalIntegerLiteral `.' DecimalDigits_opt_ ExponentPart_opt_ `.'
DecimalDigits ExponentPart_opt_ DecimalIntegerLiteral ExponentPart_opt_
DecimalIntegerLiteral :: `0' NonZeroDigit DecimalDigits_opt_
DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit DecimalDigit
:: one of `0  1  2  3  4  5  6  7  8  9' NonZeroDigit :: one of `1  2
3  4  5  6  7  8  9' ExponentPart :: ExponentIndicator SignedInteger
ExponentIndicator :: one of `e  E' SignedInteger :: DecimalDigits `+'
DecimalDigits `-' DecimalDigits HexIntegerLiteral :: `0x' HexDigit `0X'
HexDigit HexIntegerLiteral HexDigit

   HexDigit :: one of `0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
A  B  C  D  E  F' The source character immediately following a
NumericLiteral must not be an IdentifierStart or DecimalDigit.

   NOTE For example:

3in

   is an error and not the two input elements `3' and `in'.


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 783 Numeric Literals

68.2 Semantics
==============

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

   * The MV of NumericLiteral :: DecimalLiteral is the MV of
     DecimalLiteral.

   * The MV of NumericLiteral :: HexIntegerLiteral is the MV of
     HexIntegerLiteral.

   * The MV of DecimalLiteral :: DecimalIntegerLiteral `.' is the MV of
     DecimalIntegerLiteral.

   * The MV of DecimalLiteral :: DecimalIntegerLiteral `.'
     DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of
     DecimalDigits times 10^−n), where n is the number of characters
     in DecimalDigits.

   * The MV of DecimalLiteral :: DecimalIntegerLiteral `.' ExponentPart
     is the MV of DecimalIntegerLiteral times 10^e, where e is the MV
     of ExponentPart.

   * The MV of DecimalLiteral :: DecimalIntegerLiteral `.'
     DecimalDigits ExponentPart is (the MV of DecimalIntegerLiteral
     plus (the MV of DecimalDigits times 10^−n)) times 10^e, where n
     is the number of characters in DecimalDigits and e is the MV of
     ExponentPart.

   * The MV of DecimalLiteral :: `.' DecimalDigits is the MV of
     DecimalDigits times 10^−n, where n is the number of characters
     in DecimalDigits.

   * The MV of DecimalLiteral :: `.' DecimalDigits ExponentPart is the
     MV of DecimalDigits times 10^e−n, where n is the number of
     characters in DecimalDigits and e is the MV of ExponentPart.

   * The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of
     DecimalIntegerLiteral.

   * The MV of DecimalLiteral :: DecimalIntegerLiteral ExponentPart is
     the MV of DecimalIntegerLiteral times 10^e, where e is the MV of
     ExponentPart.

   * The MV of DecimalIntegerLiteral :: `0' is 0.

   * The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits is
     (the MV of NonZeroDigit times 10^n) plus the MV of DecimalDigits,
     where n is the number of characters in DecimalDigits.

   * The MV of DecimalDigits :: DecimalDigit is the MV of DecimalDigit.

   * The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the MV
     of DecimalDigits times 10) plus the MV of DecimalDigit.

   * The MV of ExponentPart :: ExponentIndicator SignedInteger is the
     MV of SignedInteger.

   * The MV of SignedInteger :: DecimalDigits is the MV of
     DecimalDigits.

   * The MV of SignedInteger :: `+' DecimalDigits is the MV of
     DecimalDigits.

   * The MV of SignedInteger :: `-' DecimalDigits is the negative of
     the MV of DecimalDigits.

   * The MV of DecimalDigit :: `0' or of HexDigit :: `0' is 0.

   * The MV of DecimalDigit :: `1' or of NonZeroDigit :: `1' or of
     HexDigit :: `1' is 1.

   * The MV of DecimalDigit :: `2' or of NonZeroDigit :: `2' or of
     HexDigit :: `2' is 2.

   * The MV of DecimalDigit :: `3' or of NonZeroDigit :: `3' or of
     HexDigit :: `3' is 3.

   * The MV of DecimalDigit :: `4' or of NonZeroDigit :: `4' or of
     HexDigit :: `4' is 4.

   * The MV of DecimalDigit :: `5' or of NonZeroDigit :: `5' or of
     HexDigit :: `5' is 5.

   * The MV of DecimalDigit :: `6' or of NonZeroDigit :: `6' or of
     HexDigit :: `6' is 6.

   * The MV of DecimalDigit :: `7' or of NonZeroDigit :: `7' or of
     HexDigit :: `7' is 7.

   * The MV of DecimalDigit :: `8' or of NonZeroDigit :: `8' or of
     HexDigit :: `8' is 8.

   * The MV of DecimalDigit :: `9' or of NonZeroDigit :: `9' or of
     HexDigit :: `9' is 9.

   * The MV of HexDigit :: `a' or of HexDigit :: `A' is 10.

   * The MV of HexDigit :: `b' or of HexDigit :: `B' is 11.

   *   * The MV of HexDigit :: `d' or of HexDigit :: `D' is 13.

   * The MV of HexDigit :: `e' or of HexDigit :: `E' is 14.

   * The MV of HexDigit :: `f' or of HexDigit :: `F' is 15.

   * The MV of HexIntegerLiteral :: `0x' HexDigit is the MV of HexDigit.

   * The MV of HexIntegerLiteral :: `0X' HexDigit is the MV of HexDigit.

   * The MV of HexIntegerLiteral :: HexIntegerLiteral HexDigit is (the
     MV of HexIntegerLiteral times 16) plus the MV of HexDigit.

   Once the exact MV for a numeric literal has been determined, it is
then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0; otherwise, the rounded value must be the Number
value for (#sec-8.5) the MV (as specified in 8.5 (#sec-8.5)), unless
the literal is a DecimalLiteral and the literal has more than 20
significant digits, in which case the Number value may be either the
Number value for the MV of a literal produced by replacing each
significant digit after the 20th with a `0' digit or the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a `0' digit and then incrementing the literal at
the 20th significant digit position. A digit is significant if it is
not part of an ExponentPart and

   * it is not `0'; or

   * there is a nonzero digit to its left and there is a nonzero digit,
     not in the ExponentPart, to its right.

   A conforming implementation, when processing strict mode code (see
10.1.1) (#sec-10.1.1), must not extend the syntax of NumericLiteral to
include OctalIntegerLiteral as described in B.1.1 (#sec-B.1.1).


File: javascript_ecma_262_5th_ed.info,  Node: 784 String Literals,  Next: 785 Regular Expression Literals,  Prev: 783 Numeric Literals,  Up: Top

69 7.8.4 (#sec-7.8.4) String Literals
*************************************

A string literal is zero or more characters enclosed in single or
double quotes. Each character may be represented by an escape sequence.
All characters may appear literally in a string literal except for the
closing quote character, backslash, carriage return, line separator,
paragraph separator, and line feed. Any character may appear in the
form of an escape sequence.

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 784 String Literals

69.1 Syntax
===========

StringLiteral :: `"' DoubleStringCharacters_opt_ `"' `''
SingleStringCharacters_opt_ `'' DoubleStringCharacters ::
DoubleStringCharacter DoubleStringCharacters_opt_
SingleStringCharacters :: SingleStringCharacter
SingleStringCharacters_opt_ DoubleStringCharacter :: SourceCharacter
but not double-quote `"' or backslash `\' or LineTerminator `\'
EscapeSequence LineContinuation SingleStringCharacter ::
SourceCharacter but not single-quote `?' or backslash `\' or
LineTerminator `\' EscapeSequence LineContinuation LineContinuation ::
`\' LineTerminatorSequence

   EscapeSequence :: CharacterEscapeSequence `0' [lookahead ∉
(#def-lookahead-notin) DecimalDigit] HexEscapeSequence
UnicodeEscapeSequence CharacterEscapeSequence :: SingleEscapeCharacter
NonEscapeCharacter SingleEscapeCharacter :: one of `?  "  \  b  f  n  r
t  v' NonEscapeCharacter :: SourceCharacter but not EscapeCharacter or
LineTerminator EscapeCharacter :: SingleEscapeCharacter DecimalDigit `x'
`u' HexEscapeSequence :: `x' HexDigit HexDigit UnicodeEscapeSequence ::
`u' HexDigit HexDigit HexDigit HexDigit The definition of the
nonterminal HexDigit is given in 7.8.3 (#sec-7.8.3). SourceCharacter is
defined in clause 6 (#sec-6).


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 784 String Literals

69.2 Semantics
==============

A string literal stands for a value of the String type. The String
value (SV) of the literal is described in terms of character values
(CV) contributed by the various parts of the string literal. As part of
this process, some characters within the string literal are interpreted
as having a mathematical value (MV), as described below or in 7.8.3
(#sec-7.8.3).

   * The SV of StringLiteral :: `""' is the empty character sequence.

   * The SV of StringLiteral :: `''' is the empty character sequence.

   * The SV of StringLiteral :: `"' DoubleStringCharacters `"' is the
     SV of DoubleStringCharacters.

   * The SV of StringLiteral :: `'' SingleStringCharacters `'' is the
     SV of SingleStringCharacters.

   * The SV of DoubleStringCharacters :: DoubleStringCharacter is a
     sequence of one character, the CV of DoubleStringCharacter.

   * The SV of DoubleStringCharacters :: DoubleStringCharacter
     DoubleStringCharacters is a sequence of the CV of
     DoubleStringCharacter followed by all the characters in the SV of
     DoubleStringCharacters in order.

   * The SV of SingleStringCharacters :: SingleStringCharacter is a
     sequence of one character, the CV of SingleStringCharacter.

   * The SV of SingleStringCharacters :: SingleStringCharacter
     SingleStringCharacters is a sequence of the CV of
     SingleStringCharacter followed by all the characters in the SV of
     SingleStringCharacters in order.

   * The SV of LineContinuation :: `\' LineTerminatorSequence is the
     empty character sequence.

   * The CV of DoubleStringCharacter :: SourceCharacter but not
     double-quote `"' or backslash `\' or LineTerminator is the
     SourceCharacter character itself.

   * The CV of DoubleStringCharacter :: `\' EscapeSequence is the CV of
     the EscapeSequence.

   * The CV of SingleStringCharacter :: SourceCharacter but not
     single-quote `?' or backslash `\' or LineTerminator is the
     SourceCharacter character itself.

   * The CV of SingleStringCharacter :: `\' EscapeSequence is the CV of
     the EscapeSequence.

   * The CV of EscapeSequence :: CharacterEscapeSequence is the CV of
     the CharacterEscapeSequence.

   *   * The CV of EscapeSequence :: HexEscapeSequence is the CV of the
     HexEscapeSequence.

   * The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of the
     UnicodeEscapeSequence.

   * The CV of CharacterEscapeSequence :: SingleEscapeCharacter is the
     character whose code unit value is determined by the
     SingleEscapeCharacter according to Table 4: Table 4 — String
     Single Character Escape Sequences Escape Sequence Code Unit Value
     Name Symbol `\b' `\u0008' backspace <BS> `\t' `\u0009' horizontal
     tab <HT> `\n' `\u000A' line feed (new line) <LF> `\v' `\u000B'
     vertical tab <VT> `\f' `\u000C' form feed <FF> `\r' `\u000D'
     carriage return <CR> `\"' `\u0022' double quote `"' `\?' `\u0027'
     single quote `?' `\\' `\u005C' backslash `\'

   * The CV of CharacterEscapeSequence :: NonEscapeCharacter is the CV
     of the NonEscapeCharacter.

   * The CV of NonEscapeCharacter :: SourceCharacter but not
     EscapeCharacter or LineTerminator is the SourceCharacter character
     itself.

   * The CV of HexEscapeSequence :: `x' HexDigit HexDigit is the
     character whose code unit value is (16 times the MV of the first
     HexDigit) plus the MV of the second HexDigit.

   * The CV of UnicodeEscapeSequence :: `u' HexDigit HexDigit HexDigit
     HexDigit is the character whose code unit value is (4096 times the
     MV of the first HexDigit) plus (256 times the MV of the second
     HexDigit) plus (16 times the MV of the third HexDigit) plus the MV
     of the fourth HexDigit.

   A conforming implementation, when processing strict mode code (see
10.1.1) (#sec-10.1.1), may not extend the syntax of EscapeSequence to
include OctalEscapeSequence as described in B.1.2 (#sec-B.1.2).

   NOTE A line terminator character cannot appear in a string literal,
except as part of a LineContinuation to produce the empty character
sequence. The correct way to cause a line terminator character to be
part of the String value of a string literal is to use an escape
sequence such as `\n' or `\u000A'.


File: javascript_ecma_262_5th_ed.info,  Node: 785 Regular Expression Literals,  Next: 79 Automatic Semicolon Insertion,  Prev: 784 String Literals,  Up: Top

70 7.8.5 (#sec-7.8.5) Regular Expression Literals
*************************************************

A regular expression literal is an input element that is converted to a
RegExp object (see 15.10 (#sec-15.10)) each time the literal is
evaluated. Two regular expression literals in a program evaluate to
regular expression objects that never compare as `===' to each other
even if the two literals’ contents are identical. A RegExp object may
also be created at runtime by `new RegExp' (see 15.10.4 (#sec-15.10.4))
or calling the RegExp constructor as a function (15.10.3
(#sec-15.10.3)).

   The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of
the regular expression literal. The Strings of characters comprising
the RegularExpressionBody and the RegularExpressionFlags are passed
uninterpreted to the regular expression constructor, which interprets
them according to its own, more stringent grammar. An implementation
may extend the regular expression constructor’s grammar, but it must
not extend the RegularExpressionBody and RegularExpressionFlags
productions or the productions used by these productions.

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 785 Regular Expression Literals

70.1 Syntax
===========

RegularExpressionLiteral :: `/' RegularExpressionBody `/'
RegularExpressionFlags

   RegularExpressionBody :: RegularExpressionFirstChar
RegularExpressionChars RegularExpressionChars :: [empty]
RegularExpressionChars RegularExpressionChar RegularExpressionFirstChar
:: RegularExpressionNonTerminator but not `*' or `\' or `/' or `['
RegularExpressionBackslashSequence RegularExpressionClass
RegularExpressionChar :: RegularExpressionNonTerminator but not `\' or
`/' or `[' RegularExpressionBackslashSequence RegularExpressionClass
RegularExpressionBackslashSequence :: `\' RegularExpressionNonTerminator
RegularExpressionNonTerminator :: SourceCharacter but not LineTerminator
RegularExpressionClass :: `[' RegularExpressionClassChars `]'
RegularExpressionClassChars :: [empty] RegularExpressionClassChars
RegularExpressionClassChar RegularExpressionClassChar ::
RegularExpressionNonTerminator but not `]' or `\'
RegularExpressionBackslashSequence RegularExpressionFlags :: [empty]
RegularExpressionFlags IdentifierPart NOTE Regular expression literals
may not be empty; instead of representing an empty regular expression
literal, the characters `//' start a single-line comment. To specify an
empty regular expression, use: `/(?:)/'.


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 785 Regular Expression Literals

70.2 Semantics
==============

A regular expression literal evaluates to a value of the Object type
that is an instance of the standard built-in constructor RegExp. This
value is determined in two steps: first, the characters comprising the
regular expression’s RegularExpressionBody and RegularExpressionFlags
production expansions are collected uninterpreted into two Strings
Pattern and Flags, respectively. Then each time the literal is
evaluated, a new object is created as if by the expression `new
RegExp(<var>Pattern</var>, <var>Flags</var>)' where `RegExp' is the
standard built-in constructor with that name. The newly constructed
object becomes the value of the RegularExpressionLiteral. If the call
to `new RegExp' would generate an error as specified in 15.10.4.1
(#sec-15.10.4.1), the error must be treated as an early error (Clause
16 (#sec-16)).


File: javascript_ecma_262_5th_ed.info,  Node: 79 Automatic Semicolon Insertion,  Next: 791 Rules of Automatic Semicolon Insertion,  Prev: 785 Regular Expression Literals,  Up: Top

71 7.9 (#sec-7.9) Automatic Semicolon Insertion
***********************************************

Certain ECMAScript statements (empty statement, variable statement,
expression statement, `do'–`while' statement, `continue' statement,
`break' statement, `return' statement, and `throw' statement) must be
terminated with semicolons. Such semicolons may always appear
explicitly in the source text. For convenience, however, such
semicolons may be omitted from the source text in certain situations.
These situations are described by saying that semicolons are
automatically inserted into the source code token stream in those
situations.


File: javascript_ecma_262_5th_ed.info,  Node: 791 Rules of Automatic Semicolon Insertion,  Next: 792 Examples of Automatic Semicolon Insertion,  Prev: 79 Automatic Semicolon Insertion,  Up: Top

72 7.9.1 (#sec-7.9.1) Rules of Automatic Semicolon Insertion
************************************************************

There are three basic rules of semicolon insertion:

  1. When, as the program is parsed from left to right, a token (called
     the offending token) is encountered that is not allowed by any
     production of the grammar, then a semicolon is automatically
     inserted before the offending token if one or more of the
     following conditions is true:

        * The offending token is separated from the previous token by
          at least one LineTerminator.

        * The offending token is `}'.

  2. When, as the program is parsed from left to right, the end of the
     input stream of tokens is encountered and the parser is unable to
     parse the input token stream as a single complete ECMAScript
     Program, then a semicolon is automatically inserted at the end of
     the input stream.

  3. When, as the program is parsed from left to right, a token is
     encountered that is allowed by some production of the grammar, but
     the production is a restricted production
     (#def-restricted-production) and the token would be the first
     token for a terminal or nonterminal immediately following the
     annotation “[no LineTerminator here]
     (#def-restricted-production)” within the restricted production
     (and therefore such a token is called a restricted token), and the
     restricted token is separated from the previous token by at least
     one LineTerminator, then a semicolon is automatically inserted
     before the restricted token.


   However, there is an additional overriding condition on the
preceding rules: a semicolon is never inserted automatically if the
semicolon would then be parsed as an empty statement or if that
semicolon would become one of the two semicolons in the header of a
`for' statement (see 12.6.3 (#sec-12.6.3)).

   NOTE The following are the only restricted productions in the
grammar:

   PostfixExpression : LeftHandSideExpression [no LineTerminator here]
(#def-restricted-production) `++' LeftHandSideExpression [no
LineTerminator here] (#def-restricted-production) `--'
ContinueStatement : `continue' [no LineTerminator here]
(#def-restricted-production) Identifier_opt_ `;' BreakStatement :
`break' [no LineTerminator here] (#def-restricted-production)
Identifier_opt_ `;' ReturnStatement : `return' [no LineTerminator here]
(#def-restricted-production) Expression_opt_ `;' ThrowStatement :
`throw' [no LineTerminator here] (#def-restricted-production)
Expression `;' The practical effect of these restricted productions is
as follows:

   When a `++' or `--' token is encountered where the parser would
treat it as a postfix operator, and at least one LineTerminator
occurred between the preceding token and the `++' or `--' token, then a
semicolon is automatically inserted before the `++' or `--' token.

   When a `continue', `break', `return', or `throw' token is
encountered and a LineTerminator is encountered before the next token,
a semicolon is automatically inserted after the `continue', `break',
`return', or `throw' token.

   The resulting practical advice to ECMAScript programmers is:

   A postfix `++' or `--' operator should appear on the same line as
its operand.

   An Expression in a `return' or `throw' statement should start on the
same line as the `return' or `throw' token.

   An Identifier in a `break' or `continue' statement should be on the
same line as the `break' or `continue' token.


File: javascript_ecma_262_5th_ed.info,  Node: 792 Examples of Automatic Semicolon Insertion,  Next: 8 Types,  Prev: 791 Rules of Automatic Semicolon Insertion,  Up: Top

73 7.9.2 (#sec-7.9.2) Examples of Automatic Semicolon Insertion
***************************************************************

The source

{ 1 2 } 3

   is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

{ 1
2 } 3

   is also not a valid ECMAScript sentence, but is transformed by
automatic semicolon insertion into the following:

{ 1
;2 ;} 3;

   which is a valid ECMAScript sentence.

   The source

for (a; b
)

   is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
`for' statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a `for' statement.

   The source

return
a + b

   is transformed by automatic semicolon insertion into the following:

return;
a + b;

   NOTE The expression `a +   b' is not treated as a value to be
returned by the `return' statement, because a LineTerminator separates
it from the token `return'.

   The source

a = b
++c

   is transformed by automatic semicolon insertion into the following:

a = b;
++c;

   NOTE The token `++' is not treated as a postfix operator applying to
the variable `b', because a LineTerminator occurs between `b' and `++'.

   The source

if (a > b)
else c = d

   is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the `else' token, even though no production
of the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

   The source

a = b + c
(d + e).print()

   is _not_ transformed by automatic semicolon insertion, because the
parenthesised expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

   In the circumstance that an assignment statement must begin with a
left parenthesis, it is a good idea for the programmer to provide an
explicit semicolon at the end of the preceding statement rather than to
rely on automatic semicolon insertion.


File: javascript_ecma_262_5th_ed.info,  Node: 8 Types,  Next: 81 The Undefined Type,  Prev: 792 Examples of Automatic Semicolon Insertion,  Up: Top

74 8 (#sec-8) Types
*******************

Algorithms within this specification manipulate values each of which
has an associated type. The possible value types are exactly those
defined in this clause. Types are further subclassified into ECMAScript
language types and specification types.

   An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Number, and Object.

   A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference
(#sec-8.7), List (#sec-8.8), Completion (#sec-8.9), Property Descriptor
(#sec-8.10), Property Identifier (#def-property-identifier), Lexical
Environment (#sec-10.2), and Environment Record (#sec-10.2.1).
Specification type values are specification artefacts that do not
necessarily correspond to any specific entity within an ECMAScript
implementation. Specification type values may be used to describe
intermediate results of ECMAScript expression evaluation but such
values cannot be stored as properties of objects or values of
ECMAScript language variables.

   Within this specification, the notation “Type(x)” is used as
shorthand for “the type of x” where “type” refers to the
ECMAScript language and specification types defined in this clause.


File: javascript_ecma_262_5th_ed.info,  Node: 81 The Undefined Type,  Next: 82 The Null Type,  Prev: 8 Types,  Up: Top

75 8.1 (#sec-8.1) The Undefined Type
************************************

The Undefined type has exactly one value, called undefined. Any
variable that has not been assigned a value has the value undefined.


File: javascript_ecma_262_5th_ed.info,  Node: 82 The Null Type,  Next: 83 The Boolean Type,  Prev: 81 The Undefined Type,  Up: Top

76 8.2 (#sec-8.2) The Null Type
*******************************

The Null type has exactly one value, called null.


File: javascript_ecma_262_5th_ed.info,  Node: 83 The Boolean Type,  Next: 84 The String Type,  Prev: 82 The Null Type,  Up: Top

77 8.3 (#sec-8.3) The Boolean Type
**********************************

The Boolean type represents a logical entity having two values, called
true and false.


File: javascript_ecma_262_5th_ed.info,  Node: 84 The String Type,  Next: 85 The Number Type,  Prev: 83 The Boolean Type,  Up: Top

78 8.4 (#sec-8.4) The String Type
*********************************

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type
is generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a code
unit value (see Clause 6 (#sec-6)). Each element is regarded as
occupying a position within the sequence. These positions are indexed
with nonnegative integers. The first element (if any) is at position 0,
the next element (if any) at position 1, and so on. The length of a
String is the number of elements (i.e., 16-bit values) within it. The
empty String has length zero and therefore contains no elements.

   When a String contains actual textual data, each element is
considered to be a single UTF-16 code unit. Whether or not this is the
actual storage format of a String, the characters within a String are
numbered by their initial code unit element position as though they
were represented using UTF-16. All operations on Strings (except as
otherwise stated) treat them as sequences of undifferentiated 16-bit
unsigned integers; they do not ensure the resulting String is in
normalised form, nor do they ensure language-sensitive results.

   NOTE The rationale behind this design was to keep the implementation
of Strings as simple and high-performing as possible. The intent is
that textual data coming into the execution environment from outside
(e.g., user input, text read from a file or received over the network,
etc.) be converted to Unicode Normalised Form C before the running
program


File: javascript_ecma_262_5th_ed.info,  Node: 85 The Number Type,  Next: 86 The Object Type,  Prev: 84 The String Type,  Up: Top

79 8.5 (#sec-8.5) The Number Type
*********************************

The Number type has exactly 18437736874454810627 (that is,
2^64−2^53+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NaN value. (Note that the
NaN value is produced by the program expression NaN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

   There are two other special values, called positive Infinity and
negative Infinity. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note
that these two infinite Number values are produced by the program
expressions `+Infinity' (or simply `Infinity') and `-Infinity'.)

   The other 18437736874454810624 (that is, 2^64−2^53) values are
called the finite numbers. Half of these are positive numbers and half
are negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

   Note that there is both a positive zero and a negative zero. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different
zero Number values are produced by the program expressions `+0' (or
simply `0') and `−0'.)

   The 18437736874454810622 (that is, 2^64−2^53−2) finite nonzero
values are of two kinds:

   18428729675200069632 (that is, 2^64−2^54) of them are normalised,
having the form

   s × m × 2^e

   where s is +1 or −1, m is a positive integer less than 2^53 but
not less than 2^52, and e is an integer ranging from −1074 to 971,
inclusive.

   The remaining 9007199254740990 (that is, 2^53−2) values are
denormalised, having the form

   s × m × 2^e

   where s is +1 or −1, m is a positive integer less than 2^52, and e
is −1074.

   Note that all the positive and negative integers whose magnitude is
no greater than 2^53 are representable in the Number type (indeed, the
integer 0 has two representations, +0 and −0).

   A finite number has an odd significand if it is nonzero and the
integer m used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an even significand.

   In this specification, the phrase “the Number value for x” where
x represents an exact nonzero real mathematical quantity (which might
even be an irrational number such as π) means a Number value chosen in
the following manner. Consider the set of all finite values of the
Number type, with −0 removed and with two additional values added to
it that are not representable in the Number type, namely 2^1024 (which
is +1 × 2^53 × 2^971) and −2^1024 (which is −1 × 2^53 × 2^971).
Choose the member of this set that is closest in value to x. If two
values of the set are equally close, then the one with an even
significand is chosen; for this purpose, the two extra values 2^1024
and −2^1024 are considered to have even significands. Finally, if
2^1024 was chosen, replace it with +∞; if −2^1024 was chosen,
replace it with −∞; if +0 was chosen, replace it with −0 if and
only if x is less than zero; any other chosen value is used unchanged.
The result is the Number value for x. (This procedure corresponds
exactly to the behaviour of the IEEE 754 “round to nearest” mode.)

   Some ECMAScript operators deal only with integers in the range
−2^31 through 2^31−1, inclusive, or in the range 0 through
2^32−1, inclusive. These operators accept any value of the Number
type but first convert each such value to one of 2^32 integer values.
See the descriptions of the ToInt32 (#sec-9.5) and ToUint32 (#sec-9.6)
operators in 9.5 (#sec-9.5) and 9.6 (#sec-9.6), respectively.


File: javascript_ecma_262_5th_ed.info,  Node: 86 The Object Type,  Next: 861 Property Attributes,  Prev: 85 The Number Type,  Up: Top

80 8.6 (#sec-8.6) The Object Type
*********************************

An Object is a collection of properties. Each property is either a
named data property, a named accessor property, or an internal property:

   * A named data property associates a name with an ECMAScript
     language value and a set of Boolean attributes.

   * A named accessor property associates a name with one or two
     accessor functions, and a set of Boolean attributes. The accessor
     functions are used to store or retrieve an ECMAScript language
     value that is associated with the property.

   * An internal property has no name and is not directly accessible
     via ECMAScript language operators. Internal properties exist
     purely for specification purposes.

   There are two kinds of access for named (non-internal) properties:
_get_ and _put_, corresponding to retrieval and assignment,
respectively.


File: javascript_ecma_262_5th_ed.info,  Node: 861 Property Attributes,  Next: 862 Object Internal Properties and Methods,  Prev: 86 The Object Type,  Up: Top

81 8.6.1 (#sec-8.6.1) Property Attributes
*****************************************

Attributes are used in this specification to define and explain the
state of named properties. A named data property associates a name with
the attributes listed in Table 5:

   Table 5 — Attributes of a Named Data Property Attribute Name Value
Domain Description [[Value]] Any ECMAScript language type The value
retrieved by reading the property.  [[Writable]] Boolean If false,
attempts by ECMAScript code to change the property’s [[Value]]
attribute using [[Put]] will not succeed.  [[Enumerable]] Boolean If
true, the property will be enumerated by a for-in enumeration (see
12.6.4 (#sec-12.6.4)). Otherwise, the property is said to be
non-enumerable.  [[Configurable]] Boolean If false, attempts to delete
the property, change the property to be an accessor property, or change
its attributes (other than [[Value]]) will fail.  A named accessor
property associates a name with the attributes listed in Table 6.

   Attribute Name Value Domain Description [[Get]] Object or Undefined
If the value is an Object it must be a function Object. The
function’s [[Call]] internal method (8.6.2 (#sec-8.6.2)) is called
with an empty arguments list to return the property value each time a
get access of the property is performed.  [[Set]] Object or Undefined
If the value is an Object it must be a function Object. The
function’s [[Call]] internal method (8.6.2 (#sec-8.6.2)) is called
with an arguments list containing the assigned value as its sole
argument each time a set access of the property is performed. The
effect of a property’s [[Set]] internal method may, but is not
required to, have an effect on the value returned by subsequent calls
to the property’s [[Get]] internal method.  [[Enumerable]] Boolean If
true, the property is to be enumerated by a for-in enumeration (see
12.6.4 (#sec-12.6.4)). Otherwise, the property is said to be
non-enumerable.  [[Configurable]] Boolean If false, attempts to delete
the property, change the property to be a data property, or change its
attributes will fail.  If the value of an attribute is not explicitly
specified by this specification for a named property, the default value
defined in Table 7 is used.

   Table 7 — Default Attribute Values Attribute Name Default Value
[[Value]] undefined [[Get]] undefined [[Set]] undefined [[Writable]]
false [[Enumerable]] false [[Configurable]] false


File: javascript_ecma_262_5th_ed.info,  Node: 862 Object Internal Properties and Methods,  Next: 87 The Reference Specification Type,  Prev: 861 Property Attributes,  Up: Top

82 8.6.2 (#sec-8.6.2) Object Internal Properties and Methods
************************************************************

This specification uses various internal properties to define the
semantics of object values. These internal properties are not part of
the ECMAScript language. They are defined by this specification purely
for expository purposes. An implementation of ECMAScript must behave as
if it produced and operated upon internal properties in the manner
described here. The names of internal properties are enclosed in double
square brackets [[ ]]. When an algorithm uses an internal property of
an object and the object does not implement the indicated internal
property, a TypeError exception is thrown.

   The Table 8 summarises the internal properties used by this
specification that are applicable to all ECMAScript objects. The Table
9 summarises the internal properties used by this specification that
are only applicable to some ECMAScript objects. The descriptions in
these tables indicates their behaviour for native ECMAScript objects,
unless stated otherwise in this document for particular kinds of native
ECMAScript objects. Host objects may support these internal properties
with any implementation-dependent behaviour as long as it is consistent
with the specific host object restrictions stated in this document.

   The “Value Type Domain” columns of the following tables define
the types of values associated with internal properties. The type names
refer to the types defined in Clause 8 (#sec-8) augmented by the
following additional names. “any” means the value may be any
ECMAScript language type. “primitive” means Undefined, Null,
Boolean, String, or Number. “SpecOp” means the internal property is
an internal method, an implementation provided procedure defined by an
abstract operation specification. “SpecOp” is followed by a list of
descriptive

   Table 8 — Internal Properties Common to All Objects Internal
Property Value Type Domain Description [[Prototype]] Object or Null The
prototype of this object.  [[Class]] String A String value indicating a
specification defined classification of objects.  [[Extensible]] Boolean
If true, own properties may be added to the object.  [[Get]]
SpecOp(propertyName) → any Returns the value of the named property.
[[GetOwnProperty]] SpecOp (propertyName) → Undefined or Property
Descriptor (#sec-8.10) Returns the Property Descriptor (#sec-8.10) of
the named own property of this object, or undefined if absent.
[[GetProperty]] SpecOp (propertyName) → Undefined or Property
Descriptor (#sec-8.10) Returns the fully populated
(#def-fully-populated) Property Descriptor (#sec-8.10) of the named
property of this object, or undefined if absent.  [[Put]] SpecOp
(propertyName, any, Boolean) Sets the specified named property to the
value of the second parameter. The flag controls failure handling.
[[CanPut]] SpecOp (propertyName) → Boolean Returns a Boolean value
indicating whether a [[Put]] operation with PropertyName can be
performed.  [[HasProperty]] SpecOp (propertyName) → Boolean Returns a
Boolean value indicating whether the object already has a property with
the given name.  [[Delete]] SpecOp (propertyName, Boolean) → Boolean
Removes the specified named own property from the object. The flag
controls failure handling.  [[DefaultValue]] SpecOp (Hint) → primitive
Hint is a String. Returns a default value for the object.
[[DefineOwnProperty]] SpecOp (propertyName, PropertyDescriptor,
Boolean) → Boolean Creates or alters the named own property to have
the state described by a Property Descriptor (#sec-8.10). The flag
controls failure handling.  Every object (including host objects) must
implement all of the internal properties listed in Table 8. However,
the [[DefaultValue]] internal method may, for some objects, simply
throw a TypeError exception.

   All objects have an internal property called [[Prototype]]. The
value of this property is either null or an object and is used for
implementing inheritance. Whether or not a native object can have a
host object as its [[Prototype]] depends on the implementation. Every
[[Prototype]] chain must have finite length (that is, starting from any
object, recursively accessing the [[Prototype]] internal property must
eventually lead to a null value). Named data properties of the
[[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for put access.
Named accessor properties are inherited for both get access and put
access.

   Every ECMAScript object has a Boolean-valued [[Extensible]] internal
property that controls whether or not named properties may be added to
the object. If the value of the [[Extensible]] internal property is
false then additional named properties may not be added to the object.
In addition, if [[Extensible]] is false the value of the [[Class]] and
[[Prototype]] internal properties of the object may not be modified.
Once the value of an [[Extensible]] internal property has been set to
false it may not be subsequently changed to true.

   NOTE This specification defines no ECMAScript language operators or
built-in functions that permit a program to modify an object’s
[[Class]] or [[Prototype]] internal properties or to change the value
of [[Extensible]] from false to true.

   The value of the [[Class]] internal property is defined by this
specification for every kind of built-in object. The value of the
[[Class]] internal property of a host object may be any String value
except one of "Arguments", "Array", "Boolean", "Date", "Error",
"Function", "JSON", "Math", "Number", "Object", "RegExp", and "String".
The value of a [[Class]] internal property is used internally to
distinguish different kinds of objects. Note that this specification
does not provide any means for a program to access that value except
through Object.prototype.toString (see 15.2.4.2) (#sec-15.2.4.2).

   Unless otherwise specified, the common internal methods of native
ECMAScript objects behave as described in 8.12 (#sec-8.12). Array
objects have a slightly different implementation of the
[[DefineOwnProperty]] internal method (see 15.4.5.1 (#sec-15.4.5.1))
and String objects have a slightly different implementation of the
[[GetOwnProperty]] internal method (see 15.5.5.2 (#sec-15.5.5.2)).
Arguments objects (10.6 (#sec-10.6)) have different implementations of
[[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]].
Function objects (15.3 (#sec-15.3)) have a different implementation of
[[Get]].

   Host objects may implement these internal methods in any manner
unless specified otherwise; for example, one possibility is that
[[Get]] and [[Put]] for a particular host object indeed fetch and store
property values but [[HasProperty]] always generates false. However, if
any specified manipulation of a host object’s internal properties is
not supported by an implementation, that manipulation must throw a
TypeError exception when attempted.

   The [[GetOwnProperty]] internal method of a host object must conform
to the following invariants for each property of the host object:

   * If a property is described as a data property and it may return
     different values over time, then either or both of the
     [[Writable]] and [[Configurable]] attributes must be true even if
     no mechanism to change the value is exposed via the other internal
     methods.

   * If a property is described as a data property and its [[Writable]]
     and [[Configurable]] are both false, then the SameValue (according
     to 9.12) (#sec-9.12) must be returned for the [[Value]] attribute
     of the property on all calls to [[GetOwnProperty]].

   * If the attributes other than [[Writable]] may change over time or
     if the property might disappear, then the [[Configurable]]
     attribute must be true.

   * If the [[Writable]] attribute may change from false to true, then
     the [[Configurable]] attribute must be true.

   * If the value of the host object’s [[Extensible]] internal
     property is has been observed by ECMAScript code to be false, then
     if a call to [[GetOwnProperty]] describes a property as
     non-existent all subsequent calls must also describe that property
     as non-existent.


   The [[DefineOwnProperty]] internal method of a host object must not
permit the addition of a new property to a host object if the
[[Extensible]] internal property of that host object has been observed
by ECMAScript code to be false.

   If the [[Extensible]] internal property of that host object has been
observed by ECMAScript code to be false then it must not subsequently
become true.

   Internal Property Value Type Domain Description [[PrimitiveValue]]
primitive Internal state information associated with this object. Of
the standard built-in ECMAScript objects, only Boolean, Date, Number,
and String objects implement [[PrimitiveValue]].  [[Construct]]
SpecOp(a List (#sec-8.8) of any) → Object Creates an object. Invoked
via the `new' operator. The arguments to the SpecOp are the arguments
passed to the `new' operator. Objects that implement this internal
method are called constructors.  [[Call]] SpecOp(any, a List (#sec-8.8)
of any) → any or Reference (#sec-8.7) Executes code associated with
the object. Invoked via a function call expression. The arguments to
the SpecOp are a this object and a list containing the arguments passed
to the function call expression. Objects that implement this internal
method are callable. Only callable objects that are host objects may
return Reference (#sec-8.7) values.  [[HasInstance]] SpecOp(any) →
Boolean Returns a Boolean value indicating whether the argument is
likely an Object that was constructed by this object. Of the standard
built-in ECMAScript objects, only Function objects implement
[[HasInstance]].  [[Scope]] Lexical Environment (#sec-10.2) A lexical
environment (#sec-10.2) that defines the environment in which a
Function object is executed. Of the standard built-in ECMAScript
objects, only Function objects implement [[Scope]].
[[FormalParameters]] List (#sec-8.8) of Strings A possibly empty List
(#sec-8.8) containing the identifier Strings of a Function’s
FormalParameterList. Of the standard built-in ECMAScript objects, only
Function objects implement [[FormalParameters]].  [[Code]] ECMAScript
code The ECMAScript code of a function. Of the standard built-in
ECMAScript objects, only Function objects implement [[Code]].
[[TargetFunction]] Object The target function of a function object
created using the standard built-in Function.prototype.bind
(#sec-15.3.4.5) method. Only ECMAScript objects created using
Function.prototype.bind (#sec-15.3.4.5) have a [[TargetFunction]]
internal property.  [[BoundThis]] any The pre-bound this value of a
function Object created using the standard built-in
Function.prototype.bind (#sec-15.3.4.5) method. Only ECMAScript objects
created using Function.prototype.bind (#sec-15.3.4.5) have a
[[BoundThis]] internal property.  [[BoundArguments]] List (#sec-8.8) of
any The pre-bound argument values of a function Object created using
the standard built-in Function.prototype.bind (#sec-15.3.4.5) method.
Only ECMAScript objects created using Function.prototype.bind
(#sec-15.3.4.5) have a [[BoundArguments]] internal property.  [[Match]]
SpecOp(String, index) → MatchResult Tests for a regular expression
match and returns a MatchResult value (see 15.10.2.1 (#sec-15.10.2.1)).
Of the standard built-in ECMAScript objects, only RegExp objects
implement [[Match]].  [[ParameterMap]] Object Provides a mapping
between the properties of an arguments object (see 10.6 (#sec-10.6))
and the formal parameters of the associated function. Only ECMAScript
objects that are arguments objects have a [[ParameterMap]] internal
property.


File: javascript_ecma_262_5th_ed.info,  Node: 87 The Reference Specification Type,  Next: 871 GetValue V,  Prev: 862 Object Internal Properties and Methods,  Up: Top

83 8.7 (#sec-8.7) The Reference Specification Type
**************************************************

The Reference type is used to explain the behaviour of such operators
as `delete', `typeof', and the assignment operators. For example, the
left-hand operand of an assignment is expected to produce a

   A *Reference* is a resolved name binding. A Reference consists of
three components, the base value, the referenced name and the Boolean
valued strict reference flag. The base value is either undefined, an
Object, a Boolean, a String, a Number, or an environment record
(10.2.1) (#sec-10.2.1). A base value of undefined indicates that the
reference could not be resolved to a binding. The referenced name is a
String.

   The following abstract operations are used in this specification to
access the components of references:

   * GetBase(V). Returns the base value component of the reference V.

   * GetReferencedName(V). Returns the referenced name component of the
     reference V.

   * IsStrictReference(V). Returns the strict reference component of
     the reference V.

   * HasPrimitiveBase(V). Returns true if the base value is a Boolean,
     String, or Number.

   * IsPropertyReference(V). Returns true if either the base value is
     an object or HasPrimitiveBase(V) is true; otherwise returns false.

   * IsUnresolvableReference(V). Returns true if the base value is
     undefined and false otherwise.


   The following abstract operations are used in this specification to
operate on references:


File: javascript_ecma_262_5th_ed.info,  Node: 871 GetValue V,  Next: 872 PutValue V W,  Prev: 87 The Reference Specification Type,  Up: Top

84 8.7.1 (#sec-8.7.1) GetValue (V)
**********************************

  1. If Type (#def-type)(V) is not Reference (#sec-8.7), return V.

  2. Let base be the result of calling GetBase (#def-GetBase)(V).

  3. If IsUnresolvableReference (#def-IsUnresolvableReference)(V),
     throw a ReferenceError exception.

  4. If IsPropertyReference (#def-IsPropertyReference)(V), then
       1. If HasPrimitiveBase (#def-HasPrimitiveBase)(V) is false, then
          let get be the [[Get]] internal method of base, otherwise let
          get be the special [[Get]] internal method defined below.

       2. Return the result of calling the get internal method using
          base as its this value, and passing GetReferencedName
          (#def-GetReferencedName)(V) for the argument.

  5. Else, base must be an environment record (#sec-10.2.1).
       1. Return the result of calling the GetBindingValue (see 10.2.1
          (#sec-10.2.1)) concrete method of base passing
          GetReferencedName (#def-GetReferencedName)(V) and
          IsStrictReference (#def-IsStrictReference)(V) as arguments.


   The following [[Get]] internal method is used by GetValue when V is
a property reference (#def-IsPropertyReference) with a primitive base
value. It is called using base as its this value and with property P as
its argument. The following steps are taken:

  1. Let O be ToObject (#sec-9.9)(base).

  2. Let desc be the result of calling the [[GetProperty]] internal
     method of O with property name P.

  3. If desc is undefined, return undefined.

  4. If IsDataDescriptor (#def-IsDataDescriptor)(desc) is true, return
     desc.[[Value]].

  5. Otherwise, IsAccessorDescriptor (#def-IsAccessorDescriptor)(desc)
     must be true so, let getter be desc.[[Get]].

  6. If getter is undefined, return undefined.

  7. Return the result calling the [[Call]] internal method of getter
     providing base as the this value and providing no arguments.

   NOTE The object that may be created in step 1 is not accessible
outside of the above method. An implementation might choose to avoid
the actual creation of the object. The only situation where such an
actual property access that uses this internal method can have visible
effect is when it invokes an accessor function.


File: javascript_ecma_262_5th_ed.info,  Node: 872 PutValue V W,  Next: 88 The List Specification Type,  Prev: 871 GetValue V,  Up: Top

85 8.7.2 (#sec-8.7.2) PutValue (V, W)
*************************************

  1. If Type (#def-type)(V) is not Reference (#sec-8.7), throw a
     ReferenceError exception.

  2. Let base be the result of calling GetBase (#def-GetBase)(V).

  3. If IsUnresolvableReference (#def-IsUnresolvableReference)(V), then
       1. If IsStrictReference (#def-IsStrictReference)(V) is true, then
            1. Throw a ReferenceError exception.

       2. Call the [[Put]] internal method of the global object,
          passing GetReferencedName (#def-GetReferencedName)(V) for the
          property name, W for the value, and false for the Throw flag.

  4. Else if IsPropertyReference (#def-IsPropertyReference)(V), then
       1. If HasPrimitiveBase (#def-HasPrimitiveBase)(V) is false, then
          let put be the [[Put]] internal method of base, otherwise let
          put be the special [[Put]] internal method defined below.

       2. Call the put internal method using base as its this value,
          and passing GetReferencedName (#def-GetReferencedName)(V) for
          the property name, W for the value, and IsStrictReference
          (#def-IsStrictReference)(V) for the Throw flag.

  5. Else base must be a reference whose base is an environment record
     (#sec-10.2.1). So,
       1. Call the SetMutableBinding (10.2.1 (#sec-10.2.1)) concrete
          method of base, passing GetReferencedName
          (#def-GetReferencedName)(V), W, and IsStrictReference
          (#def-IsStrictReference)(V) as arguments.

  6. Return.

   The following [[Put]] internal method is used by PutValue when V is
a property reference (#def-IsPropertyReference) with a primitive base
value. It is called using base as its this value and with property P,
value W, and Boolean flag Throw as arguments. The following steps are
taken:

  1. Let O be ToObject (#sec-9.9)(base).

  2. If the result of calling the [[CanPut]] internal method of O with
     argument P is false, then
       1. If Throw is true, then throw a TypeError exception.

       2. Else return.

  3. Let ownDesc be the result of calling the [[GetOwnProperty]]
     internal method of O with argument P.

  4. If IsDataDescriptor (#def-IsDataDescriptor)(ownDesc) is true, then
       1. If Throw is true, then throw a TypeError exception.

       2. Else Return.

  5. Let desc be the result of calling the [[GetProperty]] internal
     method of O with argument P. This may be either an own or
     inherited accessor property descriptor
     (#def-accessor-property-descriptor) or an inherited data property
     descriptor (#def-data-property-descriptor).

  6. If IsAccessorDescriptor (#def-IsAccessorDescriptor)(desc) is true,
     then
       1. Let setter be desc.[[Set]] which cannot be undefined.

       2. Call the [[Call]] internal method of setter providing base as
          the this value and an argument list containing only W.

  7. Else, this is a request to create an own property on the transient
     object O
       1. If Throw is true, then throw a TypeError exception.

  8. Return.

   NOTE The object that may be created in step 1 is not accessible
outside of the above method. An implementation might choose to avoid
the actual creation of that transient object. The only situations where
such an actual property assignment that uses this internal method can
have visible effect are when it either invokes an accessor function or
is in violation of a Throw predicated error check. When Throw is true
any property assignment that would create a new property on the
transient object throws an error.


File: javascript_ecma_262_5th_ed.info,  Node: 88 The List Specification Type,  Next: 89 The Completion Specification Type,  Prev: 872 PutValue V W,  Up: Top

86 8.8 (#sec-8.8) The List Specification Type
*********************************************

The List type is used to explain the evaluation of argument lists (see
11.2.4 (#sec-11.2.4)) in `new' expressions, in function calls, and in
other algorithms where a simple list of values is needed. Values of the
List type are simply ordered sequences of values. These sequences may
be of any length.


File: javascript_ecma_262_5th_ed.info,  Node: 89 The Completion Specification Type,  Next: 810 The Property Descriptor and Property Identifier Specification Types,  Prev: 88 The List Specification Type,  Up: Top

87 8.9 (#sec-8.9) The Completion Specification Type
***************************************************

The Completion type is used to explain the behaviour of statements
(break, continue, return and throw) that perform nonlocal transfers of
control. Values of the Completion type are triples of the form (type,
value, target), where type is one of normal, break, continue, return,
or throw, value is any ECMAScript language value or empty, and target
is any ECMAScript identifier or empty.

   The term “abrupt completion” refers to any completion with a
type other than normal.


File: javascript_ecma_262_5th_ed.info,  Node: 810 The Property Descriptor and Property Identifier Specification Types,  Next: 8101 IsAccessorDescriptor Desc,  Prev: 89 The Completion Specification Type,  Up: Top

88 8.10 (#sec-8.10) The Property Descriptor and Property Identifier Specification Types
***************************************************************************************

The Property Descriptor type is used to explain the manipulation and
reification of named property attributes. Values of the Property
Descriptor type are records composed of named fields where each
field’s name is an attribute name and its value is a corresponding
attribute value as specified in 8.6.1 (#sec-8.6.1). In addition, any
field may be present or absent.

   Property Descriptor values may be further classified as data
property descriptors and accessor property descriptors based upon the
existence or use of certain fields. A data property descriptor is one
that includes any fields named either [[Value]] or [[Writable]]. An
accessor property descriptor is one that includes any fields named
either [[Get]] or [[Set]]. Any property descriptor may have fields
named [[Enumerable]] and [[Configurable]]. A Property Descriptor value
may not be both a data property descriptor and an accessor property
descriptor; however, it may be neither. A generic property descriptor
is a Property Descriptor value that is neither a data property
descriptor nor an accessor property descriptor. A fully populated
property descriptor is one that is either an accessor property
descriptor or a data property descriptor and that has all of the fields
that correspond to the property attributes defined in either 8.6.1
(#sec-8.6.1) Table 5 or Table 6.

   For notational convenience within this specification, an object
literal-like syntax can be used to define a property descriptor value.
For example, Property Descriptor {[[Value]]: 42, [[Writable]]: false,
[[Configurable]]: true} defines a data property descriptor. Field name
order is not significant. Any fields that are not explicitly listed are
considered to be absent.

   In specification text and algorithms, dot notation may be used to
refer to a specific field of a Property Descriptor. For example, if D
is a property descriptor then D.[[Value]] is shorthand for “the field
of D named [[Value]]”.

   The Property Identifier type is used to associate a property name
with a Property Descriptor. Values of the Property Identifier type are
pairs of the form (name, descriptor), where name is a String and
descriptor is a Property Descriptor value.

   The following abstract operations are used in this specification to
operate upon Property Descriptor values:


File: javascript_ecma_262_5th_ed.info,  Node: 8101 IsAccessorDescriptor Desc,  Next: 8102 IsDataDescriptor Desc,  Prev: 810 The Property Descriptor and Property Identifier Specification Types,  Up: Top

89 8.10.1 (#sec-8.10.1) IsAccessorDescriptor ( Desc )
*****************************************************

When the abstract operation IsAccessorDescriptor is called with
property descriptor Desc, the following steps are taken:

  1. If Desc is undefined, then return false.

  2. If both Desc.[[Get]] and Desc.[[Set]] are absent, then return
     false.

  3. Return true.


File: javascript_ecma_262_5th_ed.info,  Node: 8102 IsDataDescriptor Desc,  Next: 8103 IsGenericDescriptor Desc,  Prev: 8101 IsAccessorDescriptor Desc,  Up: Top

90 8.10.2 (#sec-8.10.2) IsDataDescriptor ( Desc )
*************************************************

When the abstract operation IsDataDescriptor is called with property
descriptor Desc, the following steps are taken:

  1. If Desc is undefined, then return false.

  2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, then
     return false.

  3. Return true.


File: javascript_ecma_262_5th_ed.info,  Node: 8103 IsGenericDescriptor Desc,  Next: 8104 FromPropertyDescriptor Desc,  Prev: 8102 IsDataDescriptor Desc,  Up: Top

91 8.10.3 (#sec-8.10.3) IsGenericDescriptor ( Desc )
****************************************************

When the abstract operation IsGenericDescriptor is called with property
descriptor Desc, the following steps are taken:

  1. If Desc is undefined, then return false.

  2. If IsAccessorDescriptor (#def-IsAccessorDescriptor)(Desc) and
     IsDataDescriptor (#def-IsDataDescriptor)(Desc) are both false,
     then return true.

  3. Return false.


File: javascript_ecma_262_5th_ed.info,  Node: 8104 FromPropertyDescriptor Desc,  Next: 8105 ToPropertyDescriptor Obj,  Prev: 8103 IsGenericDescriptor Desc,  Up: Top

92 8.10.4 (#sec-8.10.4) FromPropertyDescriptor ( Desc )
*******************************************************

When the abstract operation FromPropertyDescriptor is called with
property descriptor Desc, the following steps are taken:

   The following algorithm assumes that Desc is a fully populated
(#def-fully-populated) Property Descriptor (#sec-8.10), such as that
returned from [[GetOwnProperty]] (see 8.12.1 (#sec-8.12.1)).

  1. If Desc is undefined, then return undefined.

  2. Let obj be the result of creating a new object as if by the
     expression `new Object()' where `Object' is the standard built-in
     constructor with that name.

  3. If IsDataDescriptor (#def-IsDataDescriptor)(Desc) is true, then
       1. Call the [[DefineOwnProperty]] internal method of obj with
          arguments "value", Property Descriptor {[[Value]]:
          Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true,
          [[Configurable]]: true}, and false.

       2. Call the [[DefineOwnProperty]] internal method of obj with
          arguments "writable", Property Descriptor {[[Value]]:
          Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true,
          [[Configurable]]: true}, and false.

  4. Else, IsAccessorDescriptor (#def-IsAccessorDescriptor)(Desc) must
     be true, so
       1. Call the [[DefineOwnProperty]] internal method of obj with
          arguments "get", Property Descriptor {[[Value]]:
          Desc.[[Get]], [[Writable]]: true, [[Enumerable]]: true,
          [[Configurable]]: true}, and false.

       2. Call the [[DefineOwnProperty]] internal method of obj with
          arguments "set", Property Descriptor {[[Value]]:
          Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true,
          [[Configurable]]: true}, and false.

  5. Call the [[DefineOwnProperty]] internal method of obj with
     arguments "enumerable", Property Descriptor {[[Value]]:
     Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true,
     [[Configurable]]: true}, and false.

  6. Call the [[DefineOwnProperty]] internal method of obj with
     arguments "configurable", Property Descriptor {[[Value]]:
     Desc.[[Configurable]], [[Writable]]: true, [[Enumerable]]: true,
     [[Configurable]]: true}, and false.

  7. Return obj.


File: javascript_ecma_262_5th_ed.info,  Node: 8105 ToPropertyDescriptor Obj,  Next: 811 The Lexical Environment and Environment Record Specification Types,  Prev: 8104 FromPropertyDescriptor Desc,  Up: Top

93 8.10.5 (#sec-8.10.5) ToPropertyDescriptor ( Obj )
****************************************************

When the abstract operation ToPropertyDescriptor is called with object
Desc, the following steps are taken:

  1. If Type (#def-type)(Obj) is not Object throw a TypeError exception.

  2. Let desc be the result of creating a new Property Descriptor that
     initially has no fields.

  3. If the result of calling the [[HasProperty]] internal method of
     Obj with argument "enumerable" is true, then
       1. Let enum be the result of calling the [[Get]] internal method
          of Obj with "enumerable".

       2. Set the [[Enumerable]] field of desc to ToBoolean
          (#sec-9.2)(enum).

  4. If the result of calling the [[HasProperty]] internal method of
     Obj with argument "configurable" is true, then
       1. Let conf be the result of calling the [[Get]] internal method
          of Obj with argument "configurable".

       2. Set the [[Configurable]] field of desc to ToBoolean
          (#sec-9.2)(conf).

  5. If the result of calling the [[HasProperty]] internal method of
     Obj with argument "value" is true, then
       1. Let value be the result of calling the [[Get]] internal
          method of Obj with argument "value".

       2. Set the [[Value]] field of desc to value.

  6. If the result of calling the [[HasProperty]] internal method of
     Obj with argument "writable" is true, then
       1. Let writable be the result of calling the [[Get]] internal
          method of Obj with argument "writable".

       2. Set the [[Writable]] field of desc to ToBoolean
          (#sec-9.2)(writable).

  7. If the result of calling the [[HasProperty]] internal method of
     Obj with argument "get" is true, then
       1. Let getter be the result of calling the [[Get]] internal
          method of Obj with argument "get".

       2. If IsCallable (#sec-9.11)(getter) is false and getter is not
          undefined, then throw a TypeError exception.

       3. Set the [[Get]] field of desc to getter.

  8. If the result of calling the [[HasProperty]] internal method of
     Obj with argument "set" is true, then
       1. Let setter be the result of calling the [[Get]] internal
          method of Obj with argument "set".

       2. If IsCallable (#sec-9.11)(setter) is false and setter is not
          undefined, then throw a TypeError exception.

       3. Set the [[Set]] field of desc to setter.

  9. If either desc.[[Get]] or desc.[[Set]] are present, then
       1. If either desc.[[Value]] or desc.[[Writable]] are present,
          then throw a TypeError exception.

 10. Return desc.


File: javascript_ecma_262_5th_ed.info,  Node: 811 The Lexical Environment and Environment Record Specification Types,  Next: 812 Algorithms for Object Internal Methods,  Prev: 8105 ToPropertyDescriptor Obj,  Up: Top

94 8.11 (#sec-8.11) The Lexical Environment and Environment Record Specification Types
**************************************************************************************

The Lexical Environment (#sec-10.2) and Environment Record
(#sec-10.2.1) types are used to explain the behaviour of name
resolution in nested functions and blocks. These types and the
operations upon them are defined in Clause 10 (#sec-10).


File: javascript_ecma_262_5th_ed.info,  Node: 812 Algorithms for Object Internal Methods,  Next: 8121 [[GetOwnProperty]] P,  Prev: 811 The Lexical Environment and Environment Record Specification Types,  Up: Top

95 8.12 (#sec-8.12) Algorithms for Object Internal Methods
**********************************************************

In the following algorithm descriptions, assume O is a native
ECMAScript object, P is a String, Desc is a Property Description
record, and Throw is a Boolean flag.


File: javascript_ecma_262_5th_ed.info,  Node: 8121 [[GetOwnProperty]] P,  Next: 8122 [[GetProperty]] P,  Prev: 812 Algorithms for Object Internal Methods,  Up: Top

96 8.12.1 (#sec-8.12.1) [[GetOwnProperty]] (P)
**********************************************

When the [[GetOwnProperty]] internal method of O is called with
property name P, the following steps are taken:

  1. If O doesn’t have an own property with name P, return undefined.

  2. Let D be a newly created Property Descriptor (#sec-8.10) with no
     fields.

  3. Let X be O’s own property named P.

  4. If X is a data property, then
       1. Set D.[[Value]] to the value of X’s [[Value]] attribute.

       2. Set D.[[Writable]] to the value of X’s [[Writable]]
          attribute

  5. Else X is an accessor property, so
       1. Set D.[[Get]] to the value of X’s [[Get]] attribute.

       2. Set D.[[Set]] to the value of X’s [[Set]] attribute.

  6. Set D.[[Enumerable]] to the value of X’s [[Enumerable]]
     attribute.

  7. Set D.[[Configurable]] to the value of X’s [[Configurable]]
     attribute.

  8. Return D.

   However, if O is a String object it has a more elaborate
[[GetOwnProperty]] internal method defined in 15.5.5.2 (#sec-15.5.5.2).


File: javascript_ecma_262_5th_ed.info,  Node: 8122 [[GetProperty]] P,  Next: 8123 [[Get]] P,  Prev: 8121 [[GetOwnProperty]] P,  Up: Top

97 8.12.2 (#sec-8.12.2) [[GetProperty]] (P)
*******************************************

When the [[GetProperty]] internal method of O is called with property
name P, the following steps are taken:

  1. Let prop be the result of calling the [[GetOwnProperty]] internal
     method of O with property name P.

  2. If prop is not undefined, return prop.

  3. Let proto be the value of the [[Prototype]] internal property of O.

  4. If proto is null, return undefined.

  5. Return the result of calling the [[GetProperty]] internal method
     of proto with argument P.


File: javascript_ecma_262_5th_ed.info,  Node: 8123 [[Get]] P,  Next: 8124 [[CanPut]] P,  Prev: 8122 [[GetProperty]] P,  Up: Top

98 8.12.3 (#sec-8.12.3) [[Get]] (P)
***********************************

When the [[Get]] internal method of O is called with property name P,
the following steps are taken:

  1. Let desc be the result of calling the [[GetProperty]] internal
     method of O with property name P.

  2. If desc is undefined, return undefined.

  3. If IsDataDescriptor (#def-IsDataDescriptor)(desc) is true, return
     desc.[[Value]].

  4. Otherwise, IsAccessorDescriptor (#def-IsAccessorDescriptor)(desc)
     must be true so, let getter be desc.[[Get]].

  5. If getter is undefined, return undefined.

  6. Return the result calling the [[Call]] internal method of getter
     providing O as the this value and providing no arguments.


File: javascript_ecma_262_5th_ed.info,  Node: 8124 [[CanPut]] P,  Next: 8125 [[Put]] P V Throw,  Prev: 8123 [[Get]] P,  Up: Top

99 8.12.4 (#sec-8.12.4) [[CanPut]] (P)
**************************************

When the [[CanPut]] internal method of O is called with property name
P, the following steps are taken:

  1. Let desc be the result of calling the [[GetOwnProperty]] internal
     method of O with argument P.

  2. If desc is not undefined, then
       1. If IsAccessorDescriptor (#def-IsAccessorDescriptor)(desc) is
          true, then
            1.            2. Else return true.

       2. Else, desc must be a DataDescriptor so return the value of
          desc.[[Writable]].

  3. Let proto be the [[Prototype]] internal property of O.

  4. If proto is null, then return the value of the [[Extensible]]
     internal property of O.

  5. Let inherited be the result of calling the [[GetProperty]]
     internal method of proto with property name P.

  6. If inherited is undefined, return the value of the [[Extensible]]
     internal property of O.

  7. If IsAccessorDescriptor (#def-IsAccessorDescriptor)(inherited) is
     true, then
       1. If inherited.[[Set]] is undefined, then return false.

       2. Else return true.

  8. Else, inherited must be a DataDescriptor
       1. If the [[Extensible]] internal property of O is false, return
          false.

       2. Else return the value of inherited.[[Writable]].


   Host objects may define additional constraints upon [[Put]]
operations. If possible, host objects should not allow [[Put]]
operations in situations where this definition of [[CanPut]] returns
false.


File: javascript_ecma_262_5th_ed.info,  Node: 8125 [[Put]] P V Throw,  Next: 8126 [[HasProperty]] P,  Prev: 8124 [[CanPut]] P,  Up: Top

100 8.12.5 (#sec-8.12.5) [[Put]] ( P, V, Throw )
************************************************

When the [[Put]] internal method of O is called with property P, value
V, and Boolean flag Throw, the following steps are taken:

  1. If the result of calling the [[CanPut]] internal method of O with
     argument P is false, then
       1. If Throw is true, then throw a TypeError exception.

       2. Else return.

  2. Let ownDesc be the result of calling the [[GetOwnProperty]]
     internal method of O with argument P.

  3. If IsDataDescriptor (#def-IsDataDescriptor)(ownDesc) is true, then
       1. Let valueDesc be the Property Descriptor (#sec-8.10)
          {[[Value]]: V}.

       2. Call the [[DefineOwnProperty]] internal method of O passing
          P, valueDesc, and Throw as arguments.

       3. Return.

  4. Let desc be the result of calling the [[GetProperty]] internal
     method of O with argument P. This may be either an own or
     inherited accessor property descriptor
     (#def-accessor-property-descriptor) or an inherited data property
     descriptor (#def-data-property-descriptor).

  5. If IsAccessorDescriptor (#def-IsAccessorDescriptor)(desc) is true,
     then
       1. Let setter be desc.[[Set]] which cannot be undefined.

       2. Call the [[Call]] internal method of setter providing O as
          the this value and providing V as the sole argument.

  6. Else, create a named data property named P on object O as follows
       1. Let newDesc be the Property Descriptor (#sec-8.10)
          {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true,
          [[Configurable]]: true}.

       2. Call the [[DefineOwnProperty]] internal method of O passing
          P, newDesc, and Throw as arguments.

  7. Return.


File: javascript_ecma_262_5th_ed.info,  Node: 8126 [[HasProperty]] P,  Next: 8127 [[Delete]] P Throw,  Prev: 8125 [[Put]] P V Throw,  Up: Top

101 8.12.6 (#sec-8.12.6) [[HasProperty]] (P)
********************************************

When the [[HasProperty]] internal method of O is called with property
name P, the following steps are taken:

  1. Let desc be the result of calling the [[GetProperty]] internal
     method of O with property name P.

  2. If desc is undefined, then return false.

  3. Else return true.


File: javascript_ecma_262_5th_ed.info,  Node: 8127 [[Delete]] P Throw,  Next: 8128 [[DefaultValue]] hint,  Prev: 8126 [[HasProperty]] P,  Up: Top

102 8.12.7 (#sec-8.12.7) [[Delete]] (P, Throw)
**********************************************

When the [[Delete]] internal method of O is called with property name P
and the Boolean flag Throw, the following steps are taken:

  1. Let desc be the result of calling the [[GetOwnProperty]] internal
     method of O with property name P.

  2. If desc is undefined, then return true.

  3. If desc.[[Configurable]] is true, then
       1. Remove the own property with name P from O.

       2. Return true.

  4. Else if Throw, then throw a TypeError exception.

  5. Return false.


File: javascript_ecma_262_5th_ed.info,  Node: 8128 [[DefaultValue]] hint,  Next: 8129 [[DefineOwnProperty]] P Desc Throw,  Prev: 8127 [[Delete]] P Throw,  Up: Top

103 8.12.8 (#sec-8.12.8) [[DefaultValue]] (hint)
************************************************

When the [[DefaultValue]] internal method of O is called with hint
String, the following steps are taken:

  1. Let toString be the result of calling the [[Get]] internal method
     of object O with argument "toString".

  2. If IsCallable (#sec-9.11)(toString) is true then,
       1. Let str be the result of calling the [[Call]] internal method
          of toString, with O as the this value and an empty argument
          list.

       2. If str is a primitive value, return str.

  3. Let valueOf be the result of calling the [[Get]] internal method
     of object O with argument "valueOf".

  4. If IsCallable (#sec-9.11)(valueOf) is true then,
       1. Let val be the result of calling the [[Call]] internal method
          of valueOf, with O as the this value and an empty argument
          list.

       2. If val is a primitive value, return val.

  5. Throw a TypeError exception.

   When the [[DefaultValue]] internal method of O is called with hint
Number, the following steps are taken:

  1. Let valueOf be the result of calling the [[Get]] internal method
     of object O with argument "valueOf".

  2. If IsCallable (#sec-9.11)(valueOf) is true then,
       1. Let val be the result of calling the [[Call]] internal method
          of valueOf, with O as the this value and an empty argument
          list.

       2. If val is a primitive value, return val.

  3. Let toString be the result of calling the [[Get]] internal method
     of object O with argument "toString".

  4. If IsCallable (#sec-9.11)(toString) is true then,
       1. Let str be the result of calling the [[Call]] internal method
          of toString, with O as the this value and an empty argument
          list.

       2. If str is a primitive value, return str.

  5. Throw a TypeError exception.

   When the [[DefaultValue]] internal method of O is called with no
hint, then it behaves as if the hint were Number, unless O is a Date
object (see 15.9.6 (#sec-15.9.6)), in which case it behaves as if the
hint were String.

   The above specification of [[DefaultValue]] for native objects can
return only primitive values. If a host object implements its own
[[DefaultValue]] internal method, it must ensure that its
[[DefaultValue]] internal method can return only primitive values.


File: javascript_ecma_262_5th_ed.info,  Node: 8129 [[DefineOwnProperty]] P Desc Throw,  Next: 9 Type Conversion and Testing,  Prev: 8128 [[DefaultValue]] hint,  Up: Top

104 8.12.9 (#sec-8.12.9) [[DefineOwnProperty]] (P, Desc, Throw)
***************************************************************

In the following algorithm, the term “Reject” means “If Throw is
true, then throw a TypeError exception, otherwise return false”. The
algorithm contains steps that test various fields of the Property
Descriptor (#sec-8.10) Desc for specific values. The fields that are
tested in this manner need not actually exist in Desc. If a field is
absent then its value is considered to be false.

   When the [[DefineOwnProperty]] internal method of O is called with
property name P, property descriptor Desc, and Boolean flag Throw, the
following steps are taken:

  1. Let current be the result of calling the [[GetOwnProperty]]
     internal method of O with property name P.

  2. Let extensible be the value of the [[Extensible]] internal
     property of O.

  3. If current is undefined and extensible is false, then Reject
     (#def-reject-for-object).

  4. If current is undefined and extensible is true, then
       1. If IsGenericDescriptor (#def-IsGenericDescriptor)(Desc) or
          IsDataDescriptor (#def-IsDataDescriptor)(Desc) is true, then
            1. Create an own data property named P of object O whose
               [[Value]], [[Writable]], [[Enumerable]] and
               [[Configurable]] attribute values are described by Desc.
               If the value of an attribute field of Desc is absent,
               the attribute of the newly created property is set to
               its default value.

       2.            1. Create an own accessor property named P of object O
               whose [[Get]], [[Set]], [[Enumerable]] and
               [[Configurable]] attribute values are described by Desc.
               If the value of an attribute field of Desc is absent,
               the attribute of the newly created property is set to
               its default value.

       3. Return true.

  5. Return true, if every field in Desc is absent.

  6. Return true, if every field in Desc also occurs in current and the
     value of every field in Desc is the same value as the
     corresponding field in current when compared using the SameValue
     algorithm (9.12) (#sec-9.12).

  7. If the [[Configurable]] field of current is false then
       1. Reject (#def-reject-for-object), if the [[Configurable]]
          field of Desc is true.

       2. Reject (#def-reject-for-object), if the [[Enumerable]] field
          of Desc is present and the [[Enumerable]] fields of current
          and Desc are the Boolean negation of each other.

  8. If IsGenericDescriptor (#def-IsGenericDescriptor)(Desc) is true,
     then no further validation is required.

  9. Else, if IsDataDescriptor (#def-IsDataDescriptor)(current) and
     IsDataDescriptor (#def-IsDataDescriptor)(Desc) have different
     results, then
       1. Reject (#def-reject-for-object), if the [[Configurable]]
          field of current is false.

       2. If IsDataDescriptor (#def-IsDataDescriptor)(current) is true,
          then
            1. Convert the property named P of object O from a data
               property to an accessor property. Preserve the existing
               values of the converted property’s [[Configurable]]
               and [[Enumerable]] attributes and set the rest of the
               property’s attributes to their default values.

       3. Else,
            1. Convert the property named P of object O from an
               accessor property to a data property. Preserve the
               existing values of the converted property’s
               [[Configurable]] and [[Enumerable]] attributes and set
               the rest of the property’s attributes to their default
               values.


 10. Else, if IsDataDescriptor (#def-IsDataDescriptor)(current) and
     IsDataDescriptor (#def-IsDataDescriptor)(Desc) are both true, then
       1. If the [[Configurable]] field of current is false, then
            1. Reject (#def-reject-for-object), if the [[Writable]]
               field of current is false and the [[Writable]] field of
               Desc is true.

            2. If the [[Writable]] field of current is false, then
                 1. Reject (#def-reject-for-object), if the [[Value]]
                    field of Desc is present and SameValue
                    (#sec-9.12)(Desc.[[Value]], current.[[Value]]) is
                    false.


       2. else, the [[Configurable]] field of current is true, so any
          change is acceptable.

 11. Else, IsAccessorDescriptor (#def-IsAccessorDescriptor)(current)
     and IsAccessorDescriptor (#def-IsAccessorDescriptor)(Desc) are
     both true so,
       1. If the [[Configurable]] field of current is false, then
            1. Reject (#def-reject-for-object), if the [[Set]] field of
               Desc is present and SameValue (#sec-9.12)(Desc.[[Set]],
               current.[[Set]]) is false.

            2. Reject (#def-reject-for-object), if the [[Get]] field of
               Desc is present and SameValue (#sec-9.12)(Desc.[[Get]],
               current.[[Get]]) is false.


 12. For each attribute field of Desc that is present, set the
     correspondingly named attribute of the property named P of object
     O to the value of the field.

 13. Return true. However, if O is an Array object, it has a more
     elaborate [[DefineOwnProperty]] internal method defined in
     15.4.5.1 (#sec-15.4.5.1).

   NOTE Step 10.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
true. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is false. This is allowed because a true
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to true, a new [[Value]] is set, and
then [[Writable]] is set to false.


File: javascript_ecma_262_5th_ed.info,  Node: 9 Type Conversion and Testing,  Next: 91 ToPrimitive,  Prev: 8129 [[DefineOwnProperty]] P Desc Throw,  Up: Top

105 9 (#sec-9) Type Conversion and Testing
******************************************

The ECMAScript runtime system performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. These abstract
operations are not a part of the language; they are defined here to aid
the specification of the semantics of the language. The conversion
abstract operations are polymorphic; that is, they can accept a value
of any ECMAScript language type, but not of specification types.


File: javascript_ecma_262_5th_ed.info,  Node: 91 ToPrimitive,  Next: 92 ToBoolean,  Prev: 9 Type Conversion and Testing,  Up: Top

106 9.1 (#sec-9.1) ToPrimitive
******************************

The abstract operation ToPrimitive takes an input argument and an
optional argument PreferredType. The abstract operation ToPrimitive
converts its input argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint PreferredType to favour that type. Conversion occurs
according to Table 10:

   Table 10 — ToPrimitive Conversions Input Type Result Undefined The
result equals the input argument (no conversion).  Null The result
equals the input argument (no conversion).  Boolean The result equals
the input argument (no conversion).  Number The result equals the input
argument (no conversion).  String The result equals the input argument
(no conversion).  Object Return a default value for the Object. The
default value of an object is retrieved by calling the [[DefaultValue]]
internal method of the object, passing the optional hint PreferredType.
The behaviour of the [[DefaultValue]] internal method is defined by
this specification for all native ECMAScript objects in 8.12.8
(#sec-8.12.8).


File: javascript_ecma_262_5th_ed.info,  Node: 92 ToBoolean,  Next: 93 ToNumber,  Prev: 91 ToPrimitive,  Up: Top

107 9.2 (#sec-9.2) ToBoolean
****************************

The abstract operation ToBoolean converts its argument to a value of
type Boolean according to Table 11:

   Table 11 — ToBoolean Conversions Argument Type Result Undefined
false Null false Boolean The result equals the input argument (no
conversion).  Number The result is false if the argument is +0, −0,
or NaN; otherwise the result is true.  String The result is false if
the argument is the empty String (its length is zero); otherwise the
result is true.  Object true


File: javascript_ecma_262_5th_ed.info,  Node: 93 ToNumber,  Next: 931 ToNumber Applied to the String Type,  Prev: 92 ToBoolean,  Up: Top

108 9.3 (#sec-9.3) ToNumber
***************************

The abstract operation ToNumber converts its argument to a value of
type Number according to Table 12:

   Argument Type Result Undefined NaN Null +0 Boolean The result is 1
if the argument is true. The result is +0 if the argument is false.
Number The result equals the input argument (no conversion).  String
See grammar and note below.  Object Apply the following steps:
  1. Let primValue be ToPrimitive (#sec-9.1)(input argument, hint
     Number).

  2. Return ToNumber(primValue).


File: javascript_ecma_262_5th_ed.info,  Node: 931 ToNumber Applied to the String Type,  Next: 94 ToInteger,  Prev: 93 ToNumber,  Up: Top

109 9.3.1 (#sec-9.3.1) ToNumber Applied to the String Type
**********************************************************

ToNumber (#sec-9.3) applied to Strings applies the following grammar to
the input String. If the grammar cannot interpret the String as an
expansion of StringNumericLiteral, then the result of ToNumber is NaN.

   StringNumericLiteral ::: StrWhiteSpace_opt_ StrWhiteSpace_opt_
StrNumericLiteral StrWhiteSpace_opt_ StrWhiteSpace :::
StrWhiteSpaceChar StrWhiteSpace_opt_ StrWhiteSpaceChar ::: WhiteSpace
LineTerminator StrNumericLiteral ::: StrDecimalLiteral HexIntegerLiteral
StrDecimalLiteral ::: StrUnsignedDecimalLiteral `+'
StrUnsignedDecimalLiteral `-' StrUnsignedDecimalLiteral
StrUnsignedDecimalLiteral ::: `Infinity' DecimalDigits `.'
DecimalDigits_opt_ ExponentPart_opt_ `.' DecimalDigits ExponentPart_opt_
DecimalDigits ExponentPart_opt_ DecimalDigits ::: DecimalDigit
DecimalDigits DecimalDigit DecimalDigit ::: one of `0  1  2  3  4  5  6
7  8  9' ExponentPart ::: ExponentIndicator SignedInteger
ExponentIndicator ::: one of `e  E'

   SignedInteger ::: DecimalDigits `+' DecimalDigits `-' DecimalDigits
HexIntegerLiteral ::: `0x' HexDigit `0X' HexDigit HexIntegerLiteral
HexDigit HexDigit ::: one of `0  1  2  3  4  5  6  7  8  9  a  b  c  d
e  f  A  B  C  D  E  F' Some differences should be noted between the
syntax of a StringNumericLiteral and a NumericLiteral (see 7.8.3
(#sec-7.8.3)):

   * A StringNumericLiteral may be preceded and/or followed by white
     space and/or line terminators.

   * A StringNumericLiteral that is decimal may have any number of
     leading `0' digits.

   * A StringNumericLiteral that is decimal may be preceded by `+' or
     `-' to indicate its sign.

   * A StringNumericLiteral that is empty or contains only white space
     is converted to +0.

   The conversion of a String to a Number value is similar overall to
the determination of the Number value for a numeric literal (see 7.8.3
(#sec-7.8.3)), but some of the details are different, so the process
for converting a String numeric literal to a value of Number type is
given here in full. This value is determined in two steps: first, a
mathematical value (MV) is derived from the String numeric literal;
second, this mathematical value is rounded as described below.

   * The MV of StringNumericLiteral ::: [empty] is 0.

   * The MV of StringNumericLiteral ::: StrWhiteSpace is 0.

   * The MV of StringNumericLiteral ::: StrWhiteSpace_opt_
     StrNumericLiteral StrWhiteSpace_opt_ is the MV of
     StrNumericLiteral, no matter whether white space is present or not.

   * The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of
     StrDecimalLiteral.

   * The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of
     HexIntegerLiteral.

   * The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the
     MV of StrUnsignedDecimalLiteral.

   * The MV of StrDecimalLiteral ::: `+' StrUnsignedDecimalLiteral is
     the MV of StrUnsignedDecimalLiteral.

   * The MV of StrDecimalLiteral ::: `-' StrUnsignedDecimalLiteral is
     the negative of the MV of StrUnsignedDecimalLiteral. (Note that if
     the MV of StrUnsignedDecimalLiteral is 0, the negative of this MV
     is also 0. The rounding rule described below handles the
     conversion of this signless mathematical zero to a floating-point
     +0 or −0 as appropriate.)

   * The MV of StrUnsignedDecimalLiteral ::: `Infinity' is 10^10000 (a
     value so large that it will round to +∞).

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.' is the
     MV of DecimalDigits.

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.'
     DecimalDigits is the MV of the first DecimalDigits plus (the MV of
     the second DecimalDigits times 10^−n), where n is the number of
     characters in the second DecimalDigits.

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.'
     ExponentPart is the MV of DecimalDigits times 10^e, where e is the
     MV of ExponentPart.

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.'
     DecimalDigits ExponentPart is (the MV of the first DecimalDigits
     plus (the MV of the second DecimalDigits times 10^−n)) times
     10^e, where n is the number of characters in the second
     DecimalDigits and e is the MV of ExponentPart.

   * The MV of StrUnsignedDecimalLiteral ::: `.' DecimalDigits is the
     MV of DecimalDigits times 10^−n, where n is the number of
     characters in DecimalDigits.

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart
     is the MV of DecimalDigits times 10^e−n, where n is the number
     of characters in DecimalDigits and e is the MV of ExponentPart.

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits is the MV of
     DecimalDigits.

   * The MV of StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart
     is the MV of DecimalDigits times 10^e, where e is the MV of
     ExponentPart.

   * The MV of DecimalDigits ::: DecimalDigit is the MV of DecimalDigit.

   *   * The MV of ExponentPart ::: ExponentIndicator SignedInteger is the
     MV of SignedInteger.

   * The MV of SignedInteger ::: DecimalDigits is the MV of
     DecimalDigits.

   * The MV of SignedInteger ::: `+' DecimalDigits is the MV of
     DecimalDigits.

   * The MV of SignedInteger ::: `-' DecimalDigits is the negative of
     the MV of DecimalDigits.

   * The MV of DecimalDigit ::: `0' or of HexDigit ::: `0' is 0.

   * The MV of DecimalDigit ::: `1' or of HexDigit ::: `1' is 1.

   * The MV of DecimalDigit ::: `2' or of HexDigit ::: `2' is 2.

   * The MV of DecimalDigit ::: `3' or of HexDigit ::: `3' is 3.

   * The MV of DecimalDigit ::: `4' or of HexDigit ::: `4' is 4.

   * The MV of DecimalDigit ::: `5' or of HexDigit ::: `5' is 5.

   * The MV of DecimalDigit ::: `6' or of HexDigit ::: `6' is 6.

   * The MV of DecimalDigit ::: `7' or of HexDigit ::: `7' is 7.

   * The MV of DecimalDigit ::: `8' or of HexDigit ::: `8' is 8.

   * The MV of DecimalDigit ::: `9' or of HexDigit ::: `9' is 9.

   * The MV of HexDigit ::: `a' or of HexDigit ::: `A' is 10.

   * The MV of HexDigit ::: `b' or of HexDigit ::: `B' is 11.

   * The MV of HexDigit ::: `c' or of HexDigit ::: `C' is 12.

   * The MV of HexDigit ::: `d' or of HexDigit ::: `D' is 13.

   * The MV of HexDigit ::: `e' or of HexDigit ::: `E' is 14.

   * The MV of HexDigit ::: `f' or of HexDigit ::: `F' is 15.

   * The MV of HexIntegerLiteral ::: `0x' HexDigit is the MV of
     HexDigit.

   * The MV of HexIntegerLiteral ::: `0X' HexDigit is the MV of
     HexDigit.

   * The MV of HexIntegerLiteral ::: HexIntegerLiteral HexDigit is (the
     MV of HexIntegerLiteral times 16) plus the MV of HexDigit.

   Once the exact MV for a String numeric literal has been determined,
it is then rounded to a value of the Number type. If the MV is 0, then
the rounded value is +0 unless the first non white space character in
the String numeric literal is ‘`-'’, in which case the rounded
value is −0. Otherwise, the rounded value must be the Number value
for the MV (in the sense defined in 8.5 (#sec-8.5)), unless the literal
includes a StrUnsignedDecimalLiteral and the literal has more than 20
significant digits, in which case the Number value may be either the
Number value for the MV of a literal produced by replacing each
significant digit after the 20th with a 0 digit or the Number value for
the MV of a literal produced by replacing each significant digit after
the 20th with a 0 digit and then incrementing the literal at the 20th
digit position. A digit is significant if it is not part of an
ExponentPart and

   * it is not `0'; or

   * there is a nonzero digit to its left and there is a nonzero digit,
     not in the ExponentPart, to its right.


File: javascript_ecma_262_5th_ed.info,  Node: 94 ToInteger,  Next: 95 ToInt32 Signed 32 Bit Integer,  Prev: 931 ToNumber Applied to the String Type,  Up: Top

110 9.4 (#sec-9.4) ToInteger
****************************

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

  1. Let number be the result of calling ToNumber (#sec-9.3) on the
     input argument.

  2. If number is NaN, return +0.

  3. If number is +0, −0, +∞, or −∞, return number.

  4. Return the result of computing sign (#def-sign)(number) * floor
     (#def-floor)(abs (#def-abs)(number)).


File: javascript_ecma_262_5th_ed.info,  Node: 95 ToInt32 Signed 32 Bit Integer,  Next: 96 ToUint32 Unsigned 32 Bit Integer,  Prev: 94 ToInteger,  Up: Top

111 9.5 (#sec-9.5) ToInt32: (Signed 32 Bit Integer)
***************************************************

The abstract operation ToInt32 converts its argument to one of 2^32
integer values in the range −2^31 through 2^31−1, inclusive. This
abstract operation functions as follows:

  1. Let number be the result of calling ToNumber (#sec-9.3) on the
     input argument.

  2. If number is NaN, +0, −0, +∞, or −∞, return +0.

  3. Let posInt be sign (#def-sign)(number) * floor (#def-floor)(abs
     (#def-abs)(number)).

  4. Let int32bit be posInt modulo (#def-modulo) 2^32; that is, a
     finite integer value k of Number type with positive sign and less
     than 2^32 in magnitude such that the mathematical difference of
     posInt and k is mathematically an integer multiple of 2^32.

  5. If int32bit is greater than or equal to 2^31, return int32bit −
     2^32, otherwise return int32bit.

   NOTE Given the above definition of ToInt32:

   * The ToInt32 abstract operation is idempotent: if applied to a
     result that it produced, the second application leaves that value
     unchanged.

   * ToInt32(ToUint32 (#sec-9.6)(x)) is equal to ToInt32(x) for all
     values of x. (It is to preserve this latter property that +∞ and
     −∞ are mapped to +0.)

   * ToInt32 maps −0 to +0.


File: javascript_ecma_262_5th_ed.info,  Node: 96 ToUint32 Unsigned 32 Bit Integer,  Next: 97 ToUint16 Unsigned 16 Bit Integer,  Prev: 95 ToInt32 Signed 32 Bit Integer,  Up: Top

112 9.6 (#sec-9.6) ToUint32: (Unsigned 32 Bit Integer)
******************************************************

The abstract operation ToUint32 converts its argument to one of 2^32
integer values in the range 0 through 2^32−1, inclusive. This
abstraction operation functions as follows:

  1. Let number be the result of calling ToNumber (#sec-9.3) on the
     input argument.

  2. If number is NaN, +0, −0, +∞, or −∞, return +0.

  3. Let posInt be sign (#def-sign)(number) * floor (#def-floor)(abs
     (#def-abs)(number)).

  4. Let int32bit be posInt modulo (#def-modulo) 2^32; that is, a
     finite integer value k of Number type with positive sign and less
     than 2^32 in magnitude such that the mathematical difference of
     posInt and k is mathematically an integer multiple of 2^32.

  5. Return int32bit.

   NOTE Given the above definition of ToUInt32:

   * Step 5 is the only difference between ToUint32 and ToInt32
     (#sec-9.5).

   * The ToUint32 abstract operation is idempotent: if applied to a
     result that it produced, the second application leaves that value
     unchanged.

   * ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of x.
     (It is to preserve this latter property that +∞ and −∞ are
     mapped to +0.)

   * ToUint32 maps −0 to +0.


File: javascript_ecma_262_5th_ed.info,  Node: 97 ToUint16 Unsigned 16 Bit Integer,  Next: 98 ToString,  Prev: 96 ToUint32 Unsigned 32 Bit Integer,  Up: Top

113 9.7 (#sec-9.7) ToUint16: (Unsigned 16 Bit Integer)
******************************************************

The abstract operation ToUint16 converts its argument to one of 2^16
integer values in the range 0 through 2^16−1, inclusive. This
abstract operation functions as follows:

  1. Let number be the result of calling ToNumber (#sec-9.3) on the
     input argument.

  2. If number is NaN, +0, −0, +∞, or −∞, return +0.

  3. Let posInt be sign (#def-sign)(number) * floor (#def-floor)(abs
     (#def-abs)(number)).

  4. Let int16bit be posInt modulo (#def-modulo) 2^16; that is, a
     finite integer value k of Number type with positive sign and less
     than 2^16 in magnitude such that the mathematical difference of
     posInt and k is mathematically an integer multiple of 2^16.

  5. Return int16bit.

   NOTE Given the above definition of ToUint16:

   * The substitution of 2^16 for 2^32 in step 4 is the only difference
     between ToUint32 (#sec-9.6) and ToUint16.

   * ToUint16 maps −0 to +0.


File: javascript_ecma_262_5th_ed.info,  Node: 98 ToString,  Next: 981 ToString Applied to the Number Type,  Prev: 97 ToUint16 Unsigned 16 Bit Integer,  Up: Top

114 9.8 (#sec-9.8) ToString
***************************

The abstract operation ToString converts its argument to a value of
type String according to Table 13:

   Argument Type Result Undefined "undefined" Null "null" Boolean If
the argument is true, then the result is "true". If the argument is
false, then the result is "false".  Number See 9.8.1 (#sec-9.8.1).
String Return the input argument (no conversion) Object Apply the
following steps:
  1. Let primValue be ToPrimitive (#sec-9.1)(input argument, hint
     String).

  2. Return ToString(primValue).


File: javascript_ecma_262_5th_ed.info,  Node: 981 ToString Applied to the Number Type,  Next: 99 ToObject,  Prev: 98 ToString,  Up: Top

115 9.8.1 (#sec-9.8.1) ToString Applied to the Number Type
**********************************************************

The abstract operation ToString (#sec-9.8) converts a Number m to
String format as follows:

  1. If m is NaN, return the String "NaN".

  2. If m is +0 or −0, return the String "0".

  3. If m is less than zero, return the String concatenation of the
     String "-" and ToString(−m).

  4. If m is infinity, return the String "Infinity".

  5. Otherwise, let n, k, and s be integers such that k ≥ 1, 10^k−1
     ≤ s < 10^k, the Number value for s × 10^n−k is m, and k is as
     small as possible. Note that k is the number of digits in the
     decimal representation of s, that s is not divisible by 10, and
     that the least significant digit of s is not necessarily uniquely
     determined by these criteria.

  6. If k ≤ n ≤ 21, return the String consisting of the k digits of
     the decimal representation of s (in order, with no leading
     zeroes), followed by n−k occurrences of the character ‘`0'’.

  7. If 0 < n ≤ 21, return the String consisting of the most
     significant n digits of the decimal representation of s, followed
     by a decimal point ‘`.'’, followed by the remaining k−n
     digits of the decimal representation of s.

  8. If −6 < n ≤ 0, return the String consisting of the character
     ‘`0'’, followed by a decimal point ‘`.'’, followed by −n
     occurrences of the character ‘`0'’, followed by the k digits
     of the decimal representation of s.

  9. Otherwise, if k = 1, return the String consisting of the single
     digit of s, followed by lowercase character ‘`e'’, followed by
     a plus sign ‘`+'’ or minus sign ‘`-'’ according to whether
     n−1 is positive or negative, followed by the decimal
     representation of the integer abs (#def-abs)(n−1) (with no
     leading zeros).

 10. Return the String consisting of the most significant digit of the
     decimal representation of s, followed by a decimal point
     ‘`.'’, followed by the remaining k−1 digits of the decimal
     representation of s, followed by the lowercase character
     ‘`e'’, followed by a plus sign ‘`+'’ or minus sign
     ‘`-'’ according to whether n−1 is positive or negative,
     followed by the decimal representation of the integer abs
     (#def-abs)(n−1) (with no leading zeros).

   NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

   * If x is any Number value other than −0, then ToNumber
     (#sec-9.3)(ToString(x)) is exactly the same Number value as x.

   * The least significant digit of s is not always uniquely determined
     by the requirements listed in step 5.

   NOTE 2 For implementations that provide more accurate conversions
than required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

     Otherwise, let n, k, and s be integers such that k ≥ 1, 10^k−1
     ≤ s < 10^k, the Number value for s × 10^n−k is m, and k is as
     small as possible. If there are multiple possibilities for s,
     choose the value of s for which s × 10^n−k is closest in value
     to m. If there are two such possible values of s, choose the one
     that is even. Note that k is the number of digits in the decimal
     representation of s and that s is not divisible by 10.

   NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:


File: javascript_ecma_262_5th_ed.info,  Node: 99 ToObject,  Next: 910 CheckObjectCoercible,  Prev: 981 ToString Applied to the Number Type,  Up: Top

116 9.9 (#sec-9.9) ToObject
***************************

The abstract operation ToObject converts its argument to a value of
type Object according to Table 14:

   Table 14 — ToObject Argument Type Result Undefined Throw a
TypeError exception.  Null Throw a TypeError exception.  Boolean Create
a new Boolean object whose [[PrimitiveValue]] internal property is set
to the value of the argument. See 15.6 (#sec-15.6) for a description of
Boolean objects.  Number Create a new Number object whose
[[PrimitiveValue]] internal property is set to the value of the
argument. See 15.7 (#sec-15.7) for a description of Number objects.
String Create a new String object whose [[PrimitiveValue]] internal
property is set to the value of the argument. See 15.5 (#sec-15.5) for
a description of String objects.  Object The result is the input
argument (no conversion).


File: javascript_ecma_262_5th_ed.info,  Node: 910 CheckObjectCoercible,  Next: 911 IsCallable,  Prev: 99 ToObject,  Up: Top

117 9.10 (#sec-9.10) CheckObjectCoercible
*****************************************

The abstract operation CheckObjectCoercible throws an error if its
argument is a value that cannot be converted to an Object using
ToObject (#sec-9.9). It is defined by Table 15:

   Table 15 — CheckObjectCoercible Results Argument Type Result
Undefined Throw a TypeError exception.  Null Throw a TypeError
exception.  Boolean Return Number Return String Return Object Return


File: javascript_ecma_262_5th_ed.info,  Node: 911 IsCallable,  Next: 912 The SameValue Algorithm,  Prev: 910 CheckObjectCoercible,  Up: Top

118 9.11 (#sec-9.11) IsCallable
*******************************

The abstract operation IsCallable determines if its argument, which
must be an ECMAScript language value, is a callable function Object
according to Table 16:

   Argument Type Result Undefined Return false.  Null Return false.
Boolean Return false.  Number Return false.  String Return false.
Object If the argument object has a [[Call]] internal method, then
return true, otherwise return false.


File: javascript_ecma_262_5th_ed.info,  Node: 912 The SameValue Algorithm,  Next: 10 Executable Code and Execution Contexts,  Prev: 911 IsCallable,  Up: Top

119 9.12 (#sec-9.12) The SameValue Algorithm
********************************************

The internal comparison abstract operation SameValue(x, y), where x and
y are ECMAScript language values, produces true or false. Such a
comparison is performed as follows:

  1. If Type (#def-type)(x) is different from Type (#def-type)(y),
     return false.

  2. If Type (#def-type)(x) is Undefined, return true.

  3. If Type (#def-type)(x) is Null, return true.

  4. If Type (#def-type)(x) is Number, then.
       1. If x is NaN and y is NaN, return true.

       2. If x is +0 and y is −0, return false.

       3. If x is −0 and y is +0, return false.

       4. If x is the same Number value as y, return true.

       5. Return false.

  5. If Type (#def-type)(x) is String, then return true if x and y are
     exactly the same sequence of characters (same length and same
     characters in corresponding positions); otherwise, return false.

  6. If Type (#def-type)(x) is Boolean, return true if x and y are both
     true or both false; otherwise, return false.

  7. Return true if x and y refer to the same object. Otherwise, return
     false.


File: javascript_ecma_262_5th_ed.info,  Node: 10 Executable Code and Execution Contexts,  Next: 101 Types of Executable Code,  Prev: 912 The SameValue Algorithm,  Up: Top

120 10 (#sec-10) Executable Code and Execution Contexts
*******************************************************


File: javascript_ecma_262_5th_ed.info,  Node: 101 Types of Executable Code,  Next: 1011 Strict Mode Code,  Prev: 10 Executable Code and Execution Contexts,  Up: Top

121 10.1 (#sec-10.1) Types of Executable Code
*********************************************

There are three types of ECMAScript executable code:

   * Global code is source text that is treated as an ECMAScript
     Program. The global code of a particular Program does not include
     any source text that is parsed as part of a FunctionBody.

   * Eval code is the source text supplied to the built-in eval
     (#sec-15.1.2.1) function. More precisely, if the parameter to the
     built-in eval function is a String, it is treated as an ECMAScript
     Program. The eval code for a particular invocation of eval is the
     global code (#def-global-code) portion of that Program.

   * Function code is source text that is parsed as part of a
     FunctionBody. The _function code_ of a particular FunctionBody
     does not include any source text that is parsed as part of a
     nested FunctionBody. _Function code_ also denotes the source text
     supplied when using the built-in Function object as a constructor
     (#sec-15.3.2). More precisely, the last parameter provided to the
     Function constructor is converted to a String and treated as the
     FunctionBody. If more than one parameter is provided to the
     Function constructor, all parameters except the last one are
     converted to Strings and concatenated together, separated by
     commas. The resulting String is interpreted as the
     FormalParameterList for the FunctionBody defined by the last
     parameter. The function code for a particular instantiation of a
     Function does not include any source text that is parsed as part
     of a nested FunctionBody.



File: javascript_ecma_262_5th_ed.info,  Node: 1011 Strict Mode Code,  Next: 102 Lexical Environments,  Prev: 101 Types of Executable Code,  Up: Top

122 10.1.1 (#sec-10.1.1) Strict Mode Code
*****************************************

An ECMAScript Program syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the three types of ECMAScript code are referred to as
strict global code, strict eval code, and strict function code. Code is
interpreted as strict mode code in the following situations:

   * Global code (#def-global-code) is strict global code if it begins
     with a Directive Prologue that contains a Use Strict Directive
     (see 14.1 (#sec-14.1)).

   * Eval code (#def-eval-code) is strict eval code if it begins with a
     Directive Prologue that contains a Use Strict Directive or if the
     call to eval is a direct call (see 15.1.2.1.1) to the eval
     function (#sec-15.1.2.1.1) that is contained in strict mode code.

   * Function code (#def-function-code) that is part of a
     FunctionDeclaration, FunctionExpression, or accessor
     PropertyAssignment is strict function code if its
     FunctionDeclaration, FunctionExpression, or PropertyAssignment is
     contained in strict mode code or if the function code begins with
     a Directive Prologue that contains a Use Strict Directive.

   * Function code (#def-function-code) that is supplied as the last
     argument to the built-in Function constructor is strict function
     code if the last argument is a String that when processed as a
     FunctionBody begins with a Directive Prologue that contains a Use
     Strict Directive.



File: javascript_ecma_262_5th_ed.info,  Node: 102 Lexical Environments,  Next: 1021 Environment Records,  Prev: 1011 Strict Mode Code,  Up: Top

123 10.2 (#sec-10.2) Lexical Environments
*****************************************

A Lexical Environment is a specification type used to define the
association of Identifiers to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record (#sec-10.2.1) and a
possibly null reference to an outer Lexical Environment. Usually a
Lexical Environment is associated with some specific syntactic
structure of ECMAScript code such as a FunctionDeclaration, a
WithStatement, or a Catch clause of a TryStatement and a new Lexical
Environment is created each time such code is evaluated.

   An Environment Record (#sec-10.2.1) records the identifier bindings
that are created within the scope of its associated Lexical Environment.

   The outer environment reference is used to model the logical nesting
of Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a FunctionDeclaration contains
two nested FunctionDeclarations then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment
the Lexical Environment of the current execution of the surrounding
function.

   Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.


File: javascript_ecma_262_5th_ed.info,  Node: 1021 Environment Records,  Next: 10211 Declarative Environment Records,  Prev: 102 Lexical Environments,  Up: Top

124 10.2.1 (#sec-10.2.1) Environment Records
********************************************

There are two kinds of Environment Record values used in this
specification: declarative environment records (#sec-10.2.1.1) and
object environment records (#sec-10.2.1.2). Declarative environment
records (#sec-10.2.1.1) are used to define the effect of ECMAScript
language syntactic elements such as FunctionDeclarations,
VariableDeclarations, and Catch clauses that directly associate
identifier bindings with ECMAScript language values. Object environment
records (#sec-10.2.1.2) are used to define the effect of ECMAScript
elements such as Program and WithStatement that associate identifier
bindings with the properties of some object.

   For specification purposes Environment Record values can be thought
of as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with two concrete subclasses, declarative
environment record and object environment record. The abstract class
includes the abstract specification

   Table 17 — Abstract Methods of Environment Records Method Purpose
HasBinding(N) Determine if an environment record has a binding for an
identifier. Return true if it does and false if it does not. The String
value N is the text of the identifier.  CreateMutableBinding(N, D)
Create a new mutable binding in an environment record. The String value
N is the text of the bound name. If the optional Boolean argument D is
true the binding is may be subsequently deleted.  SetMutableBinding(N,
V, S) Set the value of an already existing mutable binding in an
environment record. The String value N is the text of the bound name. V
is the value for the binding and may be a value of any ECMAScript
language type. S is a Boolean flag. If S is true and the binding cannot
be set throw a TypeError exception. S is used to identify strict mode
references.  GetBindingValue(N, S) Returns the value of an already
existing binding from an environment record. The String value N is the
text of the bound name. S is used to identify strict mode references.
If S is true and the binding does not exist or is uninitialized throw a
ReferenceError exception.  DeleteBinding(N) Delete a binding from an
environment record. The String value N is the text of the bound name If
a binding for N exists, remove the binding and return true. If the
binding exists but cannot be removed return false. If the binding does
not exist return true.  ImplicitThisValue() Returns the value to use as
the this value on calls to function objects that are obtained as
binding values from this environment record.


File: javascript_ecma_262_5th_ed.info,  Node: 10211 Declarative Environment Records,  Next: 102111 HasBindingN,  Prev: 1021 Environment Records,  Up: Top

125 10.2.1.1 (#sec-10.2.1.1) Declarative Environment Records
************************************************************

Each declarative environment record is associated with an ECMAScript
program scope containing variable and/or function declarations. A
declarative environment record binds the set of identifiers defined by
the declarations contained within its scope.

   In addition to the mutable bindings supported by all Environment
Records, declarative environment records also provide for immutable
bindings. An immutable binding is one where the association between an
identifier and a value may not be modified once it has been
established. Creation and initialization of immutable binding are
distinct steps so it is possible for such bindings to exist in either
an initialized or uninitialized state. Declarative environment records
support the methods listed in Table 18 in addition to the Environment
Record abstract specification methods:

   Table 18 — Additional Methods of Declarative Environment Records
Method Purpose CreateImmutableBinding (#sec-10.2.1.1.7)(N) Create a new
but uninitialized immutable binding in an environment record. The
String value N is the text of the bound name.
InitializeImmutableBinding (#sec-10.2.1.1.8)(N, V) Set the value of an
already existing but uninitialized immutable binding in an environment
record. The String value N is the text of the bound name. V is the
value for the binding and is a value of any ECMAScript language type.


File: javascript_ecma_262_5th_ed.info,  Node: 102111 HasBindingN,  Next: 102112 CreateMutableBinding N D,  Prev: 10211 Declarative Environment Records,  Up: Top

126 10.2.1.1.1 (#sec-10.2.1.1.1) HasBinding(N)
**********************************************

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. If envRec has a binding for the name that is the value of N,
     return true.

  3. If it does not have such a binding, return false.


File: javascript_ecma_262_5th_ed.info,  Node: 102112 CreateMutableBinding N D,  Next: 102113 SetMutableBindingNVS,  Prev: 102111 HasBindingN,  Up: Top

127 10.2.1.1.2 (#sec-10.2.1.1.2) CreateMutableBinding (N, D)
************************************************************

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name N that is initialized to the value undefined. A binding must not
already exist in this Environment Record for N. If Boolean argument D
is provided and has the value true the new binding is marked as being
subject to deletion.

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. Assert: envRec does not already have a binding for N.

  3. Create a mutable binding in envRec for N and set its bound value
     to undefined. If D is true record that the newly created binding
     may be deleted by a subsequent DeleteBinding call.


File: javascript_ecma_262_5th_ed.info,  Node: 102113 SetMutableBindingNVS,  Next: 102114 GetBindingValueNS,  Prev: 102112 CreateMutableBinding N D,  Up: Top

128 10.2.1.1.3 (#sec-10.2.1.1.3) SetMutableBinding(N,V,S)
*********************************************************

The concrete Environment Record method SetMutableBinding for
declarative environment records attempts to change the bound value of
the current binding of the identifier whose name is the value of the
argument N to the value of argument V. A binding for N must already
exist. If the binding is an immutable binding (#def-immutable-binding),
a TypeError is thrown if S is true.

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. Assert: envRec must have a binding for N.

  3. If the binding for N in envRec is a mutable binding, change its
     bound value to V.

  4. Else this must be an attempt to change the value of an immutable
     binding (#def-immutable-binding) so if S is true throw a TypeError
     exception.


File: javascript_ecma_262_5th_ed.info,  Node: 102114 GetBindingValueNS,  Next: 102115 DeleteBinding N,  Prev: 102113 SetMutableBindingNVS,  Up: Top

129 10.2.1.1.4 (#sec-10.2.1.1.4) GetBindingValue(N,S)
*****************************************************

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. The binding must already
exist. If S is true and the binding is an uninitialized immutable
binding (#def-immutable-binding) throw a ReferenceError exception.

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. Assert: envRec has a binding for N.

  3. If the binding for N in envRec is an uninitialized immutable
     binding, then
       1. If S is false, return the value undefined, otherwise throw a
          ReferenceError exception.

  4. Else, return the value currently bound to N in envRec.


File: javascript_ecma_262_5th_ed.info,  Node: 102115 DeleteBinding N,  Next: 102116 ImplicitThisValue,  Prev: 102114 GetBindingValueNS,  Up: Top

130 10.2.1.1.5 (#sec-10.2.1.1.5) DeleteBinding (N)
**************************************************

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. If envRec does not have a binding for the name that is the value
     of N, return true.

  3. If the binding for N in envRec is cannot be deleted, return false.

  4. Remove the binding for N from envRec.

  5. Return true.


File: javascript_ecma_262_5th_ed.info,  Node: 102116 ImplicitThisValue,  Next: 102117 CreateImmutableBinding N,  Prev: 102115 DeleteBinding N,  Up: Top

131 10.2.1.1.6 (#sec-10.2.1.1.6) ImplicitThisValue()
****************************************************

Declarative Environment Records always return undefined as their
ImplicitThisValue.

  1. Return undefined.


File: javascript_ecma_262_5th_ed.info,  Node: 102117 CreateImmutableBinding N,  Next: 102118 InitializeImmutableBinding NV,  Prev: 102116 ImplicitThisValue,  Up: Top

132 10.2.1.1.7 (#sec-10.2.1.1.7) CreateImmutableBinding (N)
***********************************************************

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name N that is initialized to the value undefined. A binding must not
already exist in this environment record for N.

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. Assert: envRec does not already have a binding for N.

  3. Create an immutable binding in envRec for N and record that it is
     uninitialized.


File: javascript_ecma_262_5th_ed.info,  Node: 102118 InitializeImmutableBinding NV,  Next: 10212 Object Environment Records,  Prev: 102117 CreateImmutableBinding N,  Up: Top

133 10.2.1.1.8 (#sec-10.2.1.1.8) InitializeImmutableBinding (N,V)
*****************************************************************

The concrete Environment Record method InitializeImmutableBinding for
declarative environment records is used to set the bound value of the
current binding of the identifier whose name is the value of the
argument N to the value of argument V. An uninitialized immutable
binding for N must already exist.

  1. Let envRec be the declarative environment record for which the
     method was invoked.

  2. Assert: envRec must have an uninitialized immutable binding for N.

  3. Set the bound value for N in envRec to V.

  4. Record that the immutable binding for N in envRec has been
     initialized.


File: javascript_ecma_262_5th_ed.info,  Node: 10212 Object Environment Records,  Next: 102121 HasBindingN,  Prev: 102118 InitializeImmutableBinding NV,  Up: Top

134 10.2.1.2 (#sec-10.2.1.2) Object Environment Records
*******************************************************

Each object environment record (#sec-10.2.1) is associated with an
object called its binding object. An object environment record binds
the set of identifier names that directly correspond to the property
names of its binding object. Property names that are not an
IdentifierName are not included in the set of bound identifiers. Both
own and inherited properties are included in the set regardless of the
setting of their [[Enumerable]] attribute. Because properties can be
dynamically added and deleted from objects, the set of identifiers
bound by an object environment record may potentially change as a
side-effect of any operation that adds or deletes properties. Any
bindings that are created as a result of such a side-effect are
considered to be a mutable binding even if the Writable attribute of
the corresponding property has the value false. Immutable bindings do
not exist for object environment records.

   Object environment records can be configured to provide their
binding object as an implicit this value for use in function calls.
This capability is used to specify the behaviour of With Statement
(12.10 (#sec-12.10)) induced bindings. The capability is controlled by
a provideThis Boolean value that is associated with each object
environment record. By default, the value of provideThis is false for
any object environment record.

   The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.


File: javascript_ecma_262_5th_ed.info,  Node: 102121 HasBindingN,  Next: 102122 CreateMutableBinding N D,  Prev: 10212 Object Environment Records,  Up: Top

135 10.2.1.2.1 (#sec-10.2.1.2.1) HasBinding(N)
**********************************************

The concrete Environment Record method HasBinding for object
environment records determines if its associated binding object has a
property whose name is the value of the argument N:

  1. Let envRec be the object environment record for which the method
     was invoked.

  2. Let bindings be the binding object for envRec.

  3. Return the result of calling the [[HasProperty]] internal method
     of bindings, passing N as the property name.


File: javascript_ecma_262_5th_ed.info,  Node: 102122 CreateMutableBinding N D,  Next: 102123 SetMutableBinding NVS,  Prev: 102121 HasBindingN,  Up: Top

136 10.2.1.2.2 (#sec-10.2.1.2.2) CreateMutableBinding (N, D)
************************************************************

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and
initializes it to the value undefined. A property named N must not
already exist in the binding object. If Boolean argument D is provided
and has the value true the new property’s [[Configurable]] attribute
is set to true, otherwise it is set to false.

  1. Let envRec be the object environment record for which the method
     was invoked.

  2. Let bindings be the binding object for envRec.

  3. Assert: The result of calling the [[HasProperty]] internal method
     of bindings, passing N as the property name, is false.

  4. If D is true then let configValue be true otherwise let
     configValue be false.

  5. Call the [[DefineOwnProperty]] internal method of bindings,
     passing N, Property Descriptor (#sec-8.10) {[[Value]]:undefined,
     [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]:
     configValue}, and true as arguments.


File: javascript_ecma_262_5th_ed.info,  Node: 102123 SetMutableBinding NVS,  Next: 102124 GetBindingValueNS,  Prev: 102122 CreateMutableBinding N D,  Up: Top

137 10.2.1.2.3 (#sec-10.2.1.2.3) SetMutableBinding (N,V,S)
**********************************************************

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the
value of the argument N to the value of argument V. A property named N
should already exist but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument S.

  1. Let envRec be the object environment record for which the method
     was invoked.

  2. Let bindings be the binding object for envRec.

  3. Call the [[Put]] internal method of bindings with arguments N, V,
     and S.


File: javascript_ecma_262_5th_ed.info,  Node: 102124 GetBindingValueNS,  Next: 102125 DeleteBindingN,  Prev: 102123 SetMutableBinding NVS,  Up: Top

138 10.2.1.2.4 (#sec-10.2.1.2.4) GetBindingValue(N,S)
*****************************************************

The concrete Environment Record method GetBindingValue for object
environment records returns the value of its associated binding
object’s property whose name is the String value of the argument
identifier N. The property should already exist but if it does not the
result depends upon the value of the S argument:

  1. Let envRec be the object environment record for which the method
     was invoked.

  2. Let bindings be the binding object for envRec.

  3. Let value be the result of calling the [[HasProperty]] internal
     method of bindings, passing N as the property name.

  4. If value is false, then
       1. If S is false, return the value undefined, otherwise throw a
          ReferenceError exception.

  5. Return the result of calling the [[Get]] internal method of
     bindings, passing N for the argument.


File: javascript_ecma_262_5th_ed.info,  Node: 102125 DeleteBindingN,  Next: 102126 ImplicitThisValue,  Prev: 102124 GetBindingValueNS,  Up: Top

139 10.2.1.2.5 (#sec-10.2.1.2.5) DeleteBinding(N)
*************************************************

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value true.

  1. Let envRec be the object environment record for which the method
     was invoked.

  2. Let bindings be the binding object for envRec.

  3. Return the result of calling the [[Delete]] internal method of
     bindings, passing N and false as arguments.


File: javascript_ecma_262_5th_ed.info,  Node: 102126 ImplicitThisValue,  Next: 1022 Lexical Environment Operations,  Prev: 102125 DeleteBindingN,  Up: Top

140 10.2.1.2.6 (#sec-10.2.1.2.6) ImplicitThisValue()
****************************************************

Object Environment Records return undefined as their ImplicitThisValue
unless their provideThis flag is true.

  1. Let envRec be the object environment record for which the method
     was invoked.

  2. If the provideThis flag of envRec is true, return the binding
     object for envRec.

  3. Otherwise, return undefined.


File: javascript_ecma_262_5th_ed.info,  Node: 1022 Lexical Environment Operations,  Next: 10221 GetIdentifierReference lex name strict,  Prev: 102126 ImplicitThisValue,  Up: Top

141 10.2.2 (#sec-10.2.2) Lexical Environment Operations
*******************************************************

The following abstract operations are used in this specification to
operate upon lexical environments (#sec-10.2):


File: javascript_ecma_262_5th_ed.info,  Node: 10221 GetIdentifierReference lex name strict,  Next: 10222 NewDeclarativeEnvironmentE,  Prev: 1022 Lexical Environment Operations,  Up: Top

142 10.2.2.1 (#sec-10.2.2.1) GetIdentifierReference (lex, name, strict)
***********************************************************************

The abstract operation GetIdentifierReference is called with a Lexical
Environment (#sec-10.2) lex, an identifier String name, and a Boolean
flag strict. The value of lex may be null. When called, the following
steps are performed:

  1. If lex is the value null, then
       1. Return a value of type Reference (#sec-8.7) whose base value
          is undefined, whose referenced name is name, and whose strict
          mode flag is strict.

  2. Let envRec be lex’s environment record.

  3. Let exists be the result of calling the HasBinding(N) concrete
     method of envRec passing name as the argument N.

  4. If exists is true, then
       1. Return a value of type Reference (#sec-8.7) whose base value
          is envRec, whose referenced name is name, and whose strict
          mode flag is strict.

  5. Else
       1. Let outer be the value of lex’s outer environment reference
          (#def-outer-environment).

       2. Return the result of calling GetIdentifierReference
          (#sec-10.2.2.1) passing outer, name, and strict as arguments.



File: javascript_ecma_262_5th_ed.info,  Node: 10222 NewDeclarativeEnvironmentE,  Next: 10223 NewObjectEnvironment O E,  Prev: 10221 GetIdentifierReference lex name strict,  Up: Top

143 10.2.2.2 (#sec-10.2.2.2) NewDeclarativeEnvironment(E)
*********************************************************

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment (#sec-10.2) or null as argument E the
following steps are performed:

  1. Let env be a new Lexical Environment (#sec-10.2).

  2. Let envRec be a new declarative environment record containing no
     bindings.

  3. Set env’s environment record to be envRec.

  4. Set the outer lexical environment reference
     (#def-outer-environment) of env to E.

  5. Return env.


File: javascript_ecma_262_5th_ed.info,  Node: 10223 NewObjectEnvironment O E,  Next: 1023 The Global Environment,  Prev: 10222 NewDeclarativeEnvironmentE,  Up: Top

144 10.2.2.3 (#sec-10.2.2.3) NewObjectEnvironment (O, E)
********************************************************

When the abstract operation NewObjectEnvironmentis called with an
Object O and a Lexical Environment (#sec-10.2) E (or null) as
arguments, the following steps are performed:

  1. Let env be a new Lexical Environment (#sec-10.2).

  2. Let envRec be a new object environment record containing O as the
     binding object (#sec-10.2.1.2).

  3. Set env’s environment record to be envRec.

  4. Set the outer lexical environment reference
     (#def-outer-environment) of env to E.

  5. Return env.


File: javascript_ecma_262_5th_ed.info,  Node: 1023 The Global Environment,  Next: 103 Execution Contexts,  Prev: 10223 NewObjectEnvironment O E,  Up: Top

145 10.2.3 (#sec-10.2.3) The Global Environment
***********************************************

The global environment is a unique Lexical Environment (#sec-10.2)
which is created before any ECMAScript code is executed. The global
environment’s Environment Record is an object environment record
(#sec-10.2.1.2) whose binding object (#sec-10.2.1.2) is the global
object (15.1) (#sec-15.1). The global environment’s outer environment
reference (#def-outer-environment) is null.

   As ECMAScript code is executed, additional properties may be added
to the global object and the initial properties may be modified.


File: javascript_ecma_262_5th_ed.info,  Node: 103 Execution Contexts,  Next: 1031 Identifier Resolution,  Prev: 1023 The Global Environment,  Up: Top

146 10.3 (#sec-10.3) Execution Contexts
***************************************

When control is transferred to ECMAScript executable code, control is
entering an execution context. Active execution contexts logically form
a stack. The top execution context on this logical stack is the running
execution context. A new execution context is created whenever control
is transferred from the executable code associated with the currently
running execution context to executable code that is not associated with

   An execution context contains whatever state is necessary to track
the execution progress of its associated code. In addition, each
execution context has the state components listed in Table 19.

   Table 19 — Execution Context State Components Component Purpose
LexicalEnvironment Identifies the Lexical Environment (#sec-10.2) used
to resolve identifier references made by code within this execution
context.  VariableEnvironment Identifies the Lexical Environment
(#sec-10.2) whose environment record holds bindings created by
VariableStatements and FunctionDeclarations within this execution
context.  ThisBinding The value associated with the `this' keyword
within ECMAScript code associated with this execution context.  The
LexicalEnvironment and VariableEnvironment components of an execution
context are always Lexical Environments (#sec-10.2). When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

   In most situations only the running execution context (the top of
the execution context stack) is directly manipulated by algorithms
within this specification. Hence when the terms
“LexicalEnvironment”, “VariableEnvironment” and
“ThisBinding” are used without qualification they are in reference
to those components of the running execution context.

   An execution context is purely a specification mechanism and need
not correspond to any particular artefact of an ECMAScript
implementation. It is impossible for an ECMAScript program to access an
execution context.


File: javascript_ecma_262_5th_ed.info,  Node: 1031 Identifier Resolution,  Next: 104 Establishing an Execution Context,  Prev: 103 Execution Contexts,  Up: Top

147 10.3.1 (#sec-10.3.1) Identifier Resolution
**********************************************

Identifier resolution is the process of determining the binding of an
Identifier using the LexicalEnvironment of the running execution
context. During execution of ECMAScript code, the syntactic production
PrimaryExpression : Identifier is evaluated using the following
algorithm:

  1. Let env be the running execution context’s LexicalEnvironment.

  2. If the syntactic production that is being evaluated is contained
     in a strict mode code (#sec-10.1.1), then let strict be true, else
     let strict be false.

  3. Return the result of calling GetIdentifierReference
     (#sec-10.2.2.1) function passing env, Identifier, and strict as
     arguments.

   The result of evaluating an identifier is always a value of type
Reference (#sec-8.7) with its referenced name component equal to the
Identifier String.


File: javascript_ecma_262_5th_ed.info,  Node: 104 Establishing an Execution Context,  Next: 1041 Entering Global Code,  Prev: 1031 Identifier Resolution,  Up: Top

148 10.4 (#sec-10.4) Establishing an Execution Context
******************************************************

Evaluation of global code (#def-global-code) or code using the eval
function (15.1.2.1 (#sec-15.1.2.1)) establishes and enters a new
execution context. Every invocation of an ECMAScript code function
(13.2.1 (#sec-13.2.1)) also establishes and enters a new execution
context, even if a function is calling itself recursively. Every return
exits an execution context. A thrown exception may also exit one or
more execution contexts.

   When control enters an execution context, the execution context’s
ThisBinding is set, its VariableEnvironment and initial
LexicalEnvironment are defined, and declaration binding instantiation
(10.5 (#sec-10.5)) is performed. The exact manner in which these
actions occur depend on the type of code being entered.


File: javascript_ecma_262_5th_ed.info,  Node: 1041 Entering Global Code,  Next: 10411 Initial Global Execution Context,  Prev: 104 Establishing an Execution Context,  Up: Top

149 10.4.1 (#sec-10.4.1) Entering Global Code
*********************************************

The following steps are performed when control enters the execution
context for global code (#def-global-code):

  1. Initialize the execution context using the global code as
     described in 10.4.1.1 (#sec-10.4.1.1).

  2. Perform Declaration Binding Instantiation as described in 10.5
     (#sec-10.5) using the global code.


File: javascript_ecma_262_5th_ed.info,  Node: 10411 Initial Global Execution Context,  Next: 1042 Entering Eval Code,  Prev: 1041 Entering Global Code,  Up: Top

150 10.4.1.1 (#sec-10.4.1.1) Initial Global Execution Context
*************************************************************

The following steps are performed to initialize a global execution
context for ECMAScript code C:

  1. Set the VariableEnvironment to the Global Environment
     (#sec-10.2.3).

  2. Set the LexicalEnvironment to the Global Environment (#sec-10.2.3).

  3. Set the ThisBinding to the global object.


File: javascript_ecma_262_5th_ed.info,  Node: 1042 Entering Eval Code,  Next: 10421 Strict Mode Restrictions,  Prev: 10411 Initial Global Execution Context,  Up: Top

151 10.4.2 (#sec-10.4.2) Entering Eval Code
*******************************************

The following steps are performed when control enters the execution
context for eval code (#def-eval-code):

  1. If there is no calling context or if the eval code is not being
     evaluated by a direct call (15.1.2.1.1) to the eval function
     (#sec-15.1.2.1.1) then,
       1. Initialize the execution context as if it was a global
          execution context using the eval code as C as described in
          10.4.1.1 (#sec-10.4.1.1).

  2. Else,
       1. Set the ThisBinding to the same value as the ThisBinding of
          the calling execution context.

       2. Set the LexicalEnvironment to the same value as the
          LexicalEnvironment of the calling execution context.

       3. Set the VariableEnvironment to the same value as the
          VariableEnvironment of the calling execution context.

  3. If the eval code is strict code (#sec-10.1.1), then
       1. Let strictVarEnv be the result of calling
          NewDeclarativeEnvironment (#sec-10.2.2.2) passing the
          LexicalEnvironment as the argument.

       2. Set the LexicalEnvironment to strictVarEnv. c. Set the
          VariableEnvironment to strictVarEnv.

  4. Perform Declaration Binding Instantiation as described in 10.5
     (#sec-10.5) using the eval code (#def-eval-code).


File: javascript_ecma_262_5th_ed.info,  Node: 10421 Strict Mode Restrictions,  Next: 1043 Entering Function Code,  Prev: 1042 Entering Eval Code,  Up: Top

152 10.4.2.1 (#sec-10.4.2.1) Strict Mode Restrictions
*****************************************************

The eval code (#def-eval-code) cannot instantiate variable or function
bindings (#sec-10.5) in the variable environment of the calling context
that invoked the eval if either the code of the calling context or the
eval code (#def-eval-code) is strict code (#sec-10.1.1). Instead such
bindings are instantiated in a new VariableEnvironment that is only
accessible to the eval code (#def-eval-code).


File: javascript_ecma_262_5th_ed.info,  Node: 1043 Entering Function Code,  Next: 105 Declaration Binding Instantiation,  Prev: 10421 Strict Mode Restrictions,  Up: Top

153 10.4.3 (#sec-10.4.3) Entering Function Code
***********************************************

The following steps are performed when control enters the execution
context for function code contained in function object F, a caller
provided thisArg, and a caller provided argumentsList:

  1. If the function code is strict code (#sec-10.1.1), set the
     ThisBinding to thisArg.

  2. Else if thisArg is null or undefined, set the ThisBinding to the
     global object.

  3. Else if Type (#def-type)(thisArg) is not Object, set the
     ThisBinding to ToObject (#sec-9.9)(thisArg).

  4. Else set the ThisBinding to thisArg.

  5. Let localEnv be the result of calling NewDeclarativeEnvironment
     (#sec-10.2.2.2) passing the value of the [[Scope]] internal
     property of F as the argument.

  6. Set the LexicalEnvironment to localEnv.

  7. Set the VariableEnvironment to localEnv.

  8. Let code be the value of F’s [[Code]] internal property.

  9. Perform Declaration Binding Instantiation using the function code
     code and argumentList as described in 10.5 (#sec-10.5).


File: javascript_ecma_262_5th_ed.info,  Node: 105 Declaration Binding Instantiation,  Next: 106 Arguments Object,  Prev: 1043 Entering Function Code,  Up: Top

154 10.5 (#sec-10.5) Declaration Binding Instantiation
******************************************************

Every execution context has an associated VariableEnvironment.
Variables and functions declared in ECMAScript code evaluated in an
execution context are added as bindings in that VariableEnvironment’s
Environment Record (#sec-10.2.1). For function code, parameters are
also added as bindings to that Environment Record (#sec-10.2.1).

   Which Environment Record (#sec-10.2.1) is used to bind a declaration
and its kind depends upon the type of ECMAScript code executed by the
execution context, but the remainder of the behaviour is generic. On
entering an execution context, bindings are created in the
VariableEnvironment as follows using the caller provided code and, if
it is function code, argument List (#sec-8.8) args:

  1. Let env be the environment record component of the running
     execution context’s VariableEnvironment.

  2. If code is eval code (#def-eval-code), then let
     configurableBindings be true else let configurableBindings be
     false.

  3. If code is strict mode code (#sec-10.1.1), then let strict be true
     else let strict be false.

  4. If code is function code, then
       1. Let func be the function whose [[Call]] internal method
          initiated execution of code. Let names be the value of
          func’s [[FormalParameters]] internal property.

       2. Let argCount be the number of elements in args.

       3. Let n be the number 0.

       4. For each String argName in names, in list order do
            1. Let n be the current value of n plus 1.

            2. If n is greater than argCount, let v be undefined
               otherwise let v be the value of the nth element of args.

            3. Let argAlreadyDeclared be the result of calling env’s
               HasBinding concrete method passing argName as the
               argument.

            4. If argAlreadyDeclared is false, call env’s
               CreateMutableBinding concrete method passing argName as
               the argument.

            5. Call env’s SetMutableBinding concrete method passing
               argName, v, and strict as the arguments.


  5. For each FunctionDeclaration f in code, in source text order do
       1. Let fn be the Identifier in FunctionDeclaration f.

       2. Let fo be the result of instantiating FunctionDeclaration f
          as described in Clause 13 (#sec-13).

       3. Let funcAlreadyDeclared be the result of calling env’s
          HasBinding concrete method passing fn as the argument.

       4. If funcAlreadyDeclared is false, call env’s
          CreateMutableBinding concrete method passing fn and
          configurableBindings as the arguments.

       5. Else if env is the environment record component of the global
          environment then
            1. Let go be the global object.

            2. Let existingProp be the resulting of calling the
               [[GetProperty]] internal method of go with argument fn.

            3. If existingProp.[[Configurable]] is true, then
                 1. Call the [[DefineOwnProperty]] internal method of
                    go, passing fn, Property Descriptor (#sec-8.10)
                    {[[Value]]: undefined, [[Writable]]: true,
                    [[Enumerable]]: true, [[Configurable]]:
                    configurableBindings }, and true as arguments.

            4. Else if IsAccessorDescriptor
               (#def-IsAccessorDescriptor)(existingProp) or
               existingProp does not have attribute values
               {[[Writable]]: true, [[Enumerable]]: true}, then
                 1. Throw a TypeError exception.


       6. Call env’s SetMutableBinding concrete method passing fn,
          fo, and strict as the arguments.

  6. Let argumentsAlreadyDeclared be the result of calling env’s
     HasBinding concrete method passing "arguments" as the argument.

  7. If code is function code and argumentsAlreadyDeclared is false,
     then
       1. Let argsObj be the result of calling the abstract operation
          CreateArgumentsObject (10.6 (#sec-10.6)) passing func, names,
          args, env and strict as arguments.

       2. If strict is true, then
            1. Call env’s CreateImmutableBinding (#sec-10.2.1.1.7)
               concrete method passing the String "arguments" as the
               argument.

            2. Call env’s InitializeImmutableBinding
               (#sec-10.2.1.1.8) concrete method passing "arguments"
               and argsObj as arguments.

       3. Else,
            1. Call env’s CreateMutableBinding concrete method
               passing the String "arguments" as the argument.

            2. Call env’s SetMutableBinding concrete method passing
               "arguments", argsObj, and false as arguments.


  8. For each VariableDeclaration and VariableDeclarationNoIn d in
     code, in source text order do
       1. Let dn be the Identifier in d.

       2. Let varAlreadyDeclared be the result of calling env’s
          HasBinding concrete method passing dn as the argument.

       3. If varAlreadyDeclared is false, then
            1. Call env’s CreateMutableBinding concrete method
               passing dn and configurableBindings as the arguments.

            2. Call env’s SetMutableBinding concrete method passing
               dn, undefined, and strict as the arguments.




File: javascript_ecma_262_5th_ed.info,  Node: 106 Arguments Object,  Next: 11 Expressions,  Prev: 105 Declaration Binding Instantiation,  Up: Top

155 10.6 (#sec-10.6) Arguments Object
*************************************

When control enters an execution context for function code, an
arguments object is created unless (as specified in 10.5 (#sec-10.5))
the identifier `arguments' occurs as an Identifier in the function’s
FormalParameterList or occurs as the Identifier of a
VariableDeclaration or FunctionDeclaration contained in the function
code.

   The arguments object is created by calling the abstract operation
CreateArgumentsObject with arguments func the function object whose
code is to be evaluated, names a List (#sec-8.8) containing the
function’s formal parameter names, args the actual arguments passed
to the [[Call]] internal method, env the variable environment for the
function code, and strict a Boolean that indicates whether or not the
function code is strict code (#sec-10.1.1). When CreateArgumentsObject
is called the following steps are performed:

  1. Let len be the number of elements in args.

  2. Let obj be the result of creating a new ECMAScript object.

  3. Set all the internal methods of obj as specified in 8.12
     (#sec-8.12).

  4. Set the [[Class]] internal property of obj to "Arguments".

  5. Let Object be the standard built-in Object constructor (15.2.2
     (#sec-15.2.2)).

  6. Set the [[Prototype]] internal property of obj to the standard
     built-in Object prototype object (15.2.4 (#sec-15.2.4)).

  7. Call the [[DefineOwnProperty]] internal method on obj passing
     "length", the Property Descriptor (#sec-8.10) {[[Value]]: len,
     [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]:
     true}, and false as arguments.

  8. Let map be the result of creating a new object as if by the
     expression `new Object()' where `Object' is the standard built-in
     constructor with that name

  9. Let mappedNames be an empty List (#sec-8.8).

 10. Let indx = len − 1.

 11. Repeat while indx >= 0,
       1. Let val be the element of args at 0-origined list position
          indx.

       2. Call the [[DefineOwnProperty]] internal method on obj passing
          ToString (#sec-9.8)(indx), the property descriptor
          {[[Value]]: val, [[Writable]]: true, [[Enumerable]]: true,
          [[Configurable]]: true}, and false as arguments.

       3. If indx is less than the number of elements in names, then
            1. Let name be the element of names at 0-origined list
               position indx.

            2. If strict is false and name is not an element of
               mappedNames, then
                 1. Add name as an element of the list mappedNames.

                 2. Let g be the result of calling the MakeArgGetter
                    abstract operation with arguments name and env.

                 3. Let p be the result of calling the MakeArgSetter
                    abstract operation with arguments name and env.

                 4. Call the [[DefineOwnProperty]] internal method of
                    map passing ToString (#sec-9.8)(indx), the Property
                    Descriptor (#sec-8.10) {[[Set]]: p, [[Get]]: g,
                    [[Configurable]]: true}, and false as arguments.


       4. Let indx = indx − 1

 12. If mappedNames is not empty, then
       1. Set the [[ParameterMap]] internal property of obj to map.

       2. Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]],
          and [[Delete]] internal methods of obj to the definitions
          provided below.

 13. If strict is false, then
       1. Call the [[DefineOwnProperty]] internal method on obj passing
          "callee", the property descriptor {[[Value]]: func,
          [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]:
          true}, and false as arguments.

 14. Else, strict is true so
       1. Let thrower be the [[ThrowTypeError]] function Object (13.2.3
          (#sec-13.2.3)).

       2. Call the [[DefineOwnProperty]] internal method of obj with
          arguments "caller", PropertyDescriptor {[[Get]]: thrower,
          [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]:
          false}, and false.

       3. Call the [[DefineOwnProperty]] internal method of obj with
          arguments "callee", PropertyDescriptor {[[Get]]: thrower,
          [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]:
          false}, and false.

 15. Return obj

   The abstract operation MakeArgGetter called with String name and
environment record env creates a function object that when executed
returns the value bound for name in env. It performs the following
steps:

  1. Let body be the result of concatenating the Strings "return ",
     name, and ";"

  2. Return the result of creating a function object as described in
     13.2 (#sec-13.2) using no FormalParameterList, body for
     FunctionBody, env as Scope, and true for Strict.

   The abstract operation MakeArgSetter called with String name and
environment record env creates a function object that when executed
sets the value bound for name in env. It performs the following steps:

  1. Let param be the String name concatenated with the String "_arg".

  2. Let body be the String "<name> = <param>;" with <name> replaced by
     the value of name and <param> replaced by the value of param.

  3. Return the result of creating a function object as described in
     13.2 (#sec-13.2) using a List (#sec-8.8) containing the single
     String param as FormalParameterList, body for FunctionBody, env as
     Scope, and true for Strict.

   The [[Get]] internal method of an arguments object for a non-strict
mode function with formal parameters when called with a property name P
performs the following steps:

  1. Let map be the value of the [[ParameterMap]] internal property of
     the arguments object.

  2. Let isMapped be the result of calling the [[GetOwnProperty]]
     internal method of map passing P as the argument.

  3. If the value of isMapped is undefined, then
       1. Let v be the result of calling the default [[Get]] internal
          method (8.12.3 (#sec-8.12.3)) on the arguments object passing
          P as the argument.

       2. If P is "caller" and v is a strict mode Function object,
          throw a TypeError exception. c. Return v.

  4. Else, map contains a formal parameter mapping for P so,
       1. Return the result of calling the [[Get]] internal method of
          map passing P as the argument.


   The [[GetOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P performs the following steps:

  1. Let desc be the result of calling the default [[GetOwnProperty]]
     internal method (8.12.1 (#sec-8.12.1)) on the arguments object
     passing P as the argument.

  2. If desc is undefined then return desc.

  3. Let map be the value of the [[ParameterMap]] internal property of
     the arguments object.

  4. Let isMapped be the result of calling the [[GetOwnProperty]]
     internal method of map passing P as the argument.

  5. If the value of isMapped is not undefined, then
       1. Set desc.[[Value]] to the result of calling the [[Get]]
          internal method of map passing P as the argument.

  6. Return desc.

   The [[DefineOwnProperty]] internal method of an arguments object for
a non-strict mode function with formal parameters when called with a
property name P, Property Descriptor (#sec-8.10) Desc, and Boolean flag
Throw performs the following steps:

  1. Let map be the value of the [[ParameterMap]] internal property of
     the arguments object.

  2. Let isMapped be the result of calling the [[GetOwnProperty]]
     internal method of map passing P as the argument.

  3. Let allowed be the result of calling the default
     [[DefineOwnProperty]] internal method (8.12.9 (#sec-8.12.9)) on
     the arguments object passing P, Desc, and false as the arguments.

  4. If allowed is false, then
       1. If Throw is true then throw a TypeError exception, otherwise
          return false.

  5. If the value of isMapped is not undefined, then
       1.            1. Call the [[Delete]] internal method of map passing P,
               and false as the arguments.

       2. Else
            1. If Desc.[[Value]] is present, then
                 1. Call the [[Put]] internal method of map passing P,
                    Desc.[[Value]], and Throw as the arguments.

            2. If Desc.[[Writable]] is present and its value is false,
               then
                 1. Call the [[Delete]] internal method of map passing
                    P and false as arguments.



  6. Return true.

   The [[Delete]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P and Boolean flag Throw performs the following steps:

  1. Let map be the value of the [[ParameterMap]] internal property of
     the arguments object.

  2. Let isMapped be the result of calling the [[GetOwnProperty]]
     internal method of map passing P as the argument.

  3. Let result be the result of calling the default [[Delete]]
     internal method (8.12.7 (#sec-8.12.7)) on the arguments object
     passing P and Throw as the arguments.

  4. If result is true and the value of isMapped is not undefined, then
       1. Call the [[Delete]] internal method of map passing P, and
          false as the arguments.

  5. Return result.

   NOTE 1 For non-strict mode functions the array index (defined in
15.4 (#sec-15.4)) named data properties of an arguments object whose
numeric name values are less than the number of formal parameters of
the corresponding function object initially share their values with the
corresponding argument bindings in the function’s execution context.
This means that changing the property changes the corresponding value
of the argument binding and vice-versa. This correspondence is broken
if such a property is deleted and then redefined or if the property is
changed into an accessor property. For strict mode functions, the
values of the arguments object’s properties are simply a copy of the
arguments passed to the function and there is no dynamic linkage
between the property values and the formal parameter values.

   NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values
of its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

   NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named “`caller'” and
“`callee'” which throw a TypeError exception on access. The
“`callee'” property has a more specific meaning for non-strict mode
functions and a “`caller'” property has historically been provided
as an implementation-defined extension by some ECMAScript
implementations. The strict mode definition of these properties exists
to ensure that neither of them is defined in any other manner by
conforming ECMAScript implementations.


File: javascript_ecma_262_5th_ed.info,  Node: 11 Expressions,  Next: 111 Primary Expressions,  Prev: 106 Arguments Object,  Up: Top

156 11 (#sec-11) Expressions
****************************


File: javascript_ecma_262_5th_ed.info,  Node: 111 Primary Expressions,  Next: 1111 The this Keyword,  Prev: 11 Expressions,  Up: Top

157 11.1 (#sec-11.1) Primary Expressions
****************************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 111 Primary Expressions

157.1 Syntax
============

PrimaryExpression : `this' Identifier Literal ArrayLiteral ObjectLiteral
`(' Expression `)'


File: javascript_ecma_262_5th_ed.info,  Node: 1111 The this Keyword,  Next: 1112 Identifier Reference,  Prev: 111 Primary Expressions,  Up: Top

158 11.1.1 (#sec-11.1.1) The this Keyword
*****************************************

The `this' keyword evaluates to the value of the ThisBinding of the
current execution context.


File: javascript_ecma_262_5th_ed.info,  Node: 1112 Identifier Reference,  Next: 1113 Literal Reference,  Prev: 1111 The this Keyword,  Up: Top

159 11.1.2 (#sec-11.1.2) Identifier Reference
*********************************************

An Identifier is evaluated by performing Identifier Resolution as
specified in 10.3.1 (#sec-10.3.1). The result of evaluating an
Identifier is always a value of type Reference (#sec-8.7).


File: javascript_ecma_262_5th_ed.info,  Node: 1113 Literal Reference,  Next: 1114 Array Initialiser,  Prev: 1112 Identifier Reference,  Up: Top

160 11.1.3 (#sec-11.1.3) Literal Reference
******************************************

A Literal is evaluated as described in 7.8 (#sec-7.8).


File: javascript_ecma_262_5th_ed.info,  Node: 1114 Array Initialiser,  Next: 1115 Object Initialiser,  Prev: 1113 Literal Reference,  Up: Top

161 11.1.4 (#sec-11.1.4) Array Initialiser
******************************************

An array initialiser is an expression describing the initialisation of
an Array object, written in a form of a literal. It is a list of zero
or more expressions, each of which represents an array element
(#def-array-element), enclosed in square brackets. The elements need
not be literals; they are evaluated each time the array initialiser is
evaluated.

   Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by
an AssignmentExpression (i.e., a comma at the beginning or after
another comma), the missing array element contributes to the length of
the Array and increases the index of subsequent elements. Elided array
elements are not defined. If an element is elided at the end of an
array, that element does not contribute to the length of the Array.

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 1114 Array Initialiser

161.1 Syntax
============

ArrayLiteral : `[' Elision_opt_ `]' `[' ElementList `]' `[' ElementList
`,' Elision_opt_ `]' ElementList : Elision_opt_ AssignmentExpression
ElementList `,' Elision_opt_ AssignmentExpression Elision : `,' Elision
`,'


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 1114 Array Initialiser

161.2 Semantics
===============

The production ArrayLiteral : `[' Elision_opt_ `]' is evaluated as
follows:

  1. Let array be the result of creating a new object as if by the
     expression `new Array()' where `Array' is the standard built-in
     constructor with that name.

  2. Let pad be the result of evaluating Elision; if not present, use
     the numeric value zero.

  3. Call the [[Put]] internal method of array with arguments "length",
     pad, and false.

  4. Return array.

   The production ArrayLiteral : `[' ElementList `]' is evaluated as
follows:

  1. Return the result of evaluating ElementList.

   The production ArrayLiteral : `[' ElementList `,' Elision_opt_ `]'
is evaluated as follows:

  1. Let array be the result of evaluating ElementList.

  2. Let pad be the result of evaluating Elision; if not present, use
     the numeric value zero.

  3. Let len be the result of calling the [[Get]] internal method of
     array with argument "length".

  4. Call the [[Put]] internal method of array with arguments "length",
     ToUint32 (#sec-9.6)(pad+len), and false.

  5. Return array.

   The production ElementList : Elision_opt_ AssignmentExpression is
evaluated as follows:

  1.  2. Let firstIndex be the result of evaluating Elision; if not
     present, use the numeric value zero.

  3. Let initResult be the result of evaluating AssignmentExpression.

  4. Let initValue be GetValue (#sec-8.7.1)(initResult).

  5. Call the [[DefineOwnProperty]] internal method of array with
     arguments ToString (#sec-9.8)(firstIndex), the Property Descriptor
     (#sec-8.10) { [[Value]]: initValue, [[Writable]]: true,
     [[Enumerable]]: true, [[Configurable]]: true}, and false.

  6. Return array.

   The production ElementList : ElementList `,' Elision_opt_
AssignmentExpression is evaluated as follows:

  1. Let array be the result of evaluating ElementList.

  2. Let pad be the result of evaluating Elision; if not present, use
     the numeric value zero.

  3. Let initResult be the result of evaluating AssignmentExpression.

  4. Let initValue be GetValue (#sec-8.7.1)(initResult).

  5. Let len be the result of calling the [[Get]] internal method of
     array with argument "length".

  6. Call the [[DefineOwnProperty]] internal method of array with
     arguments ToString (#sec-9.8)(ToUint32 (#sec-9.6)((pad+len)) and
     the Property Descriptor (#sec-8.10) { [[Value]]: initValue,
     [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true},
     and false.

  7. Return array.

   The production Elision : `,' is evaluated as follows:

  1. Return the numeric value 1.

   The production Elision : Elision `,' is evaluated as follows:

  1. Let preceding be the result of evaluating Elision.

  2. Return preceding+1.

   NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation
of new own properties using [[Put]].


File: javascript_ecma_262_5th_ed.info,  Node: 1115 Object Initialiser,  Next: 1116 The Grouping Operator,  Prev: 1114 Array Initialiser,  Up: Top

162 11.1.5 (#sec-11.1.5) Object Initialiser
*******************************************

An object initialiser is an expression describing the initialisation of
an Object, written in a form resembling a literal. It is a list of zero
or more pairs of property names and associated values, enclosed in
curly braces. The values need not be literals; they are evaluated each
time the object initialiser is evaluated.

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 1115 Object Initialiser

162.1 Syntax
============

ObjectLiteral : `{' `}' `{' PropertyNameAndValueList `}' `{'
PropertyNameAndValueList `,' `}' PropertyNameAndValueList :
PropertyAssignment PropertyNameAndValueList `,' PropertyAssignment
PropertyAssignment : PropertyName `:' AssignmentExpression `get'
PropertyName `(' `)' `{' FunctionBody `}' `set' PropertyName `('
PropertySetParameterList `)' `{' FunctionBody `}'

   PropertyName : IdentifierName StringLiteral NumericLiteral
PropertySetParameterList : Identifier


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 1115 Object Initialiser

162.2 Semantics
===============

The production ObjectLiteral : `{' `}' is evaluated as follows:

  1. Return a new object created as if by the expression `new Object()'
     where `Object' is the standard built-in constructor with that name.

   The productions ObjectLiteral : `{' PropertyNameAndValueList `}' and
ObjectLiteral : `{' PropertyNameAndValueList `,' `}' are evaluated as
follows:

  1. Return the result of evaluating PropertyNameAndValueList.

   The production PropertyNameAndValueList : PropertyAssignment is
evaluated as follows:

  1. Let obj be the result of creating a new object as if by the
     expression `new Object()' where `Object' is the standard built-in
     constructor with that name.

  2. Let propId be the result of evaluating PropertyAssignment.

  3. Call the [[DefineOwnProperty]] internal method of obj with
     arguments propId.name, propId.descriptor, and false.

  4. Return obj.

   The production PropertyNameAndValueList : PropertyNameAndValueList
`,' PropertyAssignment is evaluated as follows:

  1. Let obj be the result of evaluating PropertyNameAndValueList.

  2. Let propId be the result of evaluating PropertyAssignment.

  3. Let previous be the result of calling the [[GetOwnProperty]]
     internal method of obj with argument propId.name.

  4. If previous is not undefined then throw a SyntaxError exception if
     any of the following conditions are true
       1. This production is contained in strict code (#sec-10.1.1) and
          IsDataDescriptor (#def-IsDataDescriptor)(previous) is true
          and IsDataDescriptor
          (#def-IsDataDescriptor)(propId.descriptor) is true.

       2. IsDataDescriptor (#def-IsDataDescriptor)(previous) is true
          and IsAccessorDescriptor
          (#def-IsAccessorDescriptor)(propId.descriptor) is true.

       3. IsAccessorDescriptor (#def-IsAccessorDescriptor)(previous) is
          true and IsDataDescriptor
          (#def-IsDataDescriptor)(propId.descriptor) is true.

       4. IsAccessorDescriptor (#def-IsAccessorDescriptor)(previous) is
          true and IsAccessorDescriptor
          (#def-IsAccessorDescriptor)(propId.descriptor) is true and
          either both previous and propId.descriptor have [[Get]]
          fields or both previous and propId.descriptor have [[Set]]
          fields

  5. Call the [[DefineOwnProperty]] internal method of obj with
     arguments propId.name, propId.descriptor, and false.

  6. Return obj.

   If the above steps would throw a SyntaxError then an implementation
must treat the error as an early error (Clause 16 (#sec-16)).

   The production PropertyAssignment : PropertyName `:'
AssignmentExpression is evaluated as follows:

  1. Let propName be the result of evaluating PropertyName.

  2. Let exprValue be the result of evaluating AssignmentExpression.

  3. Let propValue be GetValue (#sec-8.7.1)(exprValue).

  4. Let desc be the Property Descriptor (#sec-8.10) {[[Value]]:
     propValue, [[Writable]]: true, [[Enumerable]]: true,
     [[Configurable]]: true}

  5. Return Property Identifier (#def-property-identifier) (propName,
     desc).

  1. Let propName be the result of evaluating PropertyName.

  2. Let closure be the result of creating a new Function object as
     specified in 13.2 (#sec-13.2) with an empty parameter list and
     body specified by FunctionBody. Pass in the LexicalEnvironment of
     the running execution context as the Scope. Pass in true as the
     Strict flag if the PropertyAssignment is contained in strict code
     (#sec-10.1.1) or if its FunctionBody is strict code (#sec-10.1.1).

  3. Let desc be the Property Descriptor (#sec-8.10) {[[Get]]: closure,
     [[Enumerable]]: true, [[Configurable]]: true}

  4. Return Property Identifier (#def-property-identifier) (propName,
     desc).

   The production PropertyAssignment : `set' PropertyName `('
PropertySetParameterList `)' `{' FunctionBody `}' is evaluated as
follows:

  1. Let propName be the result of evaluating PropertyName.

  2. Let closure be the result of creating a new Function object as
     specified in 13.2 (#sec-13.2) with parameters specified by
     PropertySetParameterList and body specified by FunctionBody. Pass
     in the LexicalEnvironment of the running execution context as the
     Scope. Pass in true as the Strict flag if the PropertyAssignment
     is contained in strict code (#sec-10.1.1) or if its FunctionBody
     is strict code (#sec-10.1.1).

  3. Let desc be the Property Descriptor (#sec-8.10) {[[Set]]: closure,
     [[Enumerable]]: true, [[Configurable]]: true}

  4. Return Property Identifier (#def-property-identifier) (propName,
     desc).

   It is a SyntaxError if the Identifier "eval" or the Identifier
"arguments" occurs as the Identifier in a PropertySetParameterList of a
PropertyAssignment that is contained in strict code (#sec-10.1.1) or if
its FunctionBody is strict code (#sec-10.1.1).

   The production PropertyName : IdentifierName is evaluated as follows:

  1. Return the String value containing the same sequence of characters
     as the IdentifierName.

   The production PropertyName : StringLiteral is evaluated as follows:

  1. Return the SV of the StringLiteral.

   The production PropertyName : NumericLiteral is evaluated as follows:

  1. Let nbr be the result of forming the value of the NumericLiteral.

  2. Return ToString (#sec-9.8)(nbr).


File: javascript_ecma_262_5th_ed.info,  Node: 1116 The Grouping Operator,  Next: 112 Left-Hand-Side Expressions,  Prev: 1115 Object Initialiser,  Up: Top

163 11.1.6 (#sec-11.1.6) The Grouping Operator
**********************************************

The production PrimaryExpression : `(' Expression `)' is evaluated as
follows:

  1. Return the result of evaluating Expression. This may be of type
     Reference (#sec-8.7).

   NOTE This algorithm does not apply GetValue (#sec-8.7.1) to the
result of evaluating Expression. The principal motivation for this is
so that operators such as `delete' and `typeof' may be applied to
parenthesised expressions.


File: javascript_ecma_262_5th_ed.info,  Node: 112 Left-Hand-Side Expressions,  Next: 1121 Property Accessors,  Prev: 1116 The Grouping Operator,  Up: Top

164 11.2 (#sec-11.2) Left-Hand-Side Expressions
***********************************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 112 Left-Hand-Side Expressions

164.1 Syntax
============

MemberExpression : PrimaryExpression FunctionExpression
MemberExpression `[' Expression `]' MemberExpression `.' IdentifierName
`new' MemberExpression Arguments

   NewExpression : MemberExpression `new' NewExpression CallExpression :
MemberExpression Arguments CallExpression Arguments CallExpression `['
Expression `]' CallExpression `.' IdentifierName Arguments : `(' `)'
`(' ArgumentList `)' ArgumentList : AssignmentExpression ArgumentList
`,' AssignmentExpression LeftHandSideExpression : NewExpression
CallExpression


File: javascript_ecma_262_5th_ed.info,  Node: 1121 Property Accessors,  Next: 1122 The new Operator,  Prev: 112 Left-Hand-Side Expressions,  Up: Top

165 11.2.1 (#sec-11.2.1) Property Accessors
*******************************************

Properties are accessed by name, using either the dot notation:

   MemberExpression `.' IdentifierName CallExpression `.' IdentifierName
or the bracket notation:

   MemberExpression `[' Expression `]' CallExpression `[' Expression `]'
The dot notation is explained by the following syntactic conversion:

   MemberExpression `.' IdentifierName is identical in its behaviour to

   MemberExpression `[' <identifier-name-string> `]' and similarly

   CallExpression `.' IdentifierName is identical in its behaviour to

   CallExpression `[' <identifier-name-string> `]' where
<identifier-name-string> is a string literal containing the same
sequence of characters after processing of Unicode escape sequences as
the IdentifierName.

   The production MemberExpression : MemberExpression `[' Expression
`]' is evaluated as follows:

  1. Let baseReference be the result of evaluating MemberExpression.

  2. Let baseValue be GetValue (#sec-8.7.1)(baseReference).

  3. Let propertyNameReference be the result of evaluating Expression.

  4. Let propertyNameValue be GetValue
     (#sec-8.7.1)(propertyNameReference).

  5. Call CheckObjectCoercible (#sec-9.10)(baseValue).

  6. Let propertyNameString be ToString (#sec-9.8)(propertyNameValue).

  7. If the syntactic production that is being evaluated is contained
     in strict mode code (#sec-10.1.1), let strict be true, else let
     strict be false.

  8. Return a value of type Reference (#sec-8.7) whose base value is
     baseValue and whose referenced name is propertyNameString, and
     whose strict mode flag is strict.

   The production CallExpression : CallExpression `[' Expression `]' is
evaluated in exactly the same manner, except that the contained
CallExpression is evaluated in step 1.


File: javascript_ecma_262_5th_ed.info,  Node: 1122 The new Operator,  Next: 1123 Function Calls,  Prev: 1121 Property Accessors,  Up: Top

166 11.2.2 (#sec-11.2.2) The new Operator
*****************************************

The production NewExpression : `new' NewExpression is evaluated as
follows:

  1. Let ref be the result of evaluating NewExpression.

  2. Let constructor be GetValue (#sec-8.7.1)(ref).

  3. If Type (#def-type)(constructor) is not Object, throw a TypeError
     exception.

  4. If constructor does not implement the [[Construct]] internal
     method, throw a TypeError exception.

  5. Return the result of calling the [[Construct]] internal method on
     constructor, providing no arguments (that is, an empty list of
     arguments).

   The production MemberExpression : `new' MemberExpression Arguments
is evaluated as follows:

  1. Let ref be the result of evaluating MemberExpression.

  2. Let constructor be GetValue (#sec-8.7.1)(ref).

  3. Let argList be the result of evaluating Arguments, producing an
     internal list of argument values (11.2.4 (#sec-11.2.4)).

  4. If Type (#def-type)(constructor) is not Object, throw a TypeError
     exception.

  5. If constructor does not implement the [[Construct]] internal
     method, throw a TypeError exception.

  6. Return the result of calling the [[Construct]] internal method on
     constructor, providing the list argList as the argument values.


File: javascript_ecma_262_5th_ed.info,  Node: 1123 Function Calls,  Next: 1124 Argument Lists,  Prev: 1122 The new Operator,  Up: Top

167 11.2.3 (#sec-11.2.3) Function Calls
***************************************

The production CallExpression : MemberExpression Arguments is evaluated
as follows:

  1. Let ref be the result of evaluating MemberExpression.

  2. Let func be GetValue (#sec-8.7.1)(ref).

  3. Let argList be the result of evaluating Arguments, producing an
     internal list of argument values (see 11.2.4 (#sec-11.2.4)).

  4. If Type (#def-type)(func) is not Object, throw a TypeError
     exception.

  5. If IsCallable (#sec-9.11)(func) is false, throw a TypeError
     exception.

  6. If Type (#def-type)(ref) is Reference (#sec-8.7), then
       1. If IsPropertyReference (#def-IsPropertyReference)(ref) is
          true, then
            1. Let thisValue be GetBase (#def-GetBase)(ref).

       2. Else, the base of ref is an Environment Record (#sec-10.2.1)
            1. Let thisValue be the result of calling the
               ImplicitThisValue concrete method of GetBase
               (#def-GetBase)(ref).


  7. Else, Type (#def-type)(ref) is not Reference (#sec-8.7).
       1. Let thisValue be undefined.

  8. Return the result of calling the [[Call]] internal method on func,
     providing thisValue as the this value and providing the list
     argList as the argument values.

   The production CallExpression : CallExpression Arguments is
evaluated in exactly the same manner, except that the contained
CallExpression is evaluated in step 1.

   NOTE The returned result will never be of type Reference (#sec-8.7)
if func is a native ECMAScript object. Whether calling a host object
can return a value of type Reference (#sec-8.7) is
implementation-dependent. If a value of type Reference (#sec-8.7) is
returned, it must be a non-strict Property Reference
(#def-IsPropertyReference).


File: javascript_ecma_262_5th_ed.info,  Node: 1124 Argument Lists,  Next: 1125 Function Expressions,  Prev: 1123 Function Calls,  Up: Top

168 11.2.4 (#sec-11.2.4) Argument Lists
***************************************

The evaluation of an argument list produces a List (#sec-8.8) of values
(see 8.8 (#sec-8.8)).

   The production Arguments : `(' `)' is evaluated as follows:

  1.
   The production Arguments : `(' ArgumentList `)' is evaluated as
follows:

  1. Return the result of evaluating ArgumentList.

   The production ArgumentList : AssignmentExpression is evaluated as
follows:

  1. Let ref be the result of evaluating AssignmentExpression.

  2. Let arg be GetValue (#sec-8.7.1)(ref).

  3. Return a List (#sec-8.8) whose sole item is arg.

   The production ArgumentList : ArgumentList `,' AssignmentExpression
is evaluated as follows:

  1. Let precedingArgs be the result of evaluating ArgumentList.

  2. Let ref be the result of evaluating AssignmentExpression.

  3. Let arg be GetValue (#sec-8.7.1)(ref).

  4. Return a List (#sec-8.8) whose length is one greater than the
     length of precedingArgs and whose items are the items of
     precedingArgs, in order, followed at the end by arg which is the
     last item of the new list.


File: javascript_ecma_262_5th_ed.info,  Node: 1125 Function Expressions,  Next: 113 Postfix Expressions,  Prev: 1124 Argument Lists,  Up: Top

169 11.2.5 (#sec-11.2.5) Function Expressions
*********************************************

The production MemberExpression : FunctionExpression is evaluated as
follows:

  1. Return the result of evaluating FunctionExpression.


File: javascript_ecma_262_5th_ed.info,  Node: 113 Postfix Expressions,  Next: 1131 Postfix Increment Operator,  Prev: 1125 Function Expressions,  Up: Top

170 11.3 (#sec-11.3) Postfix Expressions
****************************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 113 Postfix Expressions

170.1 Syntax
============

PostfixExpression : LeftHandSideExpression LeftHandSideExpression [no
LineTerminator here] (#def-restricted-production) `++'
LeftHandSideExpression [no LineTerminator here]
(#def-restricted-production) `--'


File: javascript_ecma_262_5th_ed.info,  Node: 1131 Postfix Increment Operator,  Next: 1132 Postfix Decrement Operator,  Prev: 113 Postfix Expressions,  Up: Top

171 11.3.1 (#sec-11.3.1) Postfix Increment Operator
***************************************************

The production PostfixExpression : LeftHandSideExpression [no
LineTerminator here] (#def-restricted-production) `++' is evaluated as
follows:

  1. Let lhs be the result of evaluating LeftHandSideExpression.

  2. Throw a SyntaxError exception if the following conditions are all
     true:
        * Type (#def-type)(lhs) is Reference (#sec-8.7) is true

        * IsStrictReference (#def-IsStrictReference)(lhs) is true

        * Type (#def-type)(GetBase (#def-GetBase)(lhs)) is Enviroment
          Record

        * GetReferencedName (#def-GetReferencedName)(lhs) is either
          "eval" or "arguments"

  3. Let oldValue be ToNumber (#sec-9.3)(GetValue (#sec-8.7.1)(lhs)).

  4. Let newValue be the result of adding the value 1 to oldValue,
     using the same rules as for the `+' operator (see 11.6.3
     (#sec-11.6.3)).

  5. Call PutValue (#sec-8.7.2)(lhs, newValue).

  6. Return oldValue.


File: javascript_ecma_262_5th_ed.info,  Node: 1132 Postfix Decrement Operator,  Next: 114 Unary Operators,  Prev: 1131 Postfix Increment Operator,  Up: Top

172 11.3.2 (#sec-11.3.2) Postfix Decrement Operator
***************************************************

The production PostfixExpression : LeftHandSideExpression [no
LineTerminator here] (#def-restricted-production) `--' is evaluated as
follows:

  1. Let lhs be the result of evaluating LeftHandSideExpression.

  2. Throw a SyntaxError exception if the following conditions are all
     true:
        * Type (#def-type)(lhs) is Reference (#sec-8.7) is true

        *        * Type (#def-type)(GetBase (#def-GetBase)(lhs)) is Enviroment
          Record

        * GetReferencedName (#def-GetReferencedName)(lhs) is either
          "eval" or "arguments"

  3. Let oldValue be ToNumber (#sec-9.3)(GetValue (#sec-8.7.1)(lhs)).

  4. Let newValue be the result of subtracting the value 1 from
     oldValue, using the same rules as for the `-' operator (11.6.3
     (#sec-11.6.3)).

  5. Call PutValue (#sec-8.7.2)(lhs, newValue).

  6. Return oldValue.


File: javascript_ecma_262_5th_ed.info,  Node: 114 Unary Operators,  Next: 1141 The delete Operator,  Prev: 1132 Postfix Decrement Operator,  Up: Top

173 11.4 (#sec-11.4) Unary Operators
************************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 114 Unary Operators

173.1 Syntax
============

UnaryExpression : PostfixExpression `delete' UnaryExpression `void'
UnaryExpression `typeof' UnaryExpression `++' UnaryExpression `--'
UnaryExpression `+' UnaryExpression `-' UnaryExpression `~'
UnaryExpression `!' UnaryExpression


File: javascript_ecma_262_5th_ed.info,  Node: 1141 The delete Operator,  Next: 1142 The void Operator,  Prev: 114 Unary Operators,  Up: Top

174 11.4.1 (#sec-11.4.1) The `delete' Operator
**********************************************

The production UnaryExpression : `delete' UnaryExpression is evaluated
as follows:

  1. Let ref be the result of evaluating UnaryExpression.

  2. If Type (#def-type)(ref) is not Reference (#sec-8.7), return true.

  3. If IsUnresolvableReference (#def-IsUnresolvableReference)(ref)
     then,
       1. If IsStrictReference (#def-IsStrictReference)(ref) is true,
          throw a SyntaxError exception.

       2. Else, return true.

  4. If IsPropertyReference (#def-IsPropertyReference)(ref) is true,
     then
       1. Return the result of calling the [[Delete]] internal method
          on ToObject (#sec-9.9)(GetBase (#def-GetBase)(ref)) providing
          GetReferencedName (#def-GetReferencedName)(ref) and
          IsStrictReference (#def-IsStrictReference)(ref) as the
          arguments.

  5. Else, ref is a Reference (#sec-8.7) to an Environment Record
     (#sec-10.2.1) binding, so
       1. If IsStrictReference (#def-IsStrictReference)(ref) is true,
          throw a SyntaxError exception.

       2. Let bindings be GetBase (#def-GetBase)(ref).

       3. Return the result of calling the DeleteBinding concrete
          method of bindings, providing GetReferencedName
          (#def-GetReferencedName)(ref) as the argument.


   NOTE When a `delete' operator occurs within strict mode code
(#sec-10.1.1), a SyntaxError exception is thrown if its UnaryExpression
is a direct reference to a variable, function argument, or function
name. In addition, if a `delete' operator occurs within strict mode
code (#sec-10.1.1) and the property to be deleted has the attribute {
[[Configurable]]: false }, a TypeError exception is thrown.


File: javascript_ecma_262_5th_ed.info,  Node: 1142 The void Operator,  Next: 1143 The typeof Operator,  Prev: 1141 The delete Operator,  Up: Top

175 11.4.2 (#sec-11.4.2) The `void' Operator
********************************************

The production UnaryExpression : `void' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Call GetValue (#sec-8.7.1)(expr).

  3. Return undefined.

   NOTE GetValue (#sec-8.7.1) must be called even though its value is
not used because it may have observable side-effects.


File: javascript_ecma_262_5th_ed.info,  Node: 1143 The typeof Operator,  Next: 1144 Prefix Increment Operator,  Prev: 1142 The void Operator,  Up: Top

176 11.4.3 (#sec-11.4.3) The `typeof' Operator
**********************************************

The production UnaryExpression : `typeof' UnaryExpression is evaluated
as follows:

  1. Let val be the result of evaluating UnaryExpression.

  2. If Type (#def-type)(val) is Reference (#sec-8.7), then
       1. If IsUnresolvableReference
          (#def-IsUnresolvableReference)(val) is true, return
          "undefined".

       2. Let val be GetValue (#sec-8.7.1)(val).

  3. Return a String determined by Type (#def-type)(val) according to
     Table 20.

   Table 20 — typeof Operator Results Type of val Result Undefined
"undefined" Null "object" Boolean "boolean" Number "number" String
"string" Object (native and does not implement [[Call]]) "object"
Object (native or host and does implement [[Call]]) "function" Object
(host and does not implement [[Call]]) Implementation-defined except
may not be "undefined", "boolean", "number", or "string".


File: javascript_ecma_262_5th_ed.info,  Node: 1144 Prefix Increment Operator,  Next: 1145 Prefix Decrement Operator,  Prev: 1143 The typeof Operator,  Up: Top

177 11.4.4 (#sec-11.4.4) Prefix Increment Operator
**************************************************

The production UnaryExpression : `++' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Throw a SyntaxError exception if the following conditions are all
     true:
        * Type (#def-type)(expr) is Reference (#sec-8.7) is true

        * IsStrictReference (#def-IsStrictReference)(expr) is true

        * Type (#def-type)(GetBase (#def-GetBase)(expr)) is Enviroment
          Record

        * GetReferencedName (#def-GetReferencedName)(expr) is either
          "eval" or "arguments"

  3. Let oldValue be ToNumber (#sec-9.3)(GetValue (#sec-8.7.1)(expr)).

  4. Let newValue be the result of adding the value 1 to oldValue,
     using the same rules as for the `+' operator (see 11.6.3
     (#sec-11.6.3)).

  5. Call PutValue (#sec-8.7.2)(expr, newValue).

  6. Return newValue.


File: javascript_ecma_262_5th_ed.info,  Node: 1145 Prefix Decrement Operator,  Next: 1146 Unary + Operator,  Prev: 1144 Prefix Increment Operator,  Up: Top

178 11.4.5 (#sec-11.4.5) Prefix Decrement Operator
**************************************************

The production UnaryExpression : `--' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Throw a SyntaxError exception if the following conditions are all
     true:
        * Type (#def-type)(expr) is Reference (#sec-8.7) is true

        * IsStrictReference (#def-IsStrictReference)(expr) is true

        * Type (#def-type)(GetBase (#def-GetBase)(expr)) is Enviroment
          Record

        * GetReferencedName (#def-GetReferencedName)(expr) is either
          "eval" or "arguments"

  3. Let oldValue be ToNumber (#sec-9.3)(GetValue (#sec-8.7.1)(expr)).

  4. Let newValue be the result of subtracting the value 1 from
     oldValue, using the same rules as for the `-' operator (see 11.6.3
     (#sec-11.6.3)).

  5. Call PutValue (#sec-8.7.2)(expr, newValue).

  6. Return newValue.


File: javascript_ecma_262_5th_ed.info,  Node: 1146 Unary + Operator,  Next: 1147 Unary - Operator,  Prev: 1145 Prefix Decrement Operator,  Up: Top

179 11.4.6 (#sec-11.4.6) Unary `+' Operator
*******************************************

The unary + operator converts its operand to Number type.

   The production UnaryExpression : `+' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Return ToNumber (#sec-9.3)(GetValue (#sec-8.7.1)(expr)).


File: javascript_ecma_262_5th_ed.info,  Node: 1147 Unary - Operator,  Next: 1148 Bitwise NOT Operator ~,  Prev: 1146 Unary + Operator,  Up: Top

180 11.4.7 (#sec-11.4.7) Unary `-' Operator
*******************************************

The unary `-' operator converts its operand to Number type and then
negates it. Note that negating +0 produces −0, and negating −0
produces +0.

   The production UnaryExpression : `-' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Let oldValue be ToNumber (#sec-9.3)(GetValue (#sec-8.7.1)(expr)).

  3. If oldValue is NaN, return NaN.

  4. Return the result of negating oldValue; that is, compute a Number
     with the same magnitude but opposite sign.


File: javascript_ecma_262_5th_ed.info,  Node: 1148 Bitwise NOT Operator ~,  Next: 1149 Logical NOT Operator !,  Prev: 1147 Unary - Operator,  Up: Top

181 11.4.8 (#sec-11.4.8) Bitwise NOT Operator ( `~' )
*****************************************************

The production UnaryExpression : `~' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Let oldValue be ToInt32 (#sec-9.5)(GetValue (#sec-8.7.1)(expr)).

  3. Return the result of applying bitwise complement to oldValue. The
     result is a signed 32-bit integer.


File: javascript_ecma_262_5th_ed.info,  Node: 1149 Logical NOT Operator !,  Next: 115 Multiplicative Operators,  Prev: 1148 Bitwise NOT Operator ~,  Up: Top

182 11.4.9 (#sec-11.4.9) Logical NOT Operator ( `!' )
*****************************************************

The production UnaryExpression : `!' UnaryExpression is evaluated as
follows:

  1. Let expr be the result of evaluating UnaryExpression.

  2. Let oldValue be ToBoolean (#sec-9.2)(GetValue (#sec-8.7.1)(expr)).

  3. If oldValue is true, return false.

  4. Return true.


File: javascript_ecma_262_5th_ed.info,  Node: 115 Multiplicative Operators,  Next: 1151 Applying the * Operator,  Prev: 1149 Logical NOT Operator !,  Up: Top

183 11.5 (#sec-11.5) Multiplicative Operators
*********************************************

* Menu:

* Syntax::
* Semantics::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Next: Semantics,  Up: 115 Multiplicative Operators

183.1 Syntax
============

MultiplicativeExpression : UnaryExpression MultiplicativeExpression `*'
UnaryExpression MultiplicativeExpression `/' UnaryExpression
MultiplicativeExpression `%' UnaryExpression


File: javascript_ecma_262_5th_ed.info,  Node: Semantics,  Prev: Syntax,  Up: 115 Multiplicative Operators

183.2 Semantics
===============

The production MultiplicativeExpression : MultiplicativeExpression @
UnaryExpression, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

  1.  2. Let leftValue be GetValue (#sec-8.7.1)(left).

  3. Let right be the result of evaluating UnaryExpression.

  4. Let rightValue be GetValue (#sec-8.7.1)(right).

  5. Let leftNum be ToNumber (#sec-9.3)(leftValue).

  6. Let rightNum be ToNumber (#sec-9.3)(rightValue).

  7. Return the result of applying the specified operation (*, /, or %)
     to leftNum and rightNum. See the Notes below 11.5.1 (#sec-11.5.1),
     11.5.2 (#sec-11.5.2), 11.5.3 (#sec-11.5.3).


File: javascript_ecma_262_5th_ed.info,  Node: 1151 Applying the * Operator,  Next: 1152 Applying the / Operator,  Prev: 115 Multiplicative Operators,  Up: Top

184 11.5.1 (#sec-11.5.1) Applying the `*' Operator
**************************************************

The `*' operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

   The result of a floating-point multiplication is governed by the
rules of IEEE 754 binary double-precision arithmetic:

   * If either operand is NaN, the result is NaN.

   * The sign of the result is positive if both operands have the same
     sign, negative if the operands have different signs.

   * Multiplication of an infinity by a zero results in NaN.

   * Multiplication of an infinity by an infinity results in an
     infinity. The sign is determined by the rule already stated above.

   * Multiplication of an infinity by a finite non-zero value results
     in a signed infinity. The sign is determined by the rule already
     stated above.

   * In the remaining cases, where neither an infinity or NaN is
     involved, the product is computed and rounded to the nearest
     representable value using IEEE 754 round-to-nearest mode. If the
     magnitude is too large to represent, the result is then an
     infinity of appropriate sign. If the magnitude is too small to
     represent, the result is then a zero of appropriate sign. The
     ECMAScript language requires support of gradual underflow as
     defined by IEEE 754.


File: javascript_ecma_262_5th_ed.info,  Node: 1152 Applying the / Operator,  Next: 1153 Applying the % Operator,  Prev: 1151 Applying the * Operator,  Up: Top

185 11.5.2 (#sec-11.5.2) Applying the `/' Operator
**************************************************

The `/' operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

   * If either operand is NaN, the result is NaN.

   * The sign of the result is positive if both operands have the same
     sign, negative if the operands have different signs.

   * Division of an infinity by an infinity results in NaN.

   * Division of an infinity by a zero results in an infinity. The sign
     is determined by the rule already stated above.

   * Division of an infinity by a non-zero finite value results in a
     signed infinity. The sign is determined by the rule already stated
     above.

   * Division of a finite value by an infinity results in zero. The
     sign is determined by the rule already stated above.

   * Division of a zero by a zero results in NaN; division of zero by
     any other finite value results in zero, with the sign determined
     by the rule already stated above.

   * Division of a non-zero finite value by a zero results in a signed
     infinity. The sign is determined by the rule already stated above.

   * In the remaining cases, where neither an infinity, nor a zero, nor
     NaN is involved, the quotient is computed and rounded to the
     nearest representable value using IEEE 754 round-to-nearest mode.
     If the magnitude is too large to represent, the operation
     overflows; the result is then an infinity of appropriate sign. If
     the magnitude is too small to represent, the


File: javascript_ecma_262_5th_ed.info,  Node: 1153 Applying the % Operator,  Next: 116 Additive Operators,  Prev: 1152 Applying the / Operator,  Up: Top

186 11.5.3 (#sec-11.5.3) Applying the `%' Operator
**************************************************

The `%' operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

   NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

   The result of a floating-point remainder operation as computed by
the `%' operator is not the same as the “remainder” operation
defined by IEEE 754. The IEEE 754 “remainder” operation computes
the remainder from a rounding division, not a truncating division, and
so its behaviour is not analogous to that of the usual integer
remainder operator. Instead the ECMAScript language defines `%' on
floating-point operations to behave in a manner analogous to that of
the Java integer remainder operator; this may be compared with the C
library function fmod.

   The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

   * If either operand is NaN, the result is NaN.

   * The sign of the result equals the sign of the dividend.

   * If the dividend is an infinity, or the divisor is a zero, or both,
     the result is NaN.

   * If the dividend is finite and the divisor is an infinity, the
     result equals the dividend.

   * If the dividend is a zero and the divisor is finite, the result is
     the same as the dividend.

   * In the remaining cases, where neither an infinity, nor a zero, nor
     NaN is involved, the floating-point remainder r from a dividend n
     and a divisor d is defined by the mathematical relation r = n −
     (d × q) where q is an integer that is negative only if n/d is
     negative and positive only if n/d is positive, and whose magnitude
     is as large as possible without exceeding the magnitude of the
     true mathematical quotient of n and d.


File: javascript_ecma_262_5th_ed.info,  Node: 116 Additive Operators,  Next: 1161 The Addition operator +,  Prev: 1153 Applying the % Operator,  Up: Top

187 11.6 (#sec-11.6) Additive Operators
***************************************

* Menu:

* Syntax::


File: javascript_ecma_262_5th_ed.info,  Node: Syntax,  Up: 116 Additive Operators

187.1 Syntax
============

AdditiveExpression : MultiplicativeExpression AdditiveExpression `+'
MultiplicativeExpression AdditiveExpression `-' MultiplicativeExpression


File: javascript_ecma_262_5th_ed.info,  Node: 1161 The Addition operator +,  Next: 1162 The Subtraction Operator -,  Prev: 116 Additive Operators,  Up: Top

188 11.6.1 (#sec-11.6.1) The Addition operator ( `+' )
******************************************************

The addition operator either performs string concatenation or numeric
addition.

   The production AdditiveExpression : AdditiveExpression `+'
MultiplicativeExpression is evaluated as follows:

  1. Let lref be the result of evaluating AdditiveExpression.

  2. Let lval be GetValue (#sec-8.7.1)(lref).

  3. Let rref be the result of evaluating MultiplicativeExpression.

  4. Let rval be GetValue (#sec-8.7.1)(rref).

  5. Let lprim be ToPrimitive (#sec-9.1)(lval).

  6. Let rprim be ToPrimitive (#sec-9.1)(rval).

  7. If Type (#def-type)(lprim) is String or Type (#def-type)(rprim) is
     String, then
       1. Return the String that is the result of concatenating
          ToString (#sec-9.8)(lprim) followed by ToString
          (#sec-9.8)(rprim)

  8. Return the result of applying the addition operation to ToNumber
     (#sec-9.3)(lprim) and ToNumber (#sec-9.3)(rprim). See the Note
     below 11.6.3 (#sec-11.6.3).

   NOTE 1 No hint is provided in the calls to ToPrimitive (#sec-9.1) in
steps 5 and 6. All native ECMAScript objects except Date objects handle
the absence of a hint as if the hint Number were given; Date objects
handle the absence of a hint as if the hint String were given. Host
objects may handle the absence of a hint in some other manner.


File: javascript_ecma_262_5th_ed.info,  Node: 1162 The Subtraction Operator -,  Next: 1163 Applying the Additive Operators to Numbers,  Prev: 1161 The Addition operator +,  Up: Top

189 11.6.2 (#sec-11.6.2) The Subtraction Operator ( `-' )
*********************************************************

The production AdditiveExpression : AdditiveExpression `-'
MultiplicativeExpression is evaluated as follows:

  1. Let lref be the result of evaluating AdditiveExpression.

  2. Let lval be GetValue (#sec-8.7.1)(lref).

  3. Let rref be the result of evaluating MultiplicativeExpression.

  4. Let rval be GetValue (#sec-8.7.1)(rref).

  5. Let lnum be ToNumber (#sec-9.3)(lval).

  6. Let rnum be ToNumber (#sec-9.3)(rval).

  7. Return the result of applying the subtraction operation to lnum
     and rnum. See the note below 11.6.3 (#sec-11.6.3).

