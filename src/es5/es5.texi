@setfilename javascript_ecma_262_5th_ed.info
@node Top
@top ECMAScript Language Specification (ECMA-262 5th Edition)

@strong{This is @emph{not} the official ECMAScript Language Specification.}

The official specification is the PDF document located at @uref{http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf,http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf}.

This HTML version was created from the original PDF version by a preposterous concatenation of hacks. It very likely contains errors and the official standard and errata are of course definitive. For copyright information@comma{} see @uref{#ecma-disclaimer,ECMA's legal disclaimer} in the document itself.

This version was created by Jason Orendorff and incorporates the official @uref{http://wiki.ecmascript.org/lib/exe/fetch.php?id=es3.1%3Aes3.1_proposal_working_draft&cache=cache&media=resources:es5_errata_7-31-10.pdf,errata} as of 31@ July 2010.

Last updated: 5 November 2010.

PDF page 1
@menu
* ECMA-262 5th Edition / December 2009 ECMAScript Language Specification::
* Contents::
* Introduction::
* 1 Scope::
* 2 Conformance::
* 3 Normative references::
* 4 Overview::
* 41 Web Scripting::
* 42 Language Overview::
* 421 Objects::
* 422 The Strict Variant of ECMAScript::
* 43 Definitions::
* 431 type::
* 432 primitive value::
* 433 object::
* 434 constructor::
* 435 prototype::
* 436 native object::
* 437 built-in object::
* 438 host object::
* 439 undefined value::
* 4310 Undefined type::
* 4311 null value::
* 4312 Null type::
* 4313 Boolean value::
* 4314 Boolean type::
* 4315 Boolean object::
* 4316 String value::
* 4317 String type::
* 4318 String object::
* 4319 Number value::
* 4320 Number type::
* 4321 Number object::
* 4322 Infinity::
* 4323 NaN::
* 4324 function::
* 4325 built-in function::
* 4326 property::
* 4327 method::
* 4328 built-in method::
* 4329 attribute::
* 4330 own property::
* 4331 inherited property::
* 5 Notational Conventions::
* 51 Syntactic and Lexical Grammars::
* 511 Context-Free Grammars::
* 512 The Lexical and RegExp Grammars::
* 513 The Numeric String Grammar::
* 514 The Syntactic Grammar::
* 515 The JSON Grammar::
* 516 Grammar Notation::
* 52 Algorithm Conventions::
* 6 Source Text::
* 7 Lexical Conventions::
* 71 Unicode Format-Control Characters::
* 72 White Space::
* 73 Line Terminators::
* 74 Comments::
* 75 Tokens::
* 76 Identifier Names and Identifiers::
* 761 Reserved Words::
* 7611 Keywords::
* 7612 Future Reserved Words::
* 77 Punctuators::
* 78 Literals::
* 781 Null Literals::
* 782 Boolean Literals::
* 783 Numeric Literals::
* 784 String Literals::
* 785 Regular Expression Literals::
* 79 Automatic Semicolon Insertion::
* 791 Rules of Automatic Semicolon Insertion::
* 792 Examples of Automatic Semicolon Insertion::
* 8 Types::
* 81 The Undefined Type::
* 82 The Null Type::
* 83 The Boolean Type::
* 84 The String Type::
* 85 The Number Type::
* 86 The Object Type::
* 861 Property Attributes::
* 862 Object Internal Properties and Methods::
* 87 The Reference Specification Type::
* 871 GetValue V::
* 872 PutValue V W::
* 88 The List Specification Type::
* 89 The Completion Specification Type::
* 810 The Property Descriptor and Property Identifier Specification Types::
* 8101 IsAccessorDescriptor  Desc ::
* 8102 IsDataDescriptor  Desc ::
* 8103 IsGenericDescriptor  Desc ::
* 8104 FromPropertyDescriptor  Desc ::
* 8105 ToPropertyDescriptor  Obj ::
* 811 The Lexical Environment and Environment Record Specification Types::
* 812 Algorithms for Object Internal Methods::
* 8121 [[GetOwnProperty]] P::
* 8122 [[GetProperty]] P::
* 8123 [[Get]] P::
* 8124 [[CanPut]] P::
* 8125 [[Put]]  P V Throw ::
* 8126 [[HasProperty]] P::
* 8127 [[Delete]] P Throw::
* 8128 [[DefaultValue]] hint::
* 8129 [[DefineOwnProperty]] P Desc Throw::
* 9 Type Conversion and Testing::
* 91 ToPrimitive::
* 92 ToBoolean::
* 93 ToNumber::
* 931 ToNumber Applied to the String Type::
* 94 ToInteger::
* 95 ToInt32 Signed 32 Bit Integer::
* 96 ToUint32 Unsigned 32 Bit Integer::
* 97 ToUint16 Unsigned 16 Bit Integer::
* 98 ToString::
* 981 ToString Applied to the Number Type::
* 99 ToObject::
* 910 CheckObjectCoercible::
* 911 IsCallable::
* 912 The SameValue Algorithm::
* 10 Executable Code and Execution Contexts::
* 101 Types of Executable Code::
* 1011 Strict Mode Code::
* 102 Lexical Environments::
* 1021 Environment Records::
* 10211 Declarative Environment Records::
* 102111 HasBindingN::
* 102112 CreateMutableBinding N D::
* 102113 SetMutableBindingNVS::
* 102114 GetBindingValueNS::
* 102115 DeleteBinding N::
* 102116 ImplicitThisValue::
* 102117 CreateImmutableBinding N::
* 102118 InitializeImmutableBinding NV::
* 10212 Object Environment Records::
* 102121 HasBindingN::
* 102122 CreateMutableBinding N D::
* 102123 SetMutableBinding NVS::
* 102124 GetBindingValueNS::
* 102125 DeleteBindingN::
* 102126 ImplicitThisValue::
* 1022 Lexical Environment Operations::
* 10221 GetIdentifierReference lex name strict::
* 10222 NewDeclarativeEnvironmentE::
* 10223 NewObjectEnvironment O E::
* 1023 The Global Environment::
* 103 Execution Contexts::
* 1031 Identifier Resolution::
* 104 Establishing an Execution Context::
* 1041 Entering Global Code::
* 10411 Initial Global Execution Context::
* 1042 Entering Eval Code::
* 10421 Strict Mode Restrictions::
* 1043 Entering Function Code::
* 105 Declaration Binding Instantiation::
* 106 Arguments Object::
* 11 Expressions::
* 111 Primary Expressions::
* 1111 The this Keyword::
* 1112 Identifier Reference::
* 1113 Literal Reference::
* 1114 Array Initialiser::
* 1115 Object Initialiser::
* 1116 The Grouping Operator::
* 112 Left-Hand-Side Expressions::
* 1121 Property Accessors::
* 1122 The new Operator::
* 1123 Function Calls::
* 1124 Argument Lists::
* 1125 Function Expressions::
* 113 Postfix Expressions::
* 1131 Postfix Increment Operator::
* 1132 Postfix Decrement Operator::
* 114 Unary Operators::
* 1141 The delete Operator::
* 1142 The void Operator::
* 1143 The typeof Operator::
* 1144 Prefix Increment Operator::
* 1145 Prefix Decrement Operator::
* 1146 Unary + Operator::
* 1147 Unary - Operator::
* 1148 Bitwise NOT Operator  ~ ::
* 1149 Logical NOT Operator  ! ::
* 115 Multiplicative Operators::
* 1151 Applying the * Operator::
* 1152 Applying the / Operator::
* 1153 Applying the % Operator::
* 116 Additive Operators::
* 1161 The Addition operator  + ::
* 1162 The Subtraction Operator  - ::
* 1163 Applying the Additive Operators to Numbers::
* 117 Bitwise Shift Operators::
* 1171 The Left Shift Operator  << ::
* 1172 The Signed Right Shift Operator  >> ::
* 1173 The Unsigned Right Shift Operator  >>> ::
* 118 Relational Operators::
* 1181 The Less-than Operator  < ::
* 1182 The Greater-than Operator  > ::
* 1183 The Less-than-or-equal Operator  <= ::
* 1184 The Greater-than-or-equal Operator  >= ::
* 1185 The Abstract Relational Comparison Algorithm::
* 1186 The instanceof operator::
* 1187 The in operator::
* 119 Equality Operators::
* 1191 The Equals Operator  == ::
* 1192 The Does-not-equals Operator  != ::
* 1193 The Abstract Equality Comparison Algorithm::
* 1194 The Strict Equals Operator  === ::
* 1195 The Strict Does-not-equal Operator  !== ::
* 1196 The Strict Equality Comparison Algorithm::
* 1110 Binary Bitwise Operators::
* 1111 Binary Logical Operators::
* 1112 Conditional Operator  ?  ::
* 1113 Assignment Operators::
* 11131 Simple Assignment  = ::
* 11132 Compound Assignment  <var>op</var>= ::
* 1114 Comma Operator   ::
* 12 Statements::
* 121 Block::
* 122 Variable Statement::
* 1221 Strict Mode Restrictions::
* 123 Empty Statement::
* 124 Expression Statement::
* 125 The if Statement::
* 126 Iteration Statements::
* 1261 The do–while Statement::
* 1262 The while Statement::
* 1263 The for Statement::
* 1264 The for–in Statement::
* 127 The continue Statement::
* 128 The break Statement::
* 129 The return Statement::
* 1210 The with Statement::
* 12101 Strict Mode Restrictions::
* 1211 The switch Statement::
* 1212 Labelled Statements::
* 1213 The throw Statement::
* 1214 The try Statement::
* 12141 Strict Mode Restrictions::
* 1215 The debugger statement::
* 13 Function Definition::
* 131 Strict Mode Restrictions::
* 132 Creating Function Objects::
* 1321 [[Call]]::
* 1322 [[Construct]]::
* 1323 The [[ThrowTypeError]] Function Object::
* 14 Program::
* 141 Directive Prologues and the Use Strict Directive::
* 15 Standard Built-in ECMAScript Objects::
* 151 The Global Object::
* 1511 Value Properties of the Global Object::
* 15111 NaN::
* 15112 Infinity::
* 15113 undefined::
* 1512 Function Properties of the Global Object::
* 15121 eval x::
* 151211 Direct Call to Eval::
* 15122 parseInt string  radix::
* 15123 parseFloatstring::
* 15124 isNaN number::
* 15125 isFinitenumber::
* 1513 URI Handling Function Properties::
* 15131 decodeURI encodedURI::
* 15132 decodeURIComponent encodedURIComponent::
* 15133 encodeURI uri::
* 15134 encodeURIComponent uriComponent::
* 1514 Constructor Properties of the Global Object::
* 15141 Object     ::
* 15142 Function     ::
* 15143 Array     ::
* 15144 String     ::
* 15145 Boolean     ::
* 15146 Number     ::
* 15147 Date     ::
* 15148 RegExp     ::
* 15149 Error     ::
* 151410 EvalError     ::
* 151411 RangeError     ::
* 151412 ReferenceError     ::
* 151413 SyntaxError     ::
* 151414 TypeError     ::
* 151415 URIError     ::
* 1515 Other Properties of the Global Object::
* 15151 Math::
* 15152 JSON::
* 152 Object Objects::
* 1521 The Object Constructor Called as a Function::
* 15211 Object  [ value ] ::
* 1522 The Object Constructor::
* 15221 new Object  [ value ] ::
* 1523 Properties of the Object Constructor::
* 15231 Objectprototype::
* 15232 ObjectgetPrototypeOf  O ::
* 15233 ObjectgetOwnPropertyDescriptor  O P ::
* 15234 ObjectgetOwnPropertyNames  O ::
* 15235 Objectcreate  O [ Properties] ::
* 15236 ObjectdefineProperty  O P Attributes ::
* 15237 ObjectdefineProperties  O Properties ::
* 15238 Objectseal  O ::
* 15239 Objectfreeze  O ::
* 152310 ObjectpreventExtensions  O ::
* 152311 ObjectisSealed  O ::
* 152312 ObjectisFrozen  O ::
* 152313 ObjectisExtensible  O ::
* 152314 Objectkeys  O ::
* 1524 Properties of the Object Prototype Object::
* 15241 Objectprototypeconstructor::
* 15242 ObjectprototypetoString  ::
* 15243 ObjectprototypetoLocaleString  ::
* 15244 ObjectprototypevalueOf  ::
* 15245 ObjectprototypehasOwnProperty V::
* 15246 ObjectprototypeisPrototypeOf V::
* 15247 ObjectprototypepropertyIsEnumerable V::
* 1525 Properties of Object Instances::
* 153 Function Objects::
* 1531 The Function Constructor Called as a Function::
* 15311 Function p1 p2   pn body::
* 1532 The Function Constructor::
* 15321 new Function p1 p2   pn body::
* 1533 Properties of the Function Constructor::
* 15331 Functionprototype::
* 15332 Functionlength::
* 1534 Properties of the Function Prototype Object::
* 15341 Functionprototypeconstructor::
* 15342 FunctionprototypetoString  ::
* 15343 Functionprototypeapply thisArg argArray::
* 15344 Functionprototypecall thisArg [  arg1 [  arg2  ] ] ::
* 15345 Functionprototypebind thisArg [ arg1 [ arg2 ]]::
* 153451 [[Call]]::
* 153452 [[Construct]]::
* 153453 [[HasInstance]] V::
* 1535 Properties of Function Instances::
* 15351 length::
* 15352 prototype::
* 15353 [[HasInstance]] V::
* 15354 [[Get]] P::
* 154 Array Objects::
* 1541 The Array Constructor Called as a Function::
* 15411 Array  [ item1 [  item2 [   ] ] ] ::
* 1542 The Array Constructor::
* 15421 new Array  [ item0 [  item1 [   ] ] ] ::
* 15422 new Array len::
* 1543 Properties of the Array Constructor::
* 15431 Arrayprototype::
* 15432 ArrayisArray  arg ::
* 1544 Properties of the Array Prototype Object::
* 15441 Arrayprototypeconstructor::
* 15442 ArrayprototypetoString  ::
* 15443 ArrayprototypetoLocaleString  ::
* 15444 Arrayprototypeconcat  [ item1 [  item2 [   ] ] ] ::
* 15445 Arrayprototypejoin separator::
* 15446 Arrayprototypepop  ::
* 15447 Arrayprototypepush  [ item1 [  item2 [   ] ] ] ::
* 15448 Arrayprototypereverse  ::
* 15449 Arrayprototypeshift  ::
* 154410 Arrayprototypeslice start end::
* 154411 Arrayprototypesort comparefn::
* 154412 Arrayprototypesplice start deleteCount [  item1 [  item2 [   ] ] ] ::
* 154413 Arrayprototypeunshift  [ item1 [  item2 [   ] ] ] ::
* 154414 ArrayprototypeindexOf  searchElement [  fromIndex ] ::
* 154415 ArrayprototypelastIndexOf  searchElement [  fromIndex ] ::
* 154416 Arrayprototypeevery  callbackfn [  thisArg ] ::
* 154417 Arrayprototypesome  callbackfn [  thisArg ] ::
* 154418 ArrayprototypeforEach  callbackfn [  thisArg ] ::
* 154419 Arrayprototypemap  callbackfn [  thisArg ] ::
* 154420 Arrayprototypefilter  callbackfn [  thisArg ] ::
* 154421 Arrayprototypereduce  callbackfn [  initialValue ] ::
* 154422 ArrayprototypereduceRight  callbackfn [  initialValue ] ::
* 1545 Properties of Array Instances::
* 15451 [[DefineOwnProperty]]  P Desc Throw ::
* 15452 length::
* 155 String Objects::
* 1551 The String Constructor Called as a Function::
* 15511 String  [ value ] ::
* 1552 The String Constructor::
* 15521 new String  [ value ] ::
* 1553 Properties of the String Constructor::
* 15531 Stringprototype::
* 15532 StringfromCharCode  [ char0 [  char1 [   ] ] ] ::
* 1554 Properties of the String Prototype Object::
* 15541 Stringprototypeconstructor::
* 15542 StringprototypetoString  ::
* 15543 StringprototypevalueOf  ::
* 15544 StringprototypecharAt pos::
* 15545 StringprototypecharCodeAt pos::
* 15546 Stringprototypeconcat  [ string1 [  string2 [   ] ] ] ::
* 15547 StringprototypeindexOf searchString position::
* 15548 StringprototypelastIndexOf searchString position::
* 15549 StringprototypelocaleCompare that::
* 155410 Stringprototypematch regexp::
* 155411 Stringprototypereplace searchValue replaceValue::
* 155412 Stringprototypesearch regexp::
* 155413 Stringprototypeslice start end::
* 155414 Stringprototypesplit separator limit::
* 155415 Stringprototypesubstring start end::
* 155416 StringprototypetoLowerCase  ::
* 155417 StringprototypetoLocaleLowerCase  ::
* 155418 StringprototypetoUpperCase  ::
* 155419 StringprototypetoLocaleUpperCase  ::
* 155420 Stringprototypetrim  ::
* 1555 Properties of String Instances::
* 15551 length::
* 15552 [[GetOwnProperty]]  P ::
* 156 Boolean Objects::
* 1561 The Boolean Constructor Called as a Function::
* 15611 Boolean value::
* 1562 The Boolean Constructor::
* 15621 new Boolean value::
* 1563 Properties of the Boolean Constructor::
* 15631 Booleanprototype::
* 1564 Properties of the Boolean Prototype Object::
* 15641 Booleanprototypeconstructor::
* 15642 BooleanprototypetoString  ::
* 15643 BooleanprototypevalueOf  ::
* 1565 Properties of Boolean Instances::
* 157 Number Objects::
* 1571 The Number Constructor Called as a Function::
* 15711 Number  [ value ] ::
* 1572 The Number Constructor::
* 15721 new Number  [ value ] ::
* 1573 Properties of the Number Constructor::
* 15731 Numberprototype::
* 15732 NumberMAX_VALUE::
* 15733 NumberMIN_VALUE::
* 15734 NumberNaN::
* 15735 NumberNEGATIVE_INFINITY::
* 15736 NumberPOSITIVE_INFINITY::
* 1574 Properties of the Number Prototype Object::
* 15741 Numberprototypeconstructor::
* 15742 NumberprototypetoString  [ radix ] ::
* 15743 NumberprototypetoLocaleString::
* 15744 NumberprototypevalueOf  ::
* 15745 NumberprototypetoFixed fractionDigits::
* 15746 NumberprototypetoExponential fractionDigits::
* 15747 NumberprototypetoPrecision precision::
* 1575 Properties of Number Instances::
* 158 The Math Object::
* 1581 Value Properties of the Math Object::
* 15811 E::
* 15812 LN10::
* 15813 LN2::
* 15814 LOG2E::
* 15815 LOG10E::
* 15816 PI::
* 15817 SQRT1_2::
* 15818 SQRT2::
* 1582 Function Properties of the Math Object::
* 15821 abs x::
* 15822 acos x::
* 15823 asin x::
* 15824 atan x::
* 15825 atan2 y x::
* 15826 ceil x::
* 15827 cosx::
* 15828 expx::
* 15829 floor x::
* 158210 log x::
* 158211 max  [ value1 [  value2 [   ] ] ] ::
* 158212 min  [ value1 [  value2 [   ] ] ] ::
* 158213 pow x y::
* 158214 random  ::
* 158215 round x::
* 158216 sin x::
* 158217 sqrt x::
* 158218 tan x::
* 159 Date Objects::
* 1591 Overview of Date Objects and Definitions of Abstract Operators::
* 15911 Time Values and Time Range::
* 15912 Day Number and Time within Day::
* 15913 Year Number::
* 15914 Month Number::
* 15915 Date Number::
* 15916 Week Day::
* 15917 Local Time Zone Adjustment::
* 15918 Daylight Saving Time Adjustment::
* 15919 Local Time::
* 159110 Hours Minutes Second and Milliseconds::
* 159111 MakeTime hour min sec ms::
* 159112 MakeDay year month date::
* 159113 MakeDate day time::
* 159114 TimeClip time::
* 159115 Date Time String Format::
* 1591151 Extended years::
* 1592 The Date Constructor Called as a Function::
* 15921 Date  [ year [ month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ] ] ::
* 1593 The Date Constructor::
* 15931 new Date year month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ::
* 15932 new Date value::
* 15933 new Date  ::
* 1594 Properties of the Date Constructor::
* 15941 Dateprototype::
* 15942 Dateparse string::
* 15943 DateUTC year month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ::
* 15944 Datenow  ::
* 1595 Properties of the Date Prototype Object::
* 15951 Dateprototypeconstructor::
* 15952 DateprototypetoString  ::
* 15953 DateprototypetoDateString  ::
* 15954 DateprototypetoTimeString  ::
* 15955 DateprototypetoLocaleString  ::
* 15956 DateprototypetoLocaleDateString  ::
* 15957 DateprototypetoLocaleTimeString  ::
* 15958 DateprototypevalueOf  ::
* 15959 DateprototypegetTime  ::
* 159510 DateprototypegetFullYear  ::
* 159511 DateprototypegetUTCFullYear  ::
* 159512 DateprototypegetMonth  ::
* 159513 DateprototypegetUTCMonth  ::
* 159514 DateprototypegetDate  ::
* 159515 DateprototypegetUTCDate  ::
* 159516 DateprototypegetDay  ::
* 159517 DateprototypegetUTCDay  ::
* 159518 DateprototypegetHours  ::
* 159519 DateprototypegetUTCHours  ::
* 159520 DateprototypegetMinutes  ::
* 159521 DateprototypegetUTCMinutes  ::
* 159522 DateprototypegetSeconds  ::
* 159523 DateprototypegetUTCSeconds  ::
* 159524 DateprototypegetMilliseconds  ::
* 159525 DateprototypegetUTCMilliseconds  ::
* 159526 DateprototypegetTimezoneOffset  ::
* 159527 DateprototypesetTime time::
* 159528 DateprototypesetMilliseconds ms::
* 159529 DateprototypesetUTCMilliseconds ms::
* 159530 DateprototypesetSeconds sec [ ms ] ::
* 159531 DateprototypesetUTCSeconds sec [ ms ] ::
* 159532 DateprototypesetMinutes min [ sec [ ms ] ] ::
* 159533 DateprototypesetUTCMinutes min [ sec [ ms ] ] ::
* 159534 DateprototypesetHours hour [ min [ sec [ ms ] ] ] ::
* 159535 DateprototypesetUTCHours hour [ min [ sec [ ms ] ] ] ::
* 159536 DateprototypesetDate date::
* 159537 DateprototypesetUTCDate date::
* 159538 DateprototypesetMonth month [ date ] ::
* 159539 DateprototypesetUTCMonth month [ date ] ::
* 159540 DateprototypesetFullYear year [ month [ date ] ] ::
* 159541 DateprototypesetUTCFullYear year [ month [ date ] ] ::
* 159542 DateprototypetoUTCString  ::
* 159543 DateprototypetoISOString  ::
* 159544 DateprototypetoJSON  key ::
* 1596 Properties of Date Instances::
* 1510 RegExp Regular Expression Objects::
* 15101 Patterns::
* 15102 Pattern Semantics::
* 151021 Notation::
* 151022 Pattern::
* 151023 Disjunction::
* 151024 Alternative::
* 151025 Term::
* 151026 Assertion::
* 151027 Quantifier::
* 151028 Atom::
* 151029 AtomEscape::
* 1510210 CharacterEscape::
* 1510211 DecimalEscape::
* 1510212 CharacterClassEscape::
* 1510213 CharacterClass::
* 1510214 ClassRanges::
* 1510215 NonemptyClassRanges::
* 1510216 NonemptyClassRangesNoDash::
* 1510217 ClassAtom::
* 1510218 ClassAtomNoDash::
* 1510219 ClassEscape::
* 15103 The RegExp Constructor Called as a Function::
* 151031 RegExppattern flags::
* 15104 The RegExp Constructor::
* 151041 new RegExppattern flags::
* 15105 Properties of the RegExp Constructor::
* 151051 RegExpprototype::
* 15106 Properties of the RegExp Prototype Object::
* 151061 RegExpprototypeconstructor::
* 151062 RegExpprototypeexecstring::
* 151063 RegExpprototypeteststring::
* 151064 RegExpprototypetoString::
* 15107 Properties of RegExp Instances::
* 151071 source::
* 151072 global::
* 151073 ignoreCase::
* 151074 multiline::
* 151075 lastIndex::
* 1511 Error Objects::
* 15111 The Error Constructor Called as a Function::
* 151111 Error message::
* 15112 The Error Constructor::
* 151121 new Error message::
* 15113 Properties of the Error Constructor::
* 151131 Errorprototype::
* 15114 Properties of the Error Prototype Object::
* 151141 Errorprototypeconstructor::
* 151142 Errorprototypename::
* 151143 Errorprototypemessage::
* 151144 ErrorprototypetoString  ::
* 15115 Properties of Error Instances::
* 15116 Native Error Types Used in This Standard::
* 151161 EvalError::
* 151162 RangeError::
* 151163 ReferenceError::
* 151164 SyntaxError::
* 151165 TypeError::
* 151166 URIError::
* 15117 NativeError Object Structure::
* 151171 NativeError Constructors Called as Functions::
* 151172 NativeError message::
* 151173 The NativeError Constructors::
* 151174 New NativeError message::
* 151175 Properties of the NativeError Constructors::
* 151176 NativeErrorprototype::
* 151177 Properties of the NativeError Prototype Objects::
* 151178 NativeErrorprototypeconstructor::
* 151179 NativeErrorprototypename::
* 1511710 NativeErrorprototypemessage::
* 1511711 Properties of NativeError Instances::
* 1512 The JSON Object::
* 15121 The JSON Grammar::
* 151211 The JSON Lexical Grammar::
* 151212 The JSON Syntactic Grammar::
* 15122 parse  text [  reviver ] ::
* 15123 stringify  value [  replacer [  space ] ] ::
* 16 Errors::
* Annex A informative Grammar Summary::
* A1 Lexical Grammar::
* A2 Number Conversions::
* A3 Expressions::
* A4 Statements::
* A5 Functions and Programs::
* A6 Universal Resource Identifier Character Classes::
* A7 Regular Expressions::
* A8 JSON::
* A81 JSON Lexical Grammar::
* A82 JSON Syntactic Grammar::
* Annex B informative Compatibility::
* B1 Additional Syntax::
* B11 Numeric Literals::
* B12 String Literals::
* B2 Additional Properties::
* B21 escape string::
* B22 unescape string::
* B23 Stringprototypesubstr start length::
* B24 DateprototypegetYear  ::
* B25 DateprototypesetYear year::
* B26 DateprototypetoGMTString  ::
* Annex C informative The Strict Mode of ECMAScript::
* Annex D informative Corrections and Clarifications in the 5th Edition with Possible 3rd Edition Compatibility Impact::
* Annex E informative Additions and Changes in the 5th Edition that Introduce Incompatibilities with the 3rd Edition::
* Bibliography::
@end menu

@node ECMA-262 5th Edition / December 2009 ECMAScript Language Specification
@chapter ECMA-262 5th Edition / December 2009 ECMAScript Language Specification
Reference number ECMA-123:2009

COPYRIGHT PROTECTED DOCUMENT
© Ecma International 2009

@node Contents
@chapter Contents
@enumerate
@item
@uref{#introduction,Introduction}
@item
@uref{#sec-1,1 Scope}
@item
@uref{#sec-2,2 Conformance}
@item
@uref{#sec-3,3 Normative references}
@item
@uref{#sec-4,4 Overview}
@item
@uref{#sec-5,5 Notational Conventions}
@item
@uref{#sec-6,6 Source Text}
@item
@uref{#sec-7,7 Lexical Conventions}
@item
@uref{#sec-8,8 Types}
@item
@uref{#sec-9,9 Type Conversion and Testing}
@item
@uref{#sec-10,10 Executable Code and Execution Contexts}
@item
@uref{#sec-11,11 Expressions}
@item
@uref{#sec-12,12 Statements}
@item
@uref{#sec-13,13 Function Definition}
@item
@uref{#sec-14,14 Program}
@item
@uref{#sec-15,15 Standard Built-in ECMAScript Objects}
@item
@uref{#sec-16,16 Errors}
@item
@uref{#sec-A,Annex A (informative) Grammar Summary}
@item
@uref{#sec-B,Annex B (informative) Compatibility}
@item
@uref{#sec-C,Annex C (informative) The Strict Mode of ECMAScript}
@item
@uref{#sec-D,Annex D (informative) Corrections and Clarifications in the 5th Edition with Possible 3rd Edition Compatibility Impact}
@item
@uref{#sec-E,Annex E (informative) Additions and Changes in the 5th Edition that Introduce Incompatibilities with the 3rd Edition}
@item
@uref{#bibliography,Bibliography}
@end enumerate



@node Introduction
@chapter Introduction
This Ecma Standard is based on several originating technologies@comma{} the most well known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company’s Navigator 2.0 browser. It has appeared in all subsequent browsers from Netscape and in all browsers from Microsoft starting with Internet Explorer 3.0.

The development of this Standard started in November 1996. The first edition of this Ecma Standard was adopted by the Ecma General Assembly of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure@comma{} and approved as international standard ISO/IEC 16262@comma{} in April 1998. The Ecma General Assembly of June 1998 approved the second edition of ECMA-262 to keep it fully aligned with ISO/IEC 16262. Changes between the first and the second edition are editorial in nature.

The third edition of the Standard introduced powerful regular expressions@comma{} better string handling@comma{} new control statements@comma{} try/catch exception handling@comma{} tighter definition of errors@comma{} formatting for numeric output and minor changes in anticipation of forthcoming internationalisation facilities and future language growth. The third edition of the ECMAScript standard was adopted by the Ecma General Assembly of December 1999 and published as ISO/IEC 16262:2002 in June 2002.

Since publication of the third edition@comma{} ECMAScript has achieved massive adoption in conjunction with the World Wide Web where it has become the programming language that is supported by essentially all web browsers. Significant work was done to develop a fourth edition of ECMAScript. Although that work was not completed and not published[@uref{#footnote1,1}] as the fourth edition of ECMAScript@comma{} it informs continuing evolution of the language. The present fifth edition of ECMAScript (published as ECMA-262 5th edition) codifies de facto interpretations of the language specification that have become common among browser implementations and adds support for new features that have emerged since the publication of the third edition. Such features include accessor properties@comma{} reflective creation and inspection of objects@comma{} program control of property attributes@comma{} additional array manipulation functions@comma{} support for the @uref{#sec-15.12,JSON} object encoding format@comma{} and a strict mode that provides enhanced error checking and program security.

ECMAScript is a vibrant language and the evolution of the language is not complete. Significant technical enhancement will continue with future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of December 2009.

[1]Note: Please note that for ECMAScript Edition 4 the Ecma standard number “ECMA-262 Edition 4” was reserved but not used in the Ecma publication process. Therefore “ECMA-262 Edition 4” as an Ecma International publication does not exist.


"DISCLAIMER

This document and possible translations of it may be copied and furnished to others@comma{} and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared@comma{} copied@comma{} published@comma{} and distributed@comma{} in whole or in part@comma{} without restriction of any kind@comma{} provided that the above copyright notice and this section are included on all such copies and derivative works. However@comma{} this document itself may not be modified in any way@comma{} including by removing the copyright notice or references to Ecma International@comma{} except as needed for the purpose of developing any document or deliverable produced by Ecma International (in which case the rules applied to copyrights must be followed) or as required to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked by Ecma International or its successors or assigns.

This document and the information contained herein is provided on an "AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES@comma{} EXPRESS OR IMPLIED@comma{} INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE."



@node 1 Scope
@chapter @uref{#sec-1,1} Scope
This Standard defines the ECMAScript scripting language.


@node 2 Conformance
@chapter @uref{#sec-2,2} Conformance
A conforming implementation of ECMAScript must provide and support all the types@comma{} values@comma{} objects@comma{} properties@comma{} functions@comma{} and program syntax and semantics described in this specification.

A conforming implementation of this International standard shall interpret characters in conformance with the Unicode Standard@comma{} Version 3.0 or later and ISO/IEC 10646-1 with either UCS-2 or UTF-16 as the adopted encoding form@comma{} implementation level 3. If the adopted ISO/IEC 10646-1 subset is not otherwise specified@comma{} it is presumed to be the BMP subset@comma{} collection 300. If the adopted encoding form is not otherwise specified@comma{} it presumed to be the UTF-16 encoding form.

A conforming implementation of ECMAScript is permitted to provide additional types@comma{} values@comma{} objects@comma{} properties@comma{} and functions beyond those described in this specification. In particular@comma{} a conforming implementation of ECMAScript is permitted to provide properties not described in this specification@comma{} and values for those properties@comma{} for objects that are described in this specification.

A conforming implementation of ECMAScript is permitted to support program and regular expression syntax not described in this specification. In particular@comma{} a conforming implementation of ECMAScript is permitted to support program syntax that makes use of the “future reserved words” listed in @uref{#sec-7.6.1.2,7.6.1.2} of this specification.


@node 3 Normative references
@chapter @uref{#sec-3,3} Normative references
The following referenced documents are indispensable for the application of this document. For dated references@comma{} only the edition cited applies. For undated references@comma{} the latest edition of the referenced document (including any amendments) applies.

ISO/IEC 9899:1996@comma{} Programming Languages – C@comma{} including amendment 1 and technical corrigenda 1 and@ 2

ISO/IEC 10646-1:1993@comma{} Information Technology – Universal Multiple-Octet Coded Character Set (UCS) plus its amendments and corrigenda


@node 4 Overview
@chapter @uref{#sec-4,4} Overview
This section contains a non-normative overview of the ECMAScript language.

ECMAScript is an object-oriented programming language for performing computations and manipulating computational objects within a host environment. ECMAScript as defined here is not intended to be computationally self-sufficient; indeed@comma{} there are no provisions in this specification for input of external data or output of computed results. Instead@comma{} it is expected that the computational environment of an ECMAScript program will provide not only the objects and other facilities described in this specification but also certain environment-specific host objects@comma{} whose description and behaviour are beyond the scope of this specification except to indicate that they may provide certain properties that can be accessed and certain functions that can be called from an ECMAScript program.



ECMAScript was originally designed to be a @emph{Web scripting language}@comma{} providing a mechanism to enliven Web pages in browsers and to perform server computation as part of a Web-based client-server architecture. ECMAScript can provide core scripting capabilities for a variety of host environments@comma{} and therefore the core scripting language is specified in this document apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other programming languages; in particular Java™@comma{} Self@comma{} and Scheme as described in:

Gosling@comma{} James@comma{} Bill Joy and Guy Steele. The Java™ Language Specification. Addison Wesley Publishing Co.@comma{} 1996.

Ungar@comma{} David@comma{} and Smith@comma{} Randall B. Self: The Power of Simplicity. OOPSLA ’87 Conference Proceedings@comma{} pp.@ 227-241@comma{} Orlando@comma{}@ FL@comma{} October 1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


@node 41 Web Scripting
@chapter @uref{#sec-4.1,4.1} Web Scripting
A web browser provides an ECMAScript host environment for client-side computation including@comma{} for instance@comma{} objects that represent windows@comma{} menus@comma{} pop-ups@comma{} dialog boxes@comma{} text areas@comma{} anchors@comma{} frames@comma{} history@comma{} cookies@comma{} and input/output. Further@comma{} the host environment provides a means to attach scripting code to events such as change of focus@comma{} page and image loading@comma{} unloading@comma{} error and abort@comma{} selection@comma{} form submission@comma{} and mouse actions. Scripting code appears within the HTML and the displayed page is a combination of user interface elements and fixed and computed text and images. The scripting code is reactive to user interaction and there is no need for a main program.

A web server provides a different host environment for server-side computation including objects representing requests@comma{} clients@comma{} and files; and mechanisms to lock and share data. By using browser-side and server-side scripting together@comma{} it is possible to distribute computation between the client and server while providing a customised user interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own host environment@comma{} completing the ECMAScript execution environment.


@node 42 Language Overview
@chapter @uref{#sec-4.2,4.2} Language Overview
The following is an informal overview of ECMAScript—not all parts of the language are described. This overview is not part of the standard proper.

ECMAScript is object-based: basic language and host facilities are provided by objects@comma{} and an ECMAScript program is a cluster of communicating objects. An ECMAScript @emph{object} is a collection of @emph{properties} each with zero or more @emph{attributes} that determine how each property can be used—for example@comma{} when the Writable attribute for a property is set to false@comma{} any attempt by executed ECMAScript code to change the value of the property fails. Properties are containers that hold other objects@comma{} @emph{primitive values}@comma{} or @emph{functions}. A primitive value is a member of one of the following built-in types: @strong{Undefined}@comma{} @strong{Null}@comma{} @strong{Boolean}@comma{} @strong{Number}@comma{} and @strong{String}; an object is a member of the remaining built-in type @strong{Object}; and a function is a callable object. A function that is associated with an object via a property is a @emph{method}.

ECMAScript defines a collection of @emph{built-in objects} that round out the definition of ECMAScript entities. These built-in objects include the @uref{#sec-15.1,global} object@comma{} the @uref{#sec-15.2,Object} object@comma{} the @uref{#sec-15.3,Function} object@comma{} the @uref{#sec-15.4,Array} object@comma{} the @uref{#sec-15.5,String} object@comma{} the @uref{#sec-15.6,Boolean} object@comma{} the @uref{#sec-15.7,Number} object@comma{} the @uref{#sec-15.8,Math} object@comma{} the @uref{#sec-15.9,Date} object@comma{} the @uref{#sec-15.10,RegExp} object@comma{} the

ECMAScript also defines a set of built-in @emph{operators}. ECMAScript operators include various unary operations@comma{} multiplicative operators@comma{} additive operators@comma{} bitwise shift operators@comma{} relational operators@comma{} equality operators@comma{} binary bitwise operators@comma{} binary logical operators@comma{} assignment operators@comma{} and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax is relaxed to enable it to serve as an easy-to-use scripting language. For example@comma{} a variable is not required to have its type declared nor are types associated with properties@comma{} and defined functions are not required to have their declarations appear textually before calls to them.


@node 421 Objects
@chapter @uref{#sec-4.2.1,4.2.1} Objects
ECMAScript does not use classes such as those in C++@comma{} Smalltalk@comma{} or Java. Instead objects may be created in various ways including via a literal notation or via @emph{constructors} which create objects and then execute code that initialises all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named “@code{prototype}” that is used to implement @emph{prototype-based inheritance} and @emph{shared properties}. Objects are created by using constructors in @code{new} expressions; for example@comma{} @code{new@ Date(2009@comma{}11)} creates a new Date object. Invoking a constructor without using @code{new} has consequences that depend on the constructor. For example@comma{} @code{Date()} produces a string representation of the current date and time rather than an object.

Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “@code{prototype}” property. Furthermore@comma{} a prototype may have a non-null implicit reference to its prototype@comma{} and so on; this is called the prototype chain. When a reference is made to a property in an object@comma{} that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words@comma{} first the object mentioned directly is examined for such a property; if that object contains the named property@comma{} that is the property to which the reference refers; if that object does not contain the named property@comma{} the prototype for that object is examined next; and so on.

@image{figure-1,,,An image of lots of boxes and arrows.,png}
Figure 1 — Object/Prototype Relationships
In a class-based object-oriented language@comma{} in general@comma{} state is carried by instances@comma{} methods are carried by classes@comma{} and inheritance is only of structure and behaviour. In ECMAScript@comma{} the state and methods are carried by objects@comma{} and structure@comma{} behaviour@comma{} and state are all inherited.



@strong{CF} is a constructor (and also an object). Five objects have been created by using @code{new} expressions: @strong{cf_1_}@comma{} @strong{cf_2_}@comma{} @strong{cf_3_}@comma{} @strong{cf_4_}@comma{} and @strong{cf_5_}. Each of these objects contains properties named @code{q1} and @code{q2}. The dashed lines represent the implicit prototype relationship; so@comma{} for example@comma{} @strong{cf_3_}’s prototype is @strong{CF_p_}. The constructor@comma{} @strong{CF}@comma{} has two properties itself@comma{} named @code{P1} and @code{P2}@comma{} which are not visible to @strong{CF_p_}@comma{} @strong{cf_1_}@comma{} @strong{cf_2_}@comma{} @strong{cf_3_}@comma{} @strong{cf_4_}@comma{} or @strong{cf_5_}. The property named @code{CFP1} in @strong{CF_p_} is shared by @strong{cf_1_}@comma{} @strong{cf_2_}@comma{} @strong{cf_3_}@comma{} @strong{cf_4_}@comma{} and @strong{cf_5_} (but not by @strong{CF})@comma{} as are any properties found in @strong{CF_p_}’s implicit prototype chain that are not named @code{q1}@comma{} @code{q2}@comma{} or @code{CFP1}. Notice that there is no implicit prototype link between @strong{CF} and @strong{CF_p_}.

Unlike class-based object languages@comma{} properties can be added to objects dynamically by assigning values to them. That is@comma{} constructors are not required to name or assign values to all or any of the constructed object’s properties. In the above diagram@comma{} one could add a new shared property for @strong{cf_1_}@comma{} @strong{cf_2_}@comma{} @strong{cf_3_}@comma{} @strong{cf_4_}@comma{} and @strong{cf_5_} by assigning a new value to the property in @strong{CF_p_}.


@node 422 The Strict Variant of ECMAScript
@chapter @uref{#sec-4.2.2,4.2.2} The Strict Variant of ECMAScript
The ECMAScript Language recognizes the possibility that some users of the language may wish to restrict their usage of some features available in the language. They might do so in the interests of security@comma{} to avoid what they consider to be error-prone features@comma{} to get enhanced error checking@comma{} or for other reasons of their choosing. In support of this possibility@comma{} ECMAScript defines a strict variant of the language. The strict variant of the language excludes some specific syntactic and semantic features of the regular ECMAScript language and modifies the detailed semantics of some features. The strict variant also specifies additional error conditions that must be reported by throwing error exceptions in situations that are not specified as errors by the non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the strict mode of the language. Strict mode selection and use of the strict mode syntax and semantics of ECMAScript is explicitly made at the level of individual ECMAScript code units. Because strict mode is selected at the level of a syntactic code unit@comma{} strict mode only imposes restrictions that have local effect within such a code unit. Strict mode does not restrict or modify any aspect of the ECMAScript semantics that must operate consistently across multiple code units. A complete ECMAScript program may be composed for both strict mode and non-strict mode ECMAScript code units. In this case@comma{} strict mode only applies when actually executing code that is defined within a @uref{#sec-10.1.1,strict mode code} unit.

In order to conform to this specification@comma{} an ECMAScript implementation must implement both the full unrestricted ECMAScript language and the strict mode variant of the ECMAScript language as defined by this specification. In addition@comma{} an implementation must support the combination of unrestricted and @uref{#sec-10.1.1,strict mode code} units into a single composite program.


@node 43 Definitions
@chapter @uref{#sec-4.3,4.3} Definitions
For the purposes of this document@comma{} the following terms and definitions apply.


@node 431 type
@chapter @uref{#sec-4.3.1,4.3.1} type
set of data values as defined in @uref{#sec-8,Clause 8} of this specification.


@node 432 primitive value
@chapter @uref{#sec-4.3.2,4.3.2} primitive value
member of one of the types Undefined@comma{} Null@comma{} Boolean@comma{} Number@comma{} or String as defined in @uref{#sec-8,Clause 8}.

NOTE A primitive value is a datum that is represented directly at the lowest level of the language implementation.


@node 433 object
@chapter @uref{#sec-4.3.3,4.3.3} object
member of the type Object.

NOTE An object is a collection of properties and has a single prototype object. The prototype may be the null value.



@node 434 constructor
@chapter @uref{#sec-4.3.4,4.3.4} constructor
Function object that creates and initialises objects.

NOTE The value of a constructor’s “@code{prototype}” property is a prototype object that is used to implement inheritance and shared properties.


@node 435 prototype
@chapter @uref{#sec-4.3.5,4.3.5} prototype
object that provides shared properties for other objects.

NOTE When a constructor creates an object@comma{} that object implicitly references the constructor’s “@code{prototype}” property for the purpose of resolving property references. The constructor’s “@code{prototype}” property can be referenced by the program expression @code{<var>constructor</var>.prototype}@comma{} and properties added to an object’s prototype are shared@comma{} through inheritance@comma{} by all objects sharing the prototype. Alternatively@comma{} a new object may be created with an explicitly specified prototype by using the @uref{#sec-15.2.3.5,Object.create} built-in function.


@node 436 native object
@chapter @uref{#sec-4.3.6,4.3.6} native object
object in an ECMAScript implementation whose semantics are fully defined by this specification rather than by the host environment.

NOTE Standard native objects are defined in this specification. Some native objects are built-in; others may be constructed during the course of execution of an ECMAScript program.


@node 437 built-in object
@chapter @uref{#sec-4.3.7,4.3.7} built-in object
object supplied by an ECMAScript implementation@comma{} independent of the host environment@comma{} that is present at the start of the execution of an ECMAScript program.

NOTE Standard built-in objects are defined in this specification@comma{} and an ECMAScript implementation may specify and define others. Every built-in object is a native object. A built-in constructor is a built-in object that is also a constructor.


@node 438 host object
@chapter @uref{#sec-4.3.8,4.3.8} host object
object supplied by the host environment to complete the execution environment of ECMAScript.

NOTE Any object that is not native is a host object.


@node 439 undefined value
@chapter @uref{#sec-4.3.9,4.3.9} undefined value
primitive value used when a variable has not been assigned a value.


@node 4310 Undefined type
@chapter @uref{#sec-4.3.10,4.3.10} Undefined type
type whose sole value is the undefined value.


@node 4311 null value
@chapter @uref{#sec-4.3.11,4.3.11} null value
primitive value that represents the intentional absence of any object value.


@node 4312 Null type
@chapter @uref{#sec-4.3.12,4.3.12} Null type
type whose sole value is the null value.


@node 4313 Boolean value
@chapter @uref{#sec-4.3.13,4.3.13} Boolean value
member of the Boolean type.

NOTE There are only two Boolean values@comma{} true and false.



@node 4314 Boolean type
@chapter @uref{#sec-4.3.14,4.3.14} Boolean type
type consisting of the primitive values true and false.


@node 4315 Boolean object
@chapter @uref{#sec-4.3.15,4.3.15} Boolean object
member of the Object type that is an instance of the standard built-in @uref{#sec-15.6,Boolean} constructor.

NOTE A Boolean object is created by using the @uref{#sec-15.6,Boolean} constructor in a @code{new} expression@comma{} supplying a Boolean value as an argument. The resulting object has an internal property whose value is the Boolean value. A Boolean object can be coerced to a Boolean value.


@node 4316 String value
@chapter @uref{#sec-4.3.16,4.3.16} String value
primitive value that is a finite ordered sequence of zero or more 16-bit unsigned integer.

NOTE A String value is a member of the String type. Each integer value in the sequence usually represents a single 16-bit unit of UTF-16 text. However@comma{} ECMAScript does not place any restrictions or requirements on the values except that they must be 16-bit unsigned integers.


@node 4317 String type
@chapter @uref{#sec-4.3.17,4.3.17} String type
set of all possible String values.


@node 4318 String object
@chapter @uref{#sec-4.3.18,4.3.18} String object
member of the Object type that is an instance of the standard built-in @uref{#sec-15.5,String} constructor.

NOTE A String object is created by using the @uref{#sec-15.5,String} constructor in a @code{new} expression@comma{} supplying a String value as an argument. The resulting object has an internal property whose value is the String value. A String object can be coerced to a String value by calling the String constructor as a function (@uref{#sec-15.5.1,15.5.1}).


@node 4319 Number value
@chapter @uref{#sec-4.3.19,4.3.19} Number value
primitive value corresponding to a double-precision 64-bit binary format IEEE 754 value.

NOTE A Number value is a member of the Number type and is a direct representation of a number.


@node 4320 Number type
@chapter @uref{#sec-4.3.20,4.3.20} Number type
set of all possible Number values including the special “Not-a-Number” (NaN) values@comma{} positive infinity@comma{} and negative infinity.


@node 4321 Number object
@chapter @uref{#sec-4.3.21,4.3.21} Number object
member of the Object type that is an instance of the standard built-in @uref{#sec-15.7,Number} constructor.

NOTE A Number object is created by using the @uref{#sec-15.7,Number} constructor in a @code{new} expression@comma{} supplying a Number value as an argument. The resulting object has an internal property whose value is the Number value. A Number object can be coerced to a Number value by calling the Number constructor as a function (@uref{#sec-15.7.1,15.7.1}).


@node 4322 Infinity
@chapter @uref{#sec-4.3.22,4.3.22} Infinity
Number value that is the positive infinite Number value.


@node 4323 NaN
@chapter @uref{#sec-4.3.23,4.3.23} NaN
Number value that is a IEEE 754 “Not-a-Number” value.



@node 4324 function
@chapter @uref{#sec-4.3.24,4.3.24} function
member of the Object type that is an instance of the standard built-in @uref{#sec-15.3,Function} constructor and that may be invoked as a subroutine.

NOTE In addition to its named properties@comma{} a function contains executable code and state that determine how it behaves when invoked. A function’s code may or may not be written in ECMAScript.


@node 4325 built-in function
@chapter @uref{#sec-4.3.25,4.3.25} built-in function
built-in object that is a function.

NOTE Examples of built-in functions include @uref{#sec-15.1.2.2,parseInt} and @uref{#sec-15.8.2.8,Math.exp}. An implementation may provide implementation-dependent built-in functions that are not described in this specification.


@node 4326 property
@chapter @uref{#sec-4.3.26,4.3.26} property
association between a name and a value that is a part of an object.

NOTE Depending upon the form of the property the value may be represented either directly as a data value (a primitive value@comma{} an object@comma{} or a function object) or indirectly by a pair of accessor functions.


@node 4327 method
@chapter @uref{#sec-4.3.27,4.3.27} method
function that is the value of a property.

NOTE When a function is called as a method of an object@comma{} the object is passed to the function as its this value.


@node 4328 built-in method
@chapter @uref{#sec-4.3.28,4.3.28} built-in method
@uref{#sec-4.3.27,method} that is a @uref{#sec-4.3.25,built-in function}.

NOTE Standard built-in methods are defined in this specification@comma{} and an ECMAScript implementation may specify and provide other additional built-in methods.


@node 4329 attribute
@chapter @uref{#sec-4.3.29,4.3.29} attribute
internal value that defines some characteristic of a property.


@node 4330 own property
@chapter @uref{#sec-4.3.30,4.3.30} own property
property that is directly contained by its object.


@node 4331 inherited property
@chapter @uref{#sec-4.3.31,4.3.31} inherited property
property of an object that is not an own property but is a property (either own or inherited) of the object’s prototype.


@node 5 Notational Conventions
@chapter @uref{#sec-5,5} Notational Conventions

@node 51 Syntactic and Lexical Grammars
@chapter @uref{#sec-5.1,5.1} Syntactic and Lexical Grammars

@node 511 Context-Free Grammars
@chapter @uref{#sec-5.1.1,5.1.1} Context-Free Grammars
A context-free grammar consists of a number of productions. Each production has an abstract symbol called a nonterminal as its left-hand side@comma{} and a sequence of zero or more nonterminal and terminal symbols as its right-hand side. For each grammar@comma{} the terminal symbols are drawn from a specified alphabet.




@node 512 The Lexical and RegExp Grammars
@chapter @uref{#sec-5.1.2,5.1.2} The Lexical and RegExp Grammars
A lexical grammar for ECMAScript is given in @uref{#sec-7,clause 7}. This grammar has as its terminal symbols characters (Unicode code units) that conform to the rules for SourceCharacter defined in @uref{#sec-6,Clause 6}. It defines a set of productions@comma{} starting from the goal symbol InputElementDiv or InputElementRegExp@comma{} that describe how sequences of such characters are translated into a sequence of input elements.

Input elements other than white space and comments form the terminal symbols for the syntactic grammar for ECMAScript and are called ECMAScript tokens. These tokens are the reserved words@comma{} identifiers@comma{} literals@comma{} and punctuators of the ECMAScript language. Moreover@comma{} line terminators@comma{} although not considered to be tokens@comma{} also become part of the stream of input elements and guide the process of @uref{#sec-7.9,automatic semicolon insertion (7.9)}. Simple white space and single-line comments are discarded and do not appear in the stream of input elements for the syntactic grammar. A MultiLineComment (that is@comma{} a comment of the form “@code{/*...*/}” regardless of whether it spans more than one line) is likewise simply discarded if it contains no line terminator; but if a MultiLineComment contains one or more line terminators@comma{} then it is replaced by a single line terminator@comma{} which becomes part of the stream of input elements for the syntactic grammar.

A RegExp grammar for ECMAScript is given in @uref{#sec-15.10,15.10}. This grammar also has as its terminal symbols the characters as defined by SourceCharacter. It defines a set of productions@comma{} starting from the goal symbol Pattern@comma{} that describe how sequences of characters are translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by having two colons “::” as separating punctuation. The lexical and RegExp grammars share some productions.


@node 513 The Numeric String Grammar
@chapter @uref{#sec-5.1.3,5.1.3} The Numeric String Grammar
Another grammar is used for translating Strings into numeric values. This grammar is similar to the part of the lexical grammar having to do with numeric literals and has as its terminal symbols SourceCharacter. This grammar appears in @uref{#sec-9.3.1,9.3.1}.

Productions of the numeric string grammar are distinguished by having three colons “:::” as punctuation.


@node 514 The Syntactic Grammar
@chapter @uref{#sec-5.1.4,5.1.4} The Syntactic Grammar
The syntactic grammar for ECMAScript is given in clauses @uref{#sec-11,11}@comma{} @uref{#sec-12,12}@comma{} @uref{#sec-13,13} and @uref{#sec-14,14}. This grammar has ECMAScript tokens defined by the lexical grammar as its terminal symbols (@uref{#sec-5.1.2,5.1.2}). It defines a set of productions@comma{} starting from the goal symbol Program@comma{} that describe how sequences of tokens can form syntactically correct ECMAScript programs.

When a stream of characters is to be parsed as an ECMAScript program@comma{} it is first converted to a stream of input elements by repeated application of the lexical grammar; this stream of input elements is then parsed by a single application of the syntactic grammar. The program is syntactically in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal Program@comma{} with no tokens left over.

Productions of the syntactic grammar are distinguished by having just one colon “:” as punctuation.

The syntactic grammar as presented in clauses @uref{#sec-11,11}@comma{} @uref{#sec-12,12}@comma{} @uref{#sec-13,13} and @uref{#sec-14,14} is actually not a complete account of which token sequences are accepted as correct ECMAScript programs. Certain additional token sequences are also accepted@comma{} namely@comma{} those that would be described by the grammar if only semicolons were added to the sequence in certain places (such as before line terminator characters). Furthermore@comma{} certain token sequences that are described by the grammar are not considered acceptable if a terminator character appears in certain “awkward” places.



@node 515 The JSON Grammar
@chapter @uref{#sec-5.1.5,5.1.5} The JSON Grammar
The JSON grammar is used to translate a String describing a set of ECMAScript objects into actual objects. The JSON grammar is given in @uref{#sec-15.12.1,15.12.1}.

The JSON grammar consists of the JSON lexical grammar and the JSON syntactic grammar. The JSON lexical grammar is used to translate character sequences into tokens and is similar to parts of the ECMAScript lexical grammar. The JSON syntactic grammar describes how sequences of tokens from the JSON lexical grammar can form syntactically correct JSON object descriptions.

Productions of the JSON lexical grammar are distinguished by having two colons “::” as separating punctuation. The JSON lexical grammar uses some productions from the ECMAScript lexical grammar. The JSON syntactic grammar is similar to parts of the ECMAScript syntactic grammar. Productions of the JSON syntactic grammar are distinguished by using one colon “:” as separating punctuation.


@node 516 Grammar Notation
@chapter @uref{#sec-5.1.6,5.1.6} Grammar Notation
Terminal symbols of the lexical and string grammars@comma{} and some of the terminal symbols of the syntactic grammar@comma{} are shown in @code{fixed width} font@comma{} both in the productions of the grammars and throughout this specification whenever the text directly refers to such a terminal symbol. These are to appear in a program exactly as written. All terminal symbol characters specified in this way are to be understood as the appropriate Unicode character from the ASCII range@comma{} as opposed to any similar-looking characters from other Unicode ranges.

Nonterminal symbols are shown in italic type. The definition of a nonterminal is introduced by the name of the nonterminal being defined followed by one or more colons. (The number of colons indicates to which grammar the production belongs.) One or more alternative right-hand sides for the nonterminal then follow on succeeding lines. For example@comma{} the syntactic definition:

WhileStatement :
@code{while} @code{(} Expression @code{)} Statement
states that the nonterminal WhileStatement represents the token @code{while}@comma{} followed by a left parenthesis token@comma{} followed by an Expression@comma{} followed by a right parenthesis token@comma{} followed by a Statement. The occurrences of Expression and Statement are themselves nonterminals. As another example@comma{} the syntactic definition:

ArgumentList :
AssignmentExpression
ArgumentList @code{@comma{}} AssignmentExpression
states that an ArgumentList may represent either a single AssignmentExpression or an ArgumentList@comma{} followed by a comma@comma{} followed by an AssignmentExpression. This definition of ArgumentList is recursive@comma{} that is@comma{} it is defined in terms of itself. The result is that an ArgumentList may contain any positive number of arguments@comma{} separated by commas@comma{} where each argument expression is an AssignmentExpression. Such recursive definitions of nonterminals are common.

The subscripted suffix “_opt_”@comma{} which may appear after a terminal or nonterminal@comma{} indicates an optional symbol. The alternative containing the optional symbol actually specifies two right-hand sides@comma{} one that omits the optional element and one that includes it. This means that:

VariableDeclaration :
Identifier Initialiser_opt_
is a convenient abbreviation for:

VariableDeclaration :
Identifier
Identifier Initialiser


IterationStatement :
@code{for} @code{(} ExpressionNoIn_opt_ @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
is a convenient abbreviation for:

IterationStatement :
@code{for} @code{(} @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
which in turn is an abbreviation for:

IterationStatement :
@code{for} @code{(} @code{;} @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} @code{;} Expression @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} Expression @code{;} Expression_opt_ @code{)} Statement
which in turn is an abbreviation for:

IterationStatement :
@code{for} @code{(} @code{;} @code{;} @code{)} Statement
@code{for} @code{(} @code{;} @code{;} Expression @code{)} Statement
@code{for} @code{(} @code{;} Expression @code{;} @code{)} Statement
@code{for} @code{(} @code{;} Expression @code{;} Expression @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} @code{;} @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} @code{;} Expression @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} Expression @code{;} @code{)} Statement
@code{for} @code{(} ExpressionNoIn @code{;} Expression @code{;} Expression @code{)} Statement
so the nonterminal IterationStatement actually has eight alternative right-hand sides.

If the phrase “[empty]” appears as the right-hand side of a production@comma{} it indicates that the production’s right-hand side contains no terminals or nonterminals.

If the phrase “[lookahead ∉ set]” appears in the right-hand side of a production@comma{} it indicates that the production may not be used if the immediately following input token is a member of the given set. The set can be written as a list of terminals enclosed in curly braces. For convenience@comma{} the set can also be written as a nonterminal@comma{} in which case it represents the set of all terminals to which that nonterminal could expand. For example@comma{} given the definitions

DecimalDigit :: one of
@code{0} @code{1} @code{2} @code{3} @code{4} @code{5} @code{6} @code{7} @code{8} @code{9}
DecimalDigits ::
DecimalDigit
DecimalDigits DecimalDigit
the definition

LookaheadExample ::
@code{n} [lookahead ∉ @{@code{1}@comma{} @code{3}@comma{} @code{5}@comma{} @code{7}@comma{} @code{9}@}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit]
matches either the letter @code{n} followed by one or more decimal digits the first of which is even@comma{} or a decimal digit not followed by another decimal digit.



ReturnStatement :
@code{return} [no LineTerminator here] Expression_opt_ @code{;}
indicates that the production may not be used if a LineTerminator occurs in the program between the @code{return} token and the Expression.

Unless the presence of a LineTerminator is forbidden by a restricted production@comma{} any number of occurrences of LineTerminator may appear between any two consecutive tokens in the stream of input elements without affecting the syntactic acceptability of the program.

When the words “one of” follow the colon(s) in a grammar definition@comma{} they signify that each of the terminal symbols on the following line or lines is an alternative definition. For example@comma{} the lexical grammar for ECMAScript contains the production:

NonZeroDigit :: one of
@code{1  2  3  4  5  6  7  8  9}
which is merely a convenient abbreviation for:

NonZeroDigit ::
@code{1}
@code{2}
@code{3}
@code{4}
@code{5}
@code{6}
@code{7}
@code{8}
@code{9}
When an alternative in a production of the lexical grammar or the numeric string grammar appears to be a multi-character token@comma{} it represents the sequence of characters that would make up such a token.

The right-hand side of a production may specify that certain expansions are not permitted by using the phrase “but not” and then indicating the expansions to be excluded. For example@comma{} the production:

Identifier ::
IdentifierName but not ReservedWord
means that the nonterminal Identifier may be replaced by any sequence of characters that could replace IdentifierName provided that the same sequence of characters could not replace ReservedWord.

Finally@comma{} a few nonterminal symbols are described by a descriptive phrase in sans-serif type in cases where it would be impractical to list all the alternatives:

SourceCharacter ::
any Unicode code unit

@node 52 Algorithm Conventions
@chapter @uref{#sec-5.2,5.2} Algorithm Conventions
The specification often uses a numbered list to specify steps in an algorithm. These algorithms are used to precisely specify the required semantics of ECMAScript language constructs. The algorithms are not intended to imply the use of any specific implementation technique. In practice@comma{} there may be more efficient algorithms available to implement a given feature.



When an algorithm is to produce a value as a result@comma{} the directive “return x” is used to indicate that the result of the algorithm is the value of x and that the algorithm should terminate. The notation Result(n) is used as shorthand for “the result of step n”.

For clarity of expression@comma{} algorithm steps may be subdivided into sequential substeps. Substeps are indented and may themselves be further divided into indented substeps. Outline numbering conventions are used to identify substeps with the first level of substeps labelled with lower case alphabetic characters and the second level of substeps labelled with lower case roman numerals. If more than three levels are required these rules repeat with the fourth level using numeric labels. For example:

@enumerate
@item
Top-level step
@enumerate
@item
Substep.
@item
Substep
@enumerate
@item
Subsubstep.
@item
Subsubstep.
@enumerate
@item
Subsubsubstep
@enumerate
@item
Subsubsubsubstep
@end enumerate

@end enumerate

@end enumerate

@end enumerate

@end enumerate

A step or substep may be written as an “if” predicate that conditions its substeps. In this case@comma{} the substeps are only applied if the predicate is true. If a step or substep begins with the word “else”@comma{} it is a predicate that is the negation of the preceding “if” predicate step at the same level.

A step may specify the iterative application of its substeps.

Mathematical operations such as addition@comma{} subtraction@comma{} negation@comma{} multiplication@comma{} division@comma{} and the mathematical functions defined later in this clause should always be understood as computing exact mathematical results on mathematical real numbers@comma{} which do not include infinities and do not include a negative zero that is distinguished from positive zero. Algorithms in this standard that model floating-point arithmetic include explicit steps@comma{} where necessary@comma{} to handle infinities and signed zero and to perform rounding. If a mathematical operation or function is applied to a floating-point number@comma{} it should be understood as being applied to the exact mathematical value represented by that floating-point number; such a floating-point number must be finite@comma{} and if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(x) yields the absolute value of x@comma{} which is −x if x is negative (less than zero) and otherwise is x itself.

The mathematical function sign(x) yields 1 if x is positive and −1 if x is negative. The sign function is not used in this standard for cases when x is zero.

The notation “x modulo y” (y must be finite and nonzero) computes a value k of the same sign as y (or zero) such that abs(k) < abs(y) and x − k = q × y for some integer q.

The mathematical function floor(x) yields the largest integer (closest to positive infinity) that is not larger than x.

NOTE floor(x) = x − (x modulo 1).

If an algorithm is defined to “throw an exception”@comma{} execution of the algorithm is terminated and no result is returned. The calling algorithms are also terminated@comma{} until an algorithm step is reached that explicitly deals with the exception@comma{} using terminology such as “If an exception was thrown...”. Once such an algorithm step has been encountered the exception is no longer considered to have occurred.


@node 6 Source Text
@chapter @uref{#sec-6,6} Source Text
ECMAScript source text is represented as a sequence of characters in the Unicode character encoding@comma{} version 3.0 or later. The text is expected to have been normalised to Unicode Normalised Form C (canonical

SourceCharacter ::
any Unicode code unit
Throughout the rest of this document@comma{} the phrase “code unit” and the word “character” will be used to refer to a 16-bit unsigned value used to represent a single 16-bit unit of text. The phrase “Unicode character” will be used to refer to the abstract linguistic or typographical unit represented by a single Unicode scalar value (which may be longer than 16 bits and thus may be represented by more than one code unit). The phrase “code point” refers to such a Unicode scalar value. “Unicode character” only refers to entities represented by single Unicode scalar values: the components of a combining character sequence are still individual “Unicode characters@comma{}” even though a user might think of the whole sequence as a single character.

In string literals@comma{} regular expression literals@comma{} and identifiers@comma{} any character (code unit) may also be expressed as a Unicode escape sequence consisting of six characters@comma{} namely @code{\u} plus four hexadecimal digits. Within a comment@comma{} such an escape sequence is effectively ignored as part of the comment. Within a string literal or regular expression literal@comma{} the Unicode escape sequence contributes one character to the value of the literal. Within an identifier@comma{} the escape sequence contributes one character to the identifier.

NOTE Although this document sometimes refers to a “transformation” between a “character” within a “string” and the 16-bit unsigned integer that is the code unit of that character@comma{} there is actually no transformation because a “character” within a “string” is actually represented using that 16-bit unsigned value.

ECMAScript differs from the Java programming language in the behaviour of Unicode escape sequences. In a Java program@comma{} if the Unicode escape sequence @code{\u000A}@comma{} for example@comma{} occurs within a single-line comment@comma{} it is interpreted as a line terminator (Unicode character @code{000A} is line feed) and therefore the next character is not part of the comment. Similarly@comma{} if the Unicode escape sequence @code{\u000A} occurs within a string literal in a Java program@comma{} it is likewise interpreted as a line terminator@comma{} which is not allowed within a string literal—one must write @code{\n} instead of @code{\u000A} to cause a line feed to be part of the string value of a string literal. In an ECMAScript program@comma{} a Unicode escape sequence occurring within a comment is never interpreted and therefore cannot contribute to termination of the comment. Similarly@comma{} a Unicode escape sequence occurring within a string literal in an ECMAScript program always contributes a character to the String value of the literal and is never interpreted as a line terminator or as a quote mark that might terminate the string literal.


@node 7 Lexical Conventions
@chapter @uref{#sec-7,7} Lexical Conventions
The source text of an ECMAScript program is first converted into a sequence of input elements@comma{} which are tokens@comma{} line terminators@comma{} comments@comma{} or white space. The source text is scanned from left to right@comma{} repeatedly taking the longest possible sequence of characters as the next input element.

There are two goal symbols for the lexical grammar. The InputElementDiv symbol is used in those syntactic grammar contexts where a leading division (@code{/}) or division-assignment (@code{/=}) operator is permitted. The InputElementRegExp symbol is used in other syntactic grammar contexts.

NOTE There are no syntactic grammar contexts where both a leading division or division-assignment@comma{} and a leading RegularExpressionLiteral are permitted. This is not affected by @uref{#sec-7.9,semicolon insertion (see 7.9)}; in examples such as the following:
@verbatim
a = b
/hi/g.exec(c).map(d);
@end verbatim

where the first non-whitespace@comma{} non-comment character after a LineTerminator is slash (@code{/}) and the syntactic context allows division or division-assignment@comma{} no semicolon is inserted at the LineTerminator. That is@comma{} the above example is interpreted in the same way as:
@verbatim
a = b / hi / g.exec(c).map(d);
@end verbatim


@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
InputElementDiv ::
WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
InputElementRegExp ::
WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

@node 71 Unicode Format-Control Characters
@chapter @uref{#sec-7.1,7.1} Unicode Format-Control Characters
The Unicode format-control characters (i.e.@comma{} the characters in category “Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or RIGHT-TO-LEFT MARK) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).

It is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments@comma{} and within string literals and regular expression literals.

<ZWNJ> and <ZWJ> are format-control characters that are used to make necessary distinctions when forming words or phrases in certain languages. In ECMAScript source text@comma{} <ZWNJ> and <ZWJ> may also be used in an identifier after the first character.

<BOM> is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text’s encoding and byte order. <BOM> characters intended for this purpose can sometimes also appear after the start of a text@comma{} for example as a result of concatenating files. <BOM> characters are treated as white space characters (@uref{#sec-7.2,see 7.2}).

The special treatment of certain format-control characters outside of comments@comma{} string literals@comma{} and regular expression literals is summarized in Table 1.

Table 1 — Format-Control Character Usage
Code Unit Value
Name
Formal Name
Usage
@code{\u200C}
Zero width non-joiner
<ZWNJ>
IdentifierPart
@code{\u200D}
Zero width joiner
<ZWJ>
IdentifierPart
@code{\uFEFF}
Byte Order Mark
<BOM>
Whitespace

@node 72 White Space
@chapter @uref{#sec-7.2,7.2} White Space
White space characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other@comma{} but are otherwise insignificant. White space characters may occur between any two tokens and at the start or end of input. White space characters may also occur within a StringLiteral or a RegularExpressionLiteral (where they are considered significant characters forming part of the literal value) or within a Comment@comma{} but cannot appear within any other kind of token.

The ECMAScript white space characters are listed in Table 2.


Code Unit Value
Name
Formal Name
\u0009
Tab
<TAB>
\u000B
Vertical Tab
<VT>
\u000C
Form Feed
<FF>
\u0020
Space
<SP>
\u00A0
No-break space
<NBSP>
\uFEFF
Byte Order Mark
<BOM>
Other category “Zs”
Any other Unicode “space separator”
<USP>
ECMAScript implementations must recognize all of the white space characters defined in Unicode 3.0. Later editions of the Unicode Standard may define other white space characters. ECMAScript implementations may recognize white space characters from later editions of the Unicode Standard.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
WhiteSpace ::
<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

@node 73 Line Terminators
@chapter @uref{#sec-7.3,7.3} Line Terminators
Like white space characters@comma{} line terminator characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However@comma{} unlike white space characters@comma{} line terminators have some influence over the behaviour of the syntactic grammar. In general@comma{} line terminators may occur between any two tokens@comma{} but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of @uref{#sec-7.9,automatic semicolon insertion (7.9)}. A line terminator cannot occur within any token except a StringLiteral. Line terminators may only occur within a StringLiteral token as part of a LineContinuation.

A line terminator can occur within a MultiLineComment (@uref{#sec-7.4,7.4}) but cannot occur within a SingleLineComment.

Line terminators are included in the set of white space characters that are matched by the @uref{#sec-15.10.2.12,@code{\s} class} in regular expressions.

The ECMAScript line terminator characters are listed in Table 3.

Table 3 — Line Terminator Characters
Code Unit Value
Name
Formal Name
@code{\u000A}
Line Feed
<LF>
@code{\u000D}
Carriage Return
<CR>
@code{\u2028}
Line separator
<LS>
@code{\u2029}
Paragraph separator
<PS>
Only the characters in Table 3 are treated as line terminators. Other new line or line breaking characters are treated as white space but not as line terminators. The character sequence <CR><LF> is commonly used as a line terminator. It should be considered a single character for the purpose of reporting line numbers.


@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
LineTerminator ::
<LF>
<CR>
<LS>
<PS>
LineTerminatorSequence ::
<LF>
<CR> [@uref{#def-lookahead-notin,lookahead ∉} <LF>]
<LS>
<PS>
<CR> <LF>

@node 74 Comments
@chapter @uref{#sec-7.4,7.4} Comments
Comments can be either single or multi-line. Multi-line comments cannot nest.

Because a single-line comment can contain any character except a LineTerminator character@comma{} and because of the general rule that a token is always as long as possible@comma{} a single-line comment always consists of all characters from the @code{//} marker to the end of the line. However@comma{} the LineTerminator at the end of the line is not considered to be part of the single-line comment; it is recognised separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important@comma{} because it implies that the presence or absence of single-line comments does not affect the process of @uref{#sec-7.9,automatic semicolon insertion (see 7.9)}.

Comments behave like white space and are discarded except that@comma{} if a MultiLineComment contains a line terminator character@comma{} then the entire comment is considered to be a LineTerminator for purposes of parsing by the syntactic grammar.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Comment ::
MultiLineComment
SingleLineComment
MultiLineComment ::
@code{/*} MultiLineCommentChars_opt_ @code{*/}
MultiLineCommentChars ::
MultiLineNotAsteriskChar MultiLineCommentChars_opt_
@code{*} PostAsteriskCommentChars_opt_
PostAsteriskCommentChars ::
MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars_opt_
@code{*} PostAsteriskCommentChars_opt_
MultiLineNotAsteriskChar ::
SourceCharacter but not asterisk @code{*}
MultiLineNotForwardSlashOrAsteriskChar ::
SourceCharacter but not forward-slash @code{/} or asterisk @code{*}
SingleLineComment ::
@code{//} SingleLineCommentChars_opt_
SingleLineCommentChars ::
SingleLineCommentChar SingleLineCommentChars_opt_

SingleLineCommentChar ::
SourceCharacter but not LineTerminator

@node 75 Tokens
@chapter @uref{#sec-7.5,7.5} Tokens
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Token ::
IdentifierName
Punctuator
NumericLiteral
StringLiteral
NOTE The DivPunctuator and RegularExpressionLiteral productions define tokens@comma{} but are not included in the Token production.


@node 76 Identifier Names and Identifiers
@chapter @uref{#sec-7.6,7.6} Identifier Names and Identifiers
Identifier Names are tokens that are interpreted according to the grammar given in the “Identifiers” section of chapter 5 of the Unicode standard@comma{} with some small modifications. An Identifier is an IdentifierName that is not a ReservedWord (@uref{#sec-7.6.1,see 7.6.1}). The Unicode identifier grammar is based on both normative and informative character categories specified by the Unicode Standard. The characters in the specified categories in version 3.0 of the Unicode standard must be treated as in those categories by all conforming ECMAScript implementations.

This standard specifies specific character additions: The dollar sign (@code{$}) and the underscore (@code{_}) are permitted anywhere in an IdentifierName.

Unicode escape sequences are also permitted in an IdentifierName@comma{} where they contribute a single character to the IdentifierName@comma{} as computed by the CV of the UnicodeEscapeSequence (@uref{#sec-7.8.4,see 7.8.4}). The @code{\} preceding the UnicodeEscapeSequence does not contribute a character to the IdentifierName. A UnicodeEscapeSequence cannot be used to put a character into an IdentifierName that would otherwise be illegal. In other words@comma{} if a @code{\}@ UnicodeEscapeSequence sequence were replaced by its UnicodeEscapeSequence’s CV@comma{} the result must still be a valid IdentifierName that has the exact same sequence of characters as the original IdentifierName. All interpretations of identifiers within this specification are based upon their actual characters regardless of whether or not an escape sequence was used to contribute any particular characters.

Two IdentifierName that are canonically equivalent according to the Unicode standard are @emph{not} equal unless they are represented by the exact same sequence of code units (in other words@comma{} conforming ECMAScript implementations are only required to do bitwise comparison on IdentifierName values). The intent is that the incoming source text has been converted to normalised form C before it reaches the compiler.

ECMAScript implementations may recognize identifier characters defined in later editions of the Unicode Standard. If portability is a concern@comma{} programmers should only employ identifier characters defined in Unicode 3.0.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Identifier ::
IdentifierName but not ReservedWord
IdentifierName ::
IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::
UnicodeLetter
@code{$}
@code{_}
@code{\} UnicodeEscapeSequence
IdentifierPart ::
IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>
UnicodeLetter ::
any character in the Unicode categories “Uppercase letter (Lu)”@comma{} “Lowercase letter (Ll)”@comma{} “Titlecase letter (Lt)”@comma{} “Modifier letter (Lm)”@comma{} “Other letter (Lo)”@comma{} or “Letter number (Nl)”.
UnicodeCombiningMark ::
any character in the Unicode categories “Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”
UnicodeDigit ::
any character in the Unicode category “Decimal number (Nd)”
UnicodeConnectorPunctuation ::
any character in the Unicode category “Connector punctuation (Pc)”
UnicodeEscapeSequence ::
@uref{#sec-7.8.4,see 7.8.4}.

@node 761 Reserved Words
@chapter @uref{#sec-7.6.1,7.6.1} Reserved Words
A reserved word is an IdentifierName that cannot be used as an Identifier.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
ReservedWord ::
Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

@node 7611 Keywords
@chapter @uref{#sec-7.6.1.1,7.6.1.1} Keywords
The following tokens are ECMAScript keywords and may not be used as Identifiers in ECMAScript programs.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Keyword :: one of
@code{break} @code{do} @code{instanceof} @code{typeof} @code{case} @code{else} @code{new} @code{var} @code{catch} @code{finally} @code{return} @code{void} @code{continue} @code{for} @code{switch} @code{while} @code{debugger} @code{function} @code{this} @code{with} @code{default} @code{if} @code{throw} @code{@ } @code{delete} @code{in} @code{try}


@node 7612 Future Reserved Words
@chapter @uref{#sec-7.6.1.2,7.6.1.2} Future Reserved Words
The following words are used as keywords in proposed extensions and are therefore reserved to allow for the possibility of future adoption of those extensions.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
FutureReservedWord :: one of
@code{class} @code{enum} @code{extends} @code{super} @code{const} @code{export} @code{import}
The following tokens are also considered to be FutureReservedWords when they occur within @uref{#sec-10.1.1,strict mode code (see 10.1.1)}. The occurrence of any of these tokens within @uref{#sec-10.1.1,strict mode code} in any context where the occurrence of a FutureReservedWord would produce an error must also produce an equivalent error:

@code{implements} @code{let} @code{private} @code{public} @code{yield} @code{interface} @code{package} @code{protected} @code{static}

@node 77 Punctuators
@chapter @uref{#sec-7.7,7.7} Punctuators
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Punctuator :: one of
@code{@{} @code{@}} @code{(} @code{)} @code{[} @code{]} @code{.} @code{;} @code{@comma{}} @code{<} @code{>} @code{<=} @code{>=} @code{==} @code{!=} @code{===} @code{!==} @code{+} @code{-} @code{*} @code{%} @code{++} @code{--} @code{<<} @code{>>} @code{>>>} @code{&} @code{|} @code{^} @code{!} @code{~} @code{&&} @code{||} @code{?} @code{:} @code{=} @code{+=} @code{-=} @code{*=} @code{%=} @code{<<=} @code{>>=} @code{>>>=} @code{&=} @code{|=} @code{^=}
DivPunctuator :: one of
@code{/} @code{/=}

@node 78 Literals
@chapter @uref{#sec-7.8,7.8} Literals
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Literal ::
NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

@node 781 Null Literals
@chapter @uref{#sec-7.8.1,7.8.1} Null Literals
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
NullLiteral ::
@code{null}


@node Semantics
@section Semantics
The value of the null literal @code{null} is the sole value of the Null type@comma{} namely null.


@node 782 Boolean Literals
@chapter @uref{#sec-7.8.2,7.8.2} Boolean Literals
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
BooleanLiteral ::
@code{true}
@code{false}

@node Semantics
@section Semantics
The value of the Boolean literal @code{true} is a value of the Boolean type@comma{} namely true.

The value of the Boolean literal @code{false} is a value of the Boolean type@comma{} namely false.


@node 783 Numeric Literals
@chapter @uref{#sec-7.8.3,7.8.3} Numeric Literals
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
NumericLiteral ::
DecimalLiteral
HexIntegerLiteral
DecimalLiteral ::
DecimalIntegerLiteral @code{.} DecimalDigits_opt_ ExponentPart_opt_
@code{.} DecimalDigits ExponentPart_opt_
DecimalIntegerLiteral ExponentPart_opt_
DecimalIntegerLiteral ::
@code{0}
NonZeroDigit DecimalDigits_opt_
DecimalDigits ::
DecimalDigit
DecimalDigits DecimalDigit
DecimalDigit :: one of
@code{0  1  2  3  4  5  6  7  8  9}
NonZeroDigit :: one of
@code{1  2  3  4  5  6  7  8  9}
ExponentPart ::
ExponentIndicator SignedInteger
ExponentIndicator :: one of
@code{e  E}
SignedInteger ::
DecimalDigits
@code{+} DecimalDigits
@code{-} DecimalDigits
HexIntegerLiteral ::
@code{0x} HexDigit
@code{0X} HexDigit
HexIntegerLiteral HexDigit

HexDigit :: one of
@code{0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  A  B  C  D  E  F}
The source character immediately following a NumericLiteral must not be an IdentifierStart or DecimalDigit.

NOTE For example:
@verbatim
3in
@end verbatim

is an error and not the two input elements @code{3} and @code{in}.


@node Semantics
@section Semantics
A numeric literal stands for a value of the Number type. This value is determined in two steps: first@comma{} a mathematical value (MV) is derived from the literal; second@comma{} this mathematical value is rounded as described below.

@itemize
@item
The MV of NumericLiteral :: DecimalLiteral is the MV of DecimalLiteral.
@item
The MV of NumericLiteral :: HexIntegerLiteral is the MV of HexIntegerLiteral.
@item
The MV of DecimalLiteral :: DecimalIntegerLiteral @code{.} is the MV of DecimalIntegerLiteral.
@item
The MV of DecimalLiteral :: DecimalIntegerLiteral @code{.} DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of DecimalDigits times 10^−n)@comma{} where n is the number of characters in DecimalDigits.
@item
The MV of DecimalLiteral :: DecimalIntegerLiteral @code{.} ExponentPart is the MV of DecimalIntegerLiteral times 10^e@comma{} where e is the MV of ExponentPart.
@item
The MV of DecimalLiteral :: DecimalIntegerLiteral @code{.} DecimalDigits ExponentPart is (the MV of DecimalIntegerLiteral plus (the MV of DecimalDigits times 10^−n)) times 10^e@comma{} where n is the number of characters in DecimalDigits and e is the MV of ExponentPart.
@item
The MV of DecimalLiteral :: @code{.} DecimalDigits is the MV of DecimalDigits times 10^−n@comma{} where n is the number of characters in DecimalDigits.
@item
The MV of DecimalLiteral :: @code{.} DecimalDigits ExponentPart is the MV of DecimalDigits times 10^e−n@comma{} where n is the number of characters in DecimalDigits and e is the MV of ExponentPart.
@item
The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of DecimalIntegerLiteral.
@item
The MV of DecimalLiteral :: DecimalIntegerLiteral ExponentPart is the MV of DecimalIntegerLiteral times 10^e@comma{} where e is the MV of ExponentPart.
@item
The MV of DecimalIntegerLiteral :: @code{0} is 0.
@item
The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits is (the MV of NonZeroDigit times 10^n) plus the MV of DecimalDigits@comma{} where n is the number of characters in DecimalDigits.
@item
The MV of DecimalDigits :: DecimalDigit is the MV of DecimalDigit.
@item
The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the MV of DecimalDigits times 10) plus the MV of DecimalDigit.
@item
The MV of ExponentPart :: ExponentIndicator SignedInteger is the MV of SignedInteger.
@item
The MV of SignedInteger :: DecimalDigits is the MV of DecimalDigits.
@item
The MV of SignedInteger :: @code{+} DecimalDigits is the MV of DecimalDigits.
@item
The MV of SignedInteger :: @code{-} DecimalDigits is the negative of the MV of DecimalDigits.
@item
The MV of DecimalDigit :: @code{0} or of HexDigit :: @code{0} is 0.
@item
The MV of DecimalDigit :: @code{1} or of NonZeroDigit :: @code{1} or of HexDigit :: @code{1} is 1.
@item
The MV of DecimalDigit :: @code{2} or of NonZeroDigit :: @code{2} or of HexDigit :: @code{2} is 2.
@item
The MV of DecimalDigit :: @code{3} or of NonZeroDigit :: @code{3} or of HexDigit :: @code{3} is 3.
@item
The MV of DecimalDigit :: @code{4} or of NonZeroDigit :: @code{4} or of HexDigit :: @code{4} is 4.
@item
The MV of DecimalDigit :: @code{5} or of NonZeroDigit :: @code{5} or of HexDigit :: @code{5} is 5.
@item
The MV of DecimalDigit :: @code{6} or of NonZeroDigit :: @code{6} or of HexDigit :: @code{6} is 6.
@item
The MV of DecimalDigit :: @code{7} or of NonZeroDigit :: @code{7} or of HexDigit :: @code{7} is 7.
@item
The MV of DecimalDigit :: @code{8} or of NonZeroDigit :: @code{8} or of HexDigit :: @code{8} is 8.
@item
The MV of DecimalDigit :: @code{9} or of NonZeroDigit :: @code{9} or of HexDigit :: @code{9} is 9.
@item
The MV of HexDigit :: @code{a} or of HexDigit :: @code{A} is 10.
@item
The MV of HexDigit :: @code{b} or of HexDigit :: @code{B} is 11.
@item

@item
The MV of HexDigit :: @code{d} or of HexDigit :: @code{D} is 13.
@item
The MV of HexDigit :: @code{e} or of HexDigit :: @code{E} is 14.
@item
The MV of HexDigit :: @code{f} or of HexDigit :: @code{F} is 15.
@item
The MV of HexIntegerLiteral :: @code{0x} HexDigit is the MV of HexDigit.
@item
The MV of HexIntegerLiteral :: @code{0X} HexDigit is the MV of HexDigit.
@item
The MV of HexIntegerLiteral :: HexIntegerLiteral HexDigit is (the MV of HexIntegerLiteral times 16) plus the MV of HexDigit.
@end itemize

Once the exact MV for a numeric literal has been determined@comma{} it is then rounded to a value of the Number type. If the MV is 0@comma{} then the rounded value is +0; otherwise@comma{} the rounded value must be @uref{#sec-8.5,the Number value for} the MV (as specified in @uref{#sec-8.5,8.5})@comma{} unless the literal is a DecimalLiteral and the literal has more than 20 significant digits@comma{} in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a @code{0} digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a @code{0} digit and then incrementing the literal at the 20th significant digit position. A digit is significant if it is not part of an ExponentPart and

@itemize
@item
it is not @code{0}; or
@item
there is a nonzero digit to its left and there is a nonzero digit@comma{} not in the ExponentPart@comma{} to its right.
@end itemize

A conforming implementation@comma{} when processing @uref{#sec-10.1.1,strict mode code (see 10.1.1)}@comma{} must not extend the syntax of NumericLiteral to include OctalIntegerLiteral as described in @uref{#sec-B.1.1,B.1.1}.


@node 784 String Literals
@chapter @uref{#sec-7.8.4,7.8.4} String Literals
A string literal is zero or more characters enclosed in single or double quotes. Each character may be represented by an escape sequence. All characters may appear literally in a string literal except for the closing quote character@comma{} backslash@comma{} carriage return@comma{} line separator@comma{} paragraph separator@comma{} and line feed. Any character may appear in the form of an escape sequence.

@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
StringLiteral ::
@code{"} DoubleStringCharacters_opt_ @code{"}
@code{'} SingleStringCharacters_opt_ @code{'}
DoubleStringCharacters ::
DoubleStringCharacter DoubleStringCharacters_opt_
SingleStringCharacters ::
SingleStringCharacter SingleStringCharacters_opt_
DoubleStringCharacter ::
SourceCharacter but not double-quote @code{"} or backslash @code{\} or LineTerminator
@code{\} EscapeSequence
LineContinuation
SingleStringCharacter ::
SourceCharacter but not single-quote @code{?} or backslash @code{\} or LineTerminator
@code{\} EscapeSequence
LineContinuation
LineContinuation ::
@code{\} LineTerminatorSequence

EscapeSequence ::
CharacterEscapeSequence
@code{0} [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence
CharacterEscapeSequence ::
SingleEscapeCharacter
NonEscapeCharacter
SingleEscapeCharacter :: one of
@code{?  "  \  b  f  n  r  t  v}
NonEscapeCharacter ::
SourceCharacter but not EscapeCharacter or LineTerminator
EscapeCharacter ::
SingleEscapeCharacter
DecimalDigit
@code{x}
@code{u}
HexEscapeSequence ::
@code{x} HexDigit HexDigit
UnicodeEscapeSequence ::
@code{u} HexDigit HexDigit HexDigit HexDigit
The definition of the nonterminal HexDigit is given in @uref{#sec-7.8.3,7.8.3}. SourceCharacter is defined in @uref{#sec-6,clause 6}.


@node Semantics
@section Semantics
A string literal stands for a value of the String type. The String value (SV) of the literal is described in terms of character values (CV) contributed by the various parts of the string literal. As part of this process@comma{} some characters within the string literal are interpreted as having a mathematical value (MV)@comma{} as described below or in @uref{#sec-7.8.3,7.8.3}.

@itemize
@item
The SV of StringLiteral :: @code{""} is the empty character sequence.
@item
The SV of StringLiteral :: @code{''} is the empty character sequence.
@item
The SV of StringLiteral :: @code{"} DoubleStringCharacters @code{"} is the SV of DoubleStringCharacters.
@item
The SV of StringLiteral :: @code{'} SingleStringCharacters @code{'} is the SV of SingleStringCharacters.
@item
The SV of DoubleStringCharacters :: DoubleStringCharacter is a sequence of one character@comma{} the CV of DoubleStringCharacter.
@item
The SV of DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters is a sequence of the CV of DoubleStringCharacter followed by all the characters in the SV of DoubleStringCharacters in order.
@item
The SV of SingleStringCharacters :: SingleStringCharacter is a sequence of one character@comma{} the CV of SingleStringCharacter.
@item
The SV of SingleStringCharacters :: SingleStringCharacter SingleStringCharacters is a sequence of the CV of SingleStringCharacter followed by all the characters in the SV of SingleStringCharacters in order.
@item
The SV of LineContinuation :: @code{\} LineTerminatorSequence is the empty character sequence.
@item
The CV of DoubleStringCharacter :: SourceCharacter but not double-quote @code{"} or backslash @code{\} or LineTerminator is the SourceCharacter character itself.
@item
The CV of DoubleStringCharacter :: @code{\} EscapeSequence is the CV of the EscapeSequence.
@item
The CV of SingleStringCharacter :: SourceCharacter but not single-quote @code{?} or backslash @code{\} or LineTerminator is the SourceCharacter character itself.
@item
The CV of SingleStringCharacter :: @code{\} EscapeSequence is the CV of the EscapeSequence.
@item
The CV of EscapeSequence :: CharacterEscapeSequence is the CV of the CharacterEscapeSequence.
@item

@item
The CV of EscapeSequence :: HexEscapeSequence is the CV of the HexEscapeSequence.
@item
The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of the UnicodeEscapeSequence.
@item
The CV of CharacterEscapeSequence :: SingleEscapeCharacter is the character whose code unit value is determined by the SingleEscapeCharacter according to Table 4: Table 4 — String Single Character Escape Sequences
Escape Sequence
Code Unit Value
Name
Symbol
@code{\b}
@code{\u0008}
backspace
<BS>
@code{\t}
@code{\u0009}
horizontal tab
<HT>
@code{\n}
@code{\u000A}
line feed (new line)
<LF>
@code{\v}
@code{\u000B}
vertical tab
<VT>
@code{\f}
@code{\u000C}
form feed
<FF>
@code{\r}
@code{\u000D}
carriage return
<CR>
@code{\"}
@code{\u0022}
double quote
@code{"}
@code{\?}
@code{\u0027}
single quote
@code{?}
@code{\\}
@code{\u005C}
backslash
@code{\}
@item
The CV of CharacterEscapeSequence :: NonEscapeCharacter is the CV of the NonEscapeCharacter.
@item
The CV of NonEscapeCharacter :: SourceCharacter but not EscapeCharacter or LineTerminator is the SourceCharacter character itself.
@item
The CV of HexEscapeSequence :: @code{x} HexDigit HexDigit is the character whose code unit value is (16 times the MV of the first HexDigit) plus the MV of the second HexDigit.
@item
The CV of UnicodeEscapeSequence :: @code{u} HexDigit HexDigit HexDigit HexDigit is the character whose code unit value is (4096 times the MV of the first HexDigit) plus (256 times the MV of the second HexDigit) plus (16 times the MV of the third HexDigit) plus the MV of the fourth HexDigit.
@end itemize

A conforming implementation@comma{} when processing @uref{#sec-10.1.1,strict mode code (see 10.1.1)}@comma{} may not extend the syntax of EscapeSequence to include OctalEscapeSequence as described in @uref{#sec-B.1.2,B.1.2}.

NOTE A line terminator character cannot appear in a string literal@comma{} except as part of a LineContinuation to produce the empty character sequence. The correct way to cause a line terminator character to be part of the String value of a string literal is to use an escape sequence such as @code{\n} or @code{\u000A}.


@node 785 Regular Expression Literals
@chapter @uref{#sec-7.8.5,7.8.5} Regular Expression Literals
A regular expression literal is an input element that is converted to a RegExp object (@uref{#sec-15.10,see 15.10}) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as @code{===} to each other even if the two literals’ contents are identical. A RegExp object may also be created at runtime by @code{new RegExp} (@uref{#sec-15.10.4,see 15.10.4}) or calling the RegExp constructor as a function (@uref{#sec-15.10.3,15.10.3}).

The productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The Strings of characters comprising the RegularExpressionBody and the RegularExpressionFlags are passed uninterpreted to the regular expression constructor@comma{} which interprets them according to its own@comma{} more stringent grammar. An implementation may extend the regular expression constructor’s grammar@comma{} but it must not extend the RegularExpressionBody and RegularExpressionFlags productions or the productions used by these productions.

@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
RegularExpressionLiteral ::
@code{/} RegularExpressionBody @code{/} RegularExpressionFlags

RegularExpressionBody ::
RegularExpressionFirstChar RegularExpressionChars
RegularExpressionChars ::
[empty]
RegularExpressionChars RegularExpressionChar
RegularExpressionFirstChar ::
RegularExpressionNonTerminator but not @code{*} or @code{\} or @code{/} or @code{[}
RegularExpressionBackslashSequence
RegularExpressionClass
RegularExpressionChar ::
RegularExpressionNonTerminator but not @code{\} or @code{/} or @code{[}
RegularExpressionBackslashSequence
RegularExpressionClass
RegularExpressionBackslashSequence ::
@code{\} RegularExpressionNonTerminator
RegularExpressionNonTerminator ::
SourceCharacter but not LineTerminator
RegularExpressionClass ::
@code{[} RegularExpressionClassChars @code{]}
RegularExpressionClassChars ::
[empty]
RegularExpressionClassChars RegularExpressionClassChar
RegularExpressionClassChar ::
RegularExpressionNonTerminator but not @code{]} or @code{\}
RegularExpressionBackslashSequence
RegularExpressionFlags ::
[empty]
RegularExpressionFlags IdentifierPart
NOTE Regular expression literals may not be empty; instead of representing an empty regular expression literal@comma{} the characters @code{//} start a single-line comment. To specify an empty regular expression@comma{} use: @code{/(?:)/}.


@node Semantics
@section Semantics
A regular expression literal evaluates to a value of the Object type that is an instance of the standard built-in constructor RegExp. This value is determined in two steps: first@comma{} the characters comprising the regular expression’s RegularExpressionBody and RegularExpressionFlags production expansions are collected uninterpreted into two Strings Pattern and Flags@comma{} respectively. Then each time the literal is evaluated@comma{} a new object is created as if by the expression @code{new RegExp(<var>Pattern</var>@comma{} <var>Flags</var>)} where @code{RegExp} is the standard built-in constructor with that name. The newly constructed object becomes the value of the RegularExpressionLiteral. If the call to @code{new RegExp} would generate an error as specified in @uref{#sec-15.10.4.1,15.10.4.1}@comma{} the error must be treated as an early error (@uref{#sec-16,Clause 16}).


@node 79 Automatic Semicolon Insertion
@chapter @uref{#sec-7.9,7.9} Automatic Semicolon Insertion
Certain ECMAScript statements (empty statement@comma{} variable statement@comma{} expression statement@comma{} @code{do}–@code{while} statement@comma{} @code{continue} statement@comma{} @code{break} statement@comma{} @code{return} statement@comma{} and @code{throw} statement) must be terminated with semicolons. Such semicolons may always appear explicitly in the source text. For convenience@comma{} however@comma{} such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.



@node 791 Rules of Automatic Semicolon Insertion
@chapter @uref{#sec-7.9.1,7.9.1} Rules of Automatic Semicolon Insertion
There are three basic rules of semicolon insertion:

@enumerate
@item
When@comma{} as the program is parsed from left to right@comma{} a token (called the offending token) is encountered that is not allowed by any production of the grammar@comma{} then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:

@itemize
@item
The offending token is separated from the previous token by at least one LineTerminator.
@item
The offending token is @code{@}}.
@end itemize

@item
When@comma{} as the program is parsed from left to right@comma{} the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single complete ECMAScript Program@comma{} then a semicolon is automatically inserted at the end of the input stream.

@item
When@comma{} as the program is parsed from left to right@comma{} a token is encountered that is allowed by some production of the grammar@comma{} but the production is a @uref{#def-restricted-production,restricted production} and the token would be the first token for a terminal or nonterminal immediately following the annotation “@uref{#def-restricted-production,[no LineTerminator here]}” within the restricted production (and therefore such a token is called a restricted token)@comma{} and the restricted token is separated from the previous token by at least one LineTerminator@comma{} then a semicolon is automatically inserted before the restricted token.

@end enumerate

However@comma{} there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a @code{for} statement (@uref{#sec-12.6.3,see 12.6.3}).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression :
LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{++}
LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{--}
ContinueStatement :
@code{continue} @uref{#def-restricted-production,[no LineTerminator here]} Identifier_opt_ @code{;}
BreakStatement :
@code{break} @uref{#def-restricted-production,[no LineTerminator here]} Identifier_opt_ @code{;}
ReturnStatement :
@code{return} @uref{#def-restricted-production,[no LineTerminator here]} Expression_opt_ @code{;}
ThrowStatement :
@code{throw} @uref{#def-restricted-production,[no LineTerminator here]} Expression @code{;}
The practical effect of these restricted productions is as follows:

When a @code{++} or @code{--} token is encountered where the parser would treat it as a postfix operator@comma{} and at least one LineTerminator occurred between the preceding token and the @code{++} or @code{--} token@comma{} then a semicolon is automatically inserted before the @code{++} or @code{--} token.

When a @code{continue}@comma{} @code{break}@comma{} @code{return}@comma{} or @code{throw} token is encountered and a LineTerminator is encountered before the next token@comma{} a semicolon is automatically inserted after the @code{continue}@comma{} @code{break}@comma{} @code{return}@comma{} or @code{throw} token.

The resulting practical advice to ECMAScript programmers is:

A postfix @code{++} or @code{--} operator should appear on the same line as its operand.

An Expression in a @code{return} or @code{throw} statement should start on the same line as the @code{return} or @code{throw} token.

An Identifier in a @code{break} or @code{continue} statement should be on the same line as the @code{break} or @code{continue} token.



@node 792 Examples of Automatic Semicolon Insertion
@chapter @uref{#sec-7.9.2,7.9.2} Examples of Automatic Semicolon Insertion
The source
@verbatim
{ 1 2 } 3
@end verbatim

is not a valid sentence in the ECMAScript grammar@comma{} even with the automatic semicolon insertion rules. In contrast@comma{} the source
@verbatim
{ 1
2 } 3
@end verbatim

is also not a valid ECMAScript sentence@comma{} but is transformed by automatic semicolon insertion into the following:
@verbatim
{ 1
;2 ;} 3;
@end verbatim

which is a valid ECMAScript sentence.

The source
@verbatim
for (a; b
)
@end verbatim

is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a @code{for} statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a @code{for} statement.

The source
@verbatim
return
a + b
@end verbatim

is transformed by automatic semicolon insertion into the following:
@verbatim
return;
a + b;
@end verbatim

NOTE The expression @code{a +   b} is not treated as a value to be returned by the @code{return} statement@comma{} because a LineTerminator separates it from the token @code{return}.

The source
@verbatim
a = b
++c
@end verbatim

is transformed by automatic semicolon insertion into the following:
@verbatim
a = b;
++c;
@end verbatim

NOTE The token @code{++} is not treated as a postfix operator applying to the variable @code{b}@comma{} because a LineTerminator occurs between @code{b} and @code{++}.

The source
@verbatim
if (a > b)
else c = d
@end verbatim

is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the @code{else} token@comma{} even though no production of the grammar applies at that point@comma{} because an automatically inserted semicolon would then be parsed as an empty statement.

The source
@verbatim
a = b + c
(d + e).print()
@end verbatim

is @emph{not} transformed by automatic semicolon insertion@comma{} because the parenthesised expression that begins the second line can be interpreted as an argument list for a function call:
@verbatim
a = b + c(d + e).print()
@end verbatim


In the circumstance that an assignment statement must begin with a left parenthesis@comma{} it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.


@node 8 Types
@chapter @uref{#sec-8,8} Types
Algorithms within this specification manipulate values each of which has an associated type. The possible value types are exactly those defined in this clause. Types are further subclassified into ECMAScript language types and specification types.

An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined@comma{} Null@comma{} Boolean@comma{} String@comma{} Number@comma{} and Object.

A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are @uref{#sec-8.7,Reference}@comma{} @uref{#sec-8.8,List}@comma{} @uref{#sec-8.9,Completion}@comma{} @uref{#sec-8.10,Property Descriptor}@comma{} @uref{#def-property-identifier,Property Identifier}@comma{} @uref{#sec-10.2,Lexical Environment}@comma{} and @uref{#sec-10.2.1,Environment Record}. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.

Within this specification@comma{} the notation “Type(x)” is used as shorthand for “the type of x” where “type” refers to the ECMAScript language and specification types defined in this clause.


@node 81 The Undefined Type
@chapter @uref{#sec-8.1,8.1} The Undefined Type
The Undefined type has exactly one value@comma{} called undefined. Any variable that has not been assigned a value has the value undefined.


@node 82 The Null Type
@chapter @uref{#sec-8.2,8.2} The Null Type
The Null type has exactly one value@comma{} called null.


@node 83 The Boolean Type
@chapter @uref{#sec-8.3,8.3} The Boolean Type
The Boolean type represents a logical entity having two values@comma{} called true and false.


@node 84 The String Type
@chapter @uref{#sec-8.4,8.4} The String Type
The String type is the set of all finite ordered sequences of zero or more 16-bit unsigned integer values (“elements”). The String type is generally used to represent textual data in a running ECMAScript program@comma{} in which case each element in the String is treated as a code unit value (@uref{#sec-6,see Clause 6}). Each element is regarded as occupying a position within the sequence. These positions are indexed with nonnegative integers. The first element (if any) is at position 0@comma{} the next element (if any) at position 1@comma{} and so on. The length of a String is the number of elements (i.e.@comma{} 16-bit values) within it. The empty String has length zero and therefore contains no elements.

When a String contains actual textual data@comma{} each element is considered to be a single UTF-16 code unit. Whether or not this is the actual storage format of a String@comma{} the characters within a String are numbered by their initial code unit element position as though they were represented using UTF-16. All operations on Strings (except as otherwise stated) treat them as sequences of undifferentiated 16-bit unsigned integers; they do not ensure the resulting String is in normalised form@comma{} nor do they ensure language-sensitive results.

NOTE The rationale behind this design was to keep the implementation of Strings as simple and high-performing as possible. The intent is that textual data coming into the execution environment from outside (e.g.@comma{} user input@comma{} text read from a file or received over the network@comma{} etc.) be converted to Unicode Normalised Form C before the running program


@node 85 The Number Type
@chapter @uref{#sec-8.5,8.5} The Number Type
The Number type has exactly 18437736874454810627 (that is@comma{} 2^64−2^53+3) values@comma{} representing the double-precision 64-bit format IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic@comma{} except that the 9007199254740990 (that is@comma{} 2^53−2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. (Note that the NaN value is produced by the program expression NaN.) In some implementations@comma{} external code might be able to detect a difference between various Not-a-Number values@comma{} but such behaviour is implementation-dependent; to ECMAScript code@comma{} all NaN values are indistinguishable from each other.

There are two other special values@comma{} called positive Infinity and negative Infinity. For brevity@comma{} these values are also referred to for expository purposes by the symbols +∞ and −∞@comma{} respectively. (Note that these two infinite Number values are produced by the program expressions @code{+Infinity} (or simply @code{Infinity}) and @code{-Infinity}.)

The other 18437736874454810624 (that is@comma{} 2^64−2^53) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive Number value there is a corresponding negative value having the same magnitude.

Note that there is both a positive zero and a negative zero. For brevity@comma{} these values are also referred to for expository purposes by the symbols +0 and −0@comma{} respectively. (Note that these two different zero Number values are produced by the program expressions @code{+0} (or simply @code{0}) and @code{−0}.)

The 18437736874454810622 (that is@comma{} 2^64−2^53−2) finite nonzero values are of two kinds:

18428729675200069632 (that is@comma{} 2^64−2^54) of them are normalised@comma{} having the form

s × m × 2^e

where s is +1 or −1@comma{} m is a positive integer less than 2^53 but not less than 2^52@comma{} and e is an integer ranging from −1074 to 971@comma{} inclusive.

The remaining 9007199254740990 (that is@comma{} 2^53−2) values are denormalised@comma{} having the form

s × m × 2^e

where s is +1 or −1@comma{} m is a positive integer less than 2^52@comma{} and e is −1074.

Note that all the positive and negative integers whose magnitude is no greater than 2^53 are representable in the Number type (indeed@comma{} the integer 0 has two representations@comma{} +0 and −0).

A finite number has an odd significand if it is nonzero and the integer m used to express it (in one of the two forms shown above) is odd. Otherwise@comma{} it has an even significand.

In this specification@comma{} the phrase “the Number value for x” where x represents an exact nonzero real mathematical quantity (which might even be an irrational number such as π) means a Number value chosen in the following manner. Consider the set of all finite values of the Number type@comma{} with −0 removed and with two additional values added to it that are not representable in the Number type@comma{} namely 2^1024 (which is +1 × 2^53 × 2^971) and −2^1024 (which is −1 × 2^53 × 2^971). Choose the member of this set that is closest in value to x. If two values of the set are equally close@comma{} then the one with an even significand is chosen; for this purpose@comma{} the two extra values 2^1024 and −2^1024 are considered to have even significands. Finally@comma{} if 2^1024 was chosen@comma{} replace it with +∞; if −2^1024 was chosen@comma{} replace it with −∞; if +0 was chosen@comma{} replace it with −0 if and only if x is less than zero; any other chosen value is used unchanged. The result is the Number value for x. (This procedure corresponds exactly to the behaviour of the IEEE 754 “round to nearest” mode.)


Some ECMAScript operators deal only with integers in the range −2^31 through 2^31−1@comma{} inclusive@comma{} or in the range 0 through 2^32−1@comma{} inclusive. These operators accept any value of the Number type but first convert each such value to one of 2^32 integer values. See the descriptions of the @uref{#sec-9.5,ToInt32} and @uref{#sec-9.6,ToUint32} operators in @uref{#sec-9.5,9.5} and @uref{#sec-9.6,9.6}@comma{} respectively.


@node 86 The Object Type
@chapter @uref{#sec-8.6,8.6} The Object Type
An Object is a collection of properties. Each property is either a named data property@comma{} a named accessor property@comma{} or an internal property:

@itemize
@item
A named data property associates a name with an ECMAScript language value and a set of Boolean attributes.
@item
A named accessor property associates a name with one or two accessor functions@comma{} and a set of Boolean attributes. The accessor functions are used to store or retrieve an ECMAScript language value that is associated with the property.
@item
An internal property has no name and is not directly accessible via ECMAScript language operators. Internal properties exist purely for specification purposes.
@end itemize

There are two kinds of access for named (non-internal) properties: @emph{get} and @emph{put}@comma{} corresponding to retrieval and assignment@comma{} respectively.


@node 861 Property Attributes
@chapter @uref{#sec-8.6.1,8.6.1} Property Attributes
Attributes are used in this specification to define and explain the state of named properties. A named data property associates a name with the attributes listed in Table 5:

Table 5 — Attributes of a Named Data Property
Attribute Name
Value Domain
Description
[[Value]]
Any ECMAScript language type
The value retrieved by reading the property.
[[Writable]]
Boolean
If false@comma{} attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Put]] will not succeed.
[[Enumerable]]
Boolean
If true@comma{} the property will be enumerated by a for-in enumeration (@uref{#sec-12.6.4,see 12.6.4}). Otherwise@comma{} the property is said to be non-enumerable.
[[Configurable]]
Boolean
If false@comma{} attempts to delete the property@comma{} change the property to be an accessor property@comma{} or change its attributes (other than [[Value]]) will fail.
A named accessor property associates a name with the attributes listed in Table 6.


Attribute Name
Value Domain
Description
[[Get]]
Object or Undefined
If the value is an Object it must be a function Object. The function’s [[Call]] internal method (@uref{#sec-8.6.2,8.6.2}) is called with an empty arguments list to return the property value each time a get access of the property is performed.
[[Set]]
Object or Undefined
If the value is an Object it must be a function Object. The function’s [[Call]] internal method (@uref{#sec-8.6.2,8.6.2}) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property’s [[Set]] internal method may@comma{} but is not required to@comma{} have an effect on the value returned by subsequent calls to the property’s [[Get]] internal method.
[[Enumerable]]
Boolean
If true@comma{} the property is to be enumerated by a for-in enumeration (@uref{#sec-12.6.4,see 12.6.4}). Otherwise@comma{} the property is said to be non-enumerable.
[[Configurable]]
Boolean
If false@comma{} attempts to delete the property@comma{} change the property to be a data property@comma{} or change its attributes will fail.
If the value of an attribute is not explicitly specified by this specification for a named property@comma{} the default value defined in Table 7 is used.

Table 7 — Default Attribute Values
Attribute Name
Default Value
[[Value]]
undefined
[[Get]]
undefined
[[Set]]
undefined
[[Writable]]
false
[[Enumerable]]
false
[[Configurable]]
false

@node 862 Object Internal Properties and Methods
@chapter @uref{#sec-8.6.2,8.6.2} Object Internal Properties and Methods
This specification uses various internal properties to define the semantics of object values. These internal properties are not part of the ECMAScript language. They are defined by this specification purely for expository purposes. An implementation of ECMAScript must behave as if it produced and operated upon internal properties in the manner described here. The names of internal properties are enclosed in double square brackets [[ ]]. When an algorithm uses an internal property of an object and the object does not implement the indicated internal property@comma{} a TypeError exception is thrown.

The Table 8 summarises the internal properties used by this specification that are applicable to all ECMAScript objects. The Table 9 summarises the internal properties used by this specification that are only applicable to some ECMAScript objects. The descriptions in these tables indicates their behaviour for native ECMAScript objects@comma{} unless stated otherwise in this document for particular kinds of native ECMAScript objects. Host objects may support these internal properties with any implementation-dependent behaviour as long as it is consistent with the specific host object restrictions stated in this document.

The “Value Type Domain” columns of the following tables define the types of values associated with internal properties. The type names refer to the types defined in @uref{#sec-8,Clause 8} augmented by the following additional names. “any” means the value may be any ECMAScript language type. “primitive” means Undefined@comma{} Null@comma{} Boolean@comma{} String@comma{} or Number. “SpecOp” means the internal property is an internal method@comma{} an implementation provided procedure defined by an abstract operation specification. “SpecOp” is followed by a list of descriptive

Table 8 — Internal Properties Common to All Objects
Internal Property
Value Type Domain
Description
[[Prototype]]
Object or Null
The prototype of this object.
[[Class]]
String
A String value indicating a specification defined classification of objects.
[[Extensible]]
Boolean
If true@comma{} own properties may be added to the object.
[[Get]]
SpecOp(propertyName) → any
Returns the value of the named property.
[[GetOwnProperty]]
SpecOp (propertyName) → Undefined or @uref{#sec-8.10,Property Descriptor}
Returns the @uref{#sec-8.10,Property Descriptor} of the named own property of this object@comma{} or undefined if absent.
[[GetProperty]]
SpecOp (propertyName) → Undefined or @uref{#sec-8.10,Property Descriptor}
Returns the @uref{#def-fully-populated,fully populated} @uref{#sec-8.10,Property Descriptor} of the named property of this object@comma{} or undefined if absent.
[[Put]]
SpecOp (propertyName@comma{} any@comma{} Boolean)
Sets the specified named property to the value of the second parameter. The flag controls failure handling.
[[CanPut]]
SpecOp (propertyName) → Boolean
Returns a Boolean value indicating whether a [[Put]] operation with PropertyName can be performed.
[[HasProperty]]
SpecOp (propertyName) → Boolean
Returns a Boolean value indicating whether the object already has a property with the given name.
[[Delete]]
SpecOp (propertyName@comma{} Boolean) → Boolean
Removes the specified named own property from the object. The flag controls failure handling.
[[DefaultValue]]
SpecOp (Hint) → primitive
Hint is a String. Returns a default value for the object.
[[DefineOwnProperty]]
SpecOp (propertyName@comma{} PropertyDescriptor@comma{} Boolean) → Boolean
Creates or alters the named own property to have the state described by a @uref{#sec-8.10,Property Descriptor}. The flag controls failure handling.
Every object (including host objects) must implement all of the internal properties listed in Table 8. However@comma{} the [[DefaultValue]] internal method may@comma{} for some objects@comma{} simply throw a TypeError exception.

All objects have an internal property called [[Prototype]]. The value of this property is either null or an object and is used for implementing inheritance. Whether or not a native object can have a host object as its [[Prototype]] depends on the implementation. Every [[Prototype]] chain must have finite length (that is@comma{} starting from any object@comma{} recursively accessing the [[Prototype]] internal property must eventually lead to a null value). Named data properties of the [[Prototype]] object are inherited (are visible as properties of the child object) for the purposes of get access@comma{} but not for put access. Named accessor properties are inherited for both get access and put access.

Every ECMAScript object has a Boolean-valued [[Extensible]] internal property that controls whether or not named properties may be added to the object. If the value of the [[Extensible]] internal property is false then additional named properties may not be added to the object. In addition@comma{} if [[Extensible]] is false the value of the [[Class]] and [[Prototype]] internal properties of the object may not be modified. Once the value of an [[Extensible]] internal property has been set to false it may not be subsequently changed to true.

NOTE This specification defines no ECMAScript language operators or built-in functions that permit a program to modify an object’s [[Class]] or [[Prototype]] internal properties or to change the value of [[Extensible]] from false to true.

The value of the [[Class]] internal property is defined by this specification for every kind of built-in object. The value of the [[Class]] internal property of a host object may be any String value except one of "Arguments"@comma{} "Array"@comma{} "Boolean"@comma{} "Date"@comma{} "Error"@comma{} "Function"@comma{} "JSON"@comma{} "Math"@comma{} "Number"@comma{} "Object"@comma{} "RegExp"@comma{} and "String". The value of a [[Class]] internal property is used internally to distinguish different kinds of objects. Note that this specification does not provide any means for a program to access that value except through @uref{#sec-15.2.4.2,Object.prototype.toString (see 15.2.4.2)}.

Unless otherwise specified@comma{} the common internal methods of native ECMAScript objects behave as described in @uref{#sec-8.12,8.12}. Array objects have a slightly different implementation of the [[DefineOwnProperty]] internal method (@uref{#sec-15.4.5.1,see 15.4.5.1}) and String objects have a slightly different implementation of the [[GetOwnProperty]] internal method (@uref{#sec-15.5.5.2,see 15.5.5.2}). Arguments objects (@uref{#sec-10.6,10.6}) have different implementations of [[Get]]@comma{} [[GetOwnProperty]]@comma{} [[DefineOwnProperty]]@comma{} and [[Delete]]. Function objects (@uref{#sec-15.3,15.3}) have a different implementation of [[Get]].

Host objects may implement these internal methods in any manner unless specified otherwise; for example@comma{} one possibility is that [[Get]] and [[Put]] for a particular host object indeed fetch and store property values but [[HasProperty]] always generates false. However@comma{} if any specified manipulation of a host object’s internal properties is not supported by an implementation@comma{} that manipulation must throw a TypeError exception when attempted.

The [[GetOwnProperty]] internal method of a host object must conform to the following invariants for each property of the host object:

@itemize
@item
If a property is described as a data property and it may return different values over time@comma{} then either or both of the [[Writable]] and [[Configurable]] attributes must be true even if no mechanism to change the value is exposed via the other internal methods.

@item
If a property is described as a data property and its [[Writable]] and [[Configurable]] are both false@comma{} then @uref{#sec-9.12,the SameValue (according to 9.12)} must be returned for the [[Value]] attribute of the property on all calls to [[GetOwnProperty]].

@item
If the attributes other than [[Writable]] may change over time or if the property might disappear@comma{} then the [[Configurable]] attribute must be true.

@item
If the [[Writable]] attribute may change from false to true@comma{} then the [[Configurable]] attribute must be true.

@item
If the value of the host object’s [[Extensible]] internal property is has been observed by ECMAScript code to be false@comma{} then if a call to [[GetOwnProperty]] describes a property as non-existent all subsequent calls must also describe that property as non-existent.

@end itemize

The [[DefineOwnProperty]] internal method of a host object must not permit the addition of a new property to a host object if the [[Extensible]] internal property of that host object has been observed by ECMAScript code to be false.

If the [[Extensible]] internal property of that host object has been observed by ECMAScript code to be false then it must not subsequently become true.


Internal Property
Value Type Domain
Description
[[PrimitiveValue]]
primitive
Internal state information associated with this object. Of the standard built-in ECMAScript objects@comma{} only Boolean@comma{} Date@comma{} Number@comma{} and String objects implement [[PrimitiveValue]].
[[Construct]]
SpecOp(a @uref{#sec-8.8,List} of any) → Object
Creates an object. Invoked via the @code{new} operator. The arguments to the SpecOp are the arguments passed to the @code{new} operator. Objects that implement this internal method are called constructors.
[[Call]]
SpecOp(any@comma{} a @uref{#sec-8.8,List} of any) → any or @uref{#sec-8.7,Reference}
Executes code associated with the object. Invoked via a function call expression. The arguments to the SpecOp are a this object and a list containing the arguments passed to the function call expression. Objects that implement this internal method are callable. Only callable objects that are host objects may return @uref{#sec-8.7,Reference} values.
[[HasInstance]]
SpecOp(any) → Boolean
Returns a Boolean value indicating whether the argument is likely an Object that was constructed by this object. Of the standard built-in ECMAScript objects@comma{} only Function objects implement [[HasInstance]].
[[Scope]]
@uref{#sec-10.2,Lexical Environment}
A @uref{#sec-10.2,lexical environment} that defines the environment in which a Function object is executed. Of the standard built-in ECMAScript objects@comma{} only Function objects implement [[Scope]].
[[FormalParameters]]
@uref{#sec-8.8,List} of Strings
A possibly empty @uref{#sec-8.8,List} containing the identifier Strings of a Function’s FormalParameterList. Of the standard built-in ECMAScript objects@comma{} only Function objects implement [[FormalParameters]].
[[Code]]
ECMAScript code
The ECMAScript code of a function. Of the standard built-in ECMAScript objects@comma{} only Function objects implement [[Code]].
[[TargetFunction]]
Object
The target function of a function object created using the standard built-in @uref{#sec-15.3.4.5,Function.prototype.bind} method. Only ECMAScript objects created using @uref{#sec-15.3.4.5,Function.prototype.bind} have a [[TargetFunction]] internal property.
[[BoundThis]]
any
The pre-bound this value of a function Object created using the standard built-in @uref{#sec-15.3.4.5,Function.prototype.bind} method. Only ECMAScript objects created using @uref{#sec-15.3.4.5,Function.prototype.bind} have a [[BoundThis]] internal property.
[[BoundArguments]]
@uref{#sec-8.8,List} of any
The pre-bound argument values of a function Object created using the standard built-in @uref{#sec-15.3.4.5,Function.prototype.bind} method. Only ECMAScript objects created using @uref{#sec-15.3.4.5,Function.prototype.bind} have a [[BoundArguments]] internal property.
[[Match]]
SpecOp(String@comma{} index) → MatchResult
Tests for a regular expression match and returns a MatchResult value (@uref{#sec-15.10.2.1,see 15.10.2.1}). Of the standard built-in ECMAScript objects@comma{} only RegExp objects implement [[Match]].
[[ParameterMap]]
Object
Provides a mapping between the properties of an arguments object (@uref{#sec-10.6,see 10.6}) and the formal parameters of the associated function. Only ECMAScript objects that are arguments objects have a [[ParameterMap]] internal property.

@node 87 The Reference Specification Type
@chapter @uref{#sec-8.7,8.7} The Reference Specification Type
The Reference type is used to explain the behaviour of such operators as @code{delete}@comma{} @code{typeof}@comma{} and the assignment operators. For example@comma{} the left-hand operand of an assignment is expected to produce a

A @strong{Reference} is a resolved name binding. A Reference consists of three components@comma{} the base value@comma{} the referenced name and the Boolean valued strict reference flag. The base value is either undefined@comma{} an Object@comma{} a Boolean@comma{} a String@comma{} a Number@comma{} or an @uref{#sec-10.2.1,environment record (10.2.1)}. A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.

The following abstract operations are used in this specification to access the components of references:

@itemize
@item
GetBase(V). Returns the base value component of the reference V.

@item
GetReferencedName(V). Returns the referenced name component of the reference V.

@item
IsStrictReference(V). Returns the strict reference component of the reference V.

@item
HasPrimitiveBase(V). Returns true if the base value is a Boolean@comma{} String@comma{} or Number.

@item
IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.

@item
IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.

@end itemize

The following abstract operations are used in this specification to operate on references:


@node 871 GetValue V
@chapter @uref{#sec-8.7.1,8.7.1} GetValue (V)
@enumerate
@item
If @uref{#def-type,Type}(V) is not @uref{#sec-8.7,Reference}@comma{} return V.
@item
Let base be the result of calling @uref{#def-GetBase,GetBase}(V).
@item
If @uref{#def-IsUnresolvableReference,IsUnresolvableReference}(V)@comma{} throw a ReferenceError exception.
@item
If @uref{#def-IsPropertyReference,IsPropertyReference}(V)@comma{} then
@enumerate
@item
If @uref{#def-HasPrimitiveBase,HasPrimitiveBase}(V) is false@comma{} then let get be the [[Get]] internal method of base@comma{} otherwise let get be the special [[Get]] internal method defined below.
@item
Return the result of calling the get internal method using base as its this value@comma{} and passing @uref{#def-GetReferencedName,GetReferencedName}(V) for the argument.
@end enumerate

@item
Else@comma{} base must be an @uref{#sec-10.2.1,environment record}.
@enumerate
@item
Return the result of calling the GetBindingValue (@uref{#sec-10.2.1,see 10.2.1}) concrete method of base passing @uref{#def-GetReferencedName,GetReferencedName}(V) and @uref{#def-IsStrictReference,IsStrictReference}(V) as arguments.
@end enumerate

@end enumerate

The following [[Get]] internal method is used by GetValue when V is a @uref{#def-IsPropertyReference,property reference} with a primitive base value. It is called using base as its this value and with property P as its argument. The following steps are taken:

@enumerate
@item
Let O be @uref{#sec-9.9,ToObject}(base).
@item
Let desc be the result of calling the [[GetProperty]] internal method of O with property name P.
@item
If desc is undefined@comma{} return undefined.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(desc) is true@comma{} return desc.[[Value]].
@item
Otherwise@comma{} @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(desc) must be true so@comma{} let getter be desc.[[Get]].
@item
If getter is undefined@comma{} return undefined.
@item
Return the result calling the [[Call]] internal method of getter providing base as the this value and providing no arguments.
@end enumerate

NOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation might choose to avoid the actual creation of the object. The only situation where such an actual property access that uses this internal method can have visible effect is when it invokes an accessor function.


@node 872 PutValue V W
@chapter @uref{#sec-8.7.2,8.7.2} PutValue (V@comma{} W)
@enumerate
@item
If @uref{#def-type,Type}(V) is not @uref{#sec-8.7,Reference}@comma{} throw a ReferenceError exception.
@item
Let base be the result of calling @uref{#def-GetBase,GetBase}(V).
@item
If @uref{#def-IsUnresolvableReference,IsUnresolvableReference}(V)@comma{} then
@enumerate
@item
If @uref{#def-IsStrictReference,IsStrictReference}(V) is true@comma{} then
@enumerate
@item
Throw a ReferenceError exception.
@end enumerate

@item
Call the [[Put]] internal method of the global object@comma{} passing @uref{#def-GetReferencedName,GetReferencedName}(V) for the property name@comma{} W for the value@comma{} and false for the Throw flag.
@end enumerate

@item
Else if @uref{#def-IsPropertyReference,IsPropertyReference}(V)@comma{} then
@enumerate
@item
If @uref{#def-HasPrimitiveBase,HasPrimitiveBase}(V) is false@comma{} then let put be the [[Put]] internal method of base@comma{} otherwise let put be the special [[Put]] internal method defined below.
@item
Call the put internal method using base as its this value@comma{} and passing @uref{#def-GetReferencedName,GetReferencedName}(V) for the property name@comma{} W for the value@comma{} and @uref{#def-IsStrictReference,IsStrictReference}(V) for the Throw flag.
@end enumerate

@item
Else base must be a reference whose base is an @uref{#sec-10.2.1,environment record}. So@comma{}
@enumerate
@item
Call the SetMutableBinding (@uref{#sec-10.2.1,10.2.1}) concrete method of base@comma{} passing @uref{#def-GetReferencedName,GetReferencedName}(V)@comma{} W@comma{} and @uref{#def-IsStrictReference,IsStrictReference}(V) as arguments.
@end enumerate

@item
Return.
@end enumerate

The following [[Put]] internal method is used by PutValue when V is a @uref{#def-IsPropertyReference,property reference} with a primitive base value. It is called using base as its this value and with property P@comma{} value W@comma{} and Boolean flag Throw as arguments. The following steps are taken:

@enumerate
@item
Let O be @uref{#sec-9.9,ToObject}(base).
@item
If the result of calling the [[CanPut]] internal method of O with argument P is false@comma{} then
@enumerate
@item
If Throw is true@comma{} then throw a TypeError exception.
@item
Else return.
@end enumerate

@item
Let ownDesc be the result of calling the [[GetOwnProperty]] internal method of O with argument P.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(ownDesc) is true@comma{} then
@enumerate
@item
If Throw is true@comma{} then throw a TypeError exception.
@item
Else Return.
@end enumerate

@item
Let desc be the result of calling the [[GetProperty]] internal method of O with argument P. This may be either an own or inherited @uref{#def-accessor-property-descriptor,accessor property descriptor} or an inherited @uref{#def-data-property-descriptor,data property descriptor}.
@item
If @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(desc) is true@comma{} then
@enumerate
@item
Let setter be desc.[[Set]] which cannot be undefined.
@item
Call the [[Call]] internal method of setter providing base as the this value and an argument list containing only W.
@end enumerate

@item
Else@comma{} this is a request to create an own property on the transient object O
@enumerate
@item
If Throw is true@comma{} then throw a TypeError exception.
@end enumerate

@item
Return.
@end enumerate

NOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation might choose to avoid the actual creation of that transient object. The only situations where such an actual property assignment that uses this internal method can have visible effect are when it either invokes an accessor function or is in violation of a Throw predicated error check. When Throw is true any property assignment that would create a new property on the transient object throws an error.


@node 88 The List Specification Type
@chapter @uref{#sec-8.8,8.8} The List Specification Type
The List type is used to explain the evaluation of argument lists (@uref{#sec-11.2.4,see 11.2.4}) in @code{new} expressions@comma{} in function calls@comma{} and in other algorithms where a simple list of values is needed. Values of the List type are simply ordered sequences of values. These sequences may be of any length.


@node 89 The Completion Specification Type
@chapter @uref{#sec-8.9,8.9} The Completion Specification Type
The Completion type is used to explain the behaviour of statements (break@comma{} continue@comma{} return and throw) that perform nonlocal transfers of control. Values of the Completion type are triples of the form (type@comma{} value@comma{} target)@comma{} where type is one of normal@comma{} break@comma{} continue@comma{} return@comma{} or throw@comma{} value is any ECMAScript language value or empty@comma{} and target is any ECMAScript identifier or empty.

The term “abrupt completion” refers to any completion with a type other than normal.



@node 810 The Property Descriptor and Property Identifier Specification Types
@chapter @uref{#sec-8.10,8.10} The Property Descriptor and Property Identifier Specification Types
The Property Descriptor type is used to explain the manipulation and reification of named property attributes. Values of the Property Descriptor type are records composed of named fields where each field’s name is an attribute name and its value is a corresponding attribute value as specified in @uref{#sec-8.6.1,8.6.1}. In addition@comma{} any field may be present or absent.

Property Descriptor values may be further classified as data property descriptors and accessor property descriptors based upon the existence or use of certain fields. A data property descriptor is one that includes any fields named either [[Value]] or [[Writable]]. An accessor property descriptor is one that includes any fields named either [[Get]] or [[Set]]. Any property descriptor may have fields named [[Enumerable]] and [[Configurable]]. A Property Descriptor value may not be both a data property descriptor and an accessor property descriptor; however@comma{} it may be neither. A generic property descriptor is a Property Descriptor value that is neither a data property descriptor nor an accessor property descriptor. A fully populated property descriptor is one that is either an accessor property descriptor or a data property descriptor and that has all of the fields that correspond to the property attributes defined in either @uref{#sec-8.6.1,8.6.1} Table 5 or Table 6.

For notational convenience within this specification@comma{} an object literal-like syntax can be used to define a property descriptor value. For example@comma{} Property Descriptor @{[[Value]]: 42@comma{} [[Writable]]: false@comma{} [[Configurable]]: true@} defines a data property descriptor. Field name order is not significant. Any fields that are not explicitly listed are considered to be absent.

In specification text and algorithms@comma{} dot notation may be used to refer to a specific field of a Property Descriptor. For example@comma{} if D is a property descriptor then D.[[Value]] is shorthand for “the field of D named [[Value]]”.

The Property Identifier type is used to associate a property name with a Property Descriptor. Values of the Property Identifier type are pairs of the form (name@comma{} descriptor)@comma{} where name is a String and descriptor is a Property Descriptor value.

The following abstract operations are used in this specification to operate upon Property Descriptor values:


@node 8101 IsAccessorDescriptor  Desc
@chapter @uref{#sec-8.10.1,8.10.1} IsAccessorDescriptor ( Desc )
When the abstract operation IsAccessorDescriptor is called with property descriptor Desc@comma{} the following steps are taken:

@enumerate
@item
If Desc is undefined@comma{} then return false.
@item
If both Desc.[[Get]] and Desc.[[Set]] are absent@comma{} then return false.
@item
Return true.
@end enumerate


@node 8102 IsDataDescriptor  Desc
@chapter @uref{#sec-8.10.2,8.10.2} IsDataDescriptor ( Desc )
When the abstract operation IsDataDescriptor is called with property descriptor Desc@comma{} the following steps are taken:

@enumerate
@item
If Desc is undefined@comma{} then return false.
@item
If both Desc.[[Value]] and Desc.[[Writable]] are absent@comma{} then return false.
@item
Return true.
@end enumerate


@node 8103 IsGenericDescriptor  Desc
@chapter @uref{#sec-8.10.3,8.10.3} IsGenericDescriptor ( Desc )
When the abstract operation IsGenericDescriptor is called with property descriptor Desc@comma{} the following steps are taken:

@enumerate
@item
If Desc is undefined@comma{} then return false.
@item
If @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(Desc) and @uref{#def-IsDataDescriptor,IsDataDescriptor}(Desc) are both false@comma{} then return true.
@item
Return false.
@end enumerate



@node 8104 FromPropertyDescriptor  Desc
@chapter @uref{#sec-8.10.4,8.10.4} FromPropertyDescriptor ( Desc )
When the abstract operation FromPropertyDescriptor is called with property descriptor Desc@comma{} the following steps are taken:

The following algorithm assumes that Desc is a @uref{#def-fully-populated,fully populated} @uref{#sec-8.10,Property Descriptor}@comma{} such as that returned from [[GetOwnProperty]] (@uref{#sec-8.12.1,see 8.12.1}).

@enumerate
@item
If Desc is undefined@comma{} then return undefined.
@item
Let obj be the result of creating a new object as if by the expression @code{new Object()} where @code{Object} is the standard built-in constructor with that name.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(Desc) is true@comma{} then
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "value"@comma{} Property Descriptor @{[[Value]]: Desc.[[Value]]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "writable"@comma{} Property Descriptor @{[[Value]]: Desc.[[Writable]]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Else@comma{} @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(Desc) must be true@comma{} so
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "get"@comma{} Property Descriptor @{[[Value]]: Desc.[[Get]]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "set"@comma{} Property Descriptor @{[[Value]]: Desc.[[Set]]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "enumerable"@comma{} Property Descriptor @{[[Value]]: Desc.[[Enumerable]]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "configurable"@comma{} Property Descriptor @{[[Value]]: Desc.[[Configurable]]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return obj.
@end enumerate


@node 8105 ToPropertyDescriptor  Obj
@chapter @uref{#sec-8.10.5,8.10.5} ToPropertyDescriptor ( Obj )
When the abstract operation ToPropertyDescriptor is called with object Desc@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(Obj) is not Object throw a TypeError exception.
@item
Let desc be the result of creating a new Property Descriptor that initially has no fields.
@item
If the result of calling the [[HasProperty]] internal method of Obj with argument "enumerable" is true@comma{} then
@enumerate
@item
Let enum be the result of calling the [[Get]] internal method of Obj with "enumerable".
@item
Set the [[Enumerable]] field of desc to @uref{#sec-9.2,ToBoolean}(enum).
@end enumerate

@item
If the result of calling the [[HasProperty]] internal method of Obj with argument "configurable" is true@comma{} then
@enumerate
@item
Let conf be the result of calling the [[Get]] internal method of Obj with argument "configurable".
@item
Set the [[Configurable]] field of desc to @uref{#sec-9.2,ToBoolean}(conf).
@end enumerate

@item
If the result of calling the [[HasProperty]] internal method of Obj with argument "value" is true@comma{} then
@enumerate
@item
Let value be the result of calling the [[Get]] internal method of Obj with argument "value".
@item
Set the [[Value]] field of desc to value.
@end enumerate

@item
If the result of calling the [[HasProperty]] internal method of Obj with argument "writable" is true@comma{} then
@enumerate
@item
Let writable be the result of calling the [[Get]] internal method of Obj with argument "writable".
@item
Set the [[Writable]] field of desc to @uref{#sec-9.2,ToBoolean}(writable).
@end enumerate

@item
If the result of calling the [[HasProperty]] internal method of Obj with argument "get" is true@comma{} then
@enumerate
@item
Let getter be the result of calling the [[Get]] internal method of Obj with argument "get".
@item
If @uref{#sec-9.11,IsCallable}(getter) is false and getter is not undefined@comma{} then throw a TypeError exception.
@item
Set the [[Get]] field of desc to getter.
@end enumerate

@item
If the result of calling the [[HasProperty]] internal method of Obj with argument "set" is true@comma{} then
@enumerate
@item
Let setter be the result of calling the [[Get]] internal method of Obj with argument "set".
@item
If @uref{#sec-9.11,IsCallable}(setter) is false and setter is not undefined@comma{} then throw a TypeError exception.
@item
Set the [[Set]] field of desc to setter.
@end enumerate

@item
If either desc.[[Get]] or desc.[[Set]] are present@comma{} then
@enumerate
@item
If either desc.[[Value]] or desc.[[Writable]] are present@comma{} then throw a TypeError exception.
@end enumerate

@item
Return desc.
@end enumerate


@node 811 The Lexical Environment and Environment Record Specification Types
@chapter @uref{#sec-8.11,8.11} The Lexical Environment and Environment Record Specification Types
The @uref{#sec-10.2,Lexical Environment} and @uref{#sec-10.2.1,Environment Record} types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in @uref{#sec-10,Clause 10}.


@node 812 Algorithms for Object Internal Methods
@chapter @uref{#sec-8.12,8.12} Algorithms for Object Internal Methods
In the following algorithm descriptions@comma{} assume O is a native ECMAScript object@comma{} P is a String@comma{} Desc is a Property Description record@comma{} and Throw is a Boolean flag.


@node 8121 [[GetOwnProperty]] P
@chapter @uref{#sec-8.12.1,8.12.1} [[GetOwnProperty]] (P)
When the [[GetOwnProperty]] internal method of O is called with property name P@comma{} the following steps are taken:

@enumerate
@item
If O doesn’t have an own property with name P@comma{} return undefined.
@item
Let D be a newly created @uref{#sec-8.10,Property Descriptor} with no fields.
@item
Let X be O’s own property named P.
@item
If X is a data property@comma{} then
@enumerate
@item
Set D.[[Value]] to the value of X’s [[Value]] attribute.
@item
Set D.[[Writable]] to the value of X’s [[Writable]] attribute
@end enumerate

@item
Else X is an accessor property@comma{} so
@enumerate
@item
Set D.[[Get]] to the value of X’s [[Get]] attribute.
@item
Set D.[[Set]] to the value of X’s [[Set]] attribute.
@end enumerate

@item
Set D.[[Enumerable]] to the value of X’s [[Enumerable]] attribute.
@item
Set D.[[Configurable]] to the value of X’s [[Configurable]] attribute.
@item
Return D.
@end enumerate

However@comma{} if O is a String object it has a more elaborate [[GetOwnProperty]] internal method defined in @uref{#sec-15.5.5.2,15.5.5.2}.


@node 8122 [[GetProperty]] P
@chapter @uref{#sec-8.12.2,8.12.2} [[GetProperty]] (P)
When the [[GetProperty]] internal method of O is called with property name P@comma{} the following steps are taken:

@enumerate
@item
Let prop be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
@item
If prop is not undefined@comma{} return prop.
@item
Let proto be the value of the [[Prototype]] internal property of O.
@item
If proto is null@comma{} return undefined.
@item
Return the result of calling the [[GetProperty]] internal method of proto with argument P.
@end enumerate


@node 8123 [[Get]] P
@chapter @uref{#sec-8.12.3,8.12.3} [[Get]] (P)
When the [[Get]] internal method of O is called with property name P@comma{} the following steps are taken:

@enumerate
@item
Let desc be the result of calling the [[GetProperty]] internal method of O with property name P.
@item
If desc is undefined@comma{} return undefined.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(desc) is true@comma{} return desc.[[Value]].
@item
Otherwise@comma{} @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(desc) must be true so@comma{} let getter be desc.[[Get]].
@item
If getter is undefined@comma{} return undefined.
@item
Return the result calling the [[Call]] internal method of getter providing O as the this value and providing no arguments.
@end enumerate


@node 8124 [[CanPut]] P
@chapter @uref{#sec-8.12.4,8.12.4} [[CanPut]] (P)
When the [[CanPut]] internal method of O is called with property name P@comma{} the following steps are taken:

@enumerate
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with argument P.
@item
If desc is not undefined@comma{} then
@enumerate
@item
If @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(desc) is true@comma{} then
@enumerate
@item

@item
Else return true.
@end enumerate

@item
Else@comma{} desc must be a DataDescriptor so return the value of desc.[[Writable]].
@end enumerate

@item
Let proto be the [[Prototype]] internal property of O.
@item
If proto is null@comma{} then return the value of the [[Extensible]] internal property of O.
@item
Let inherited be the result of calling the [[GetProperty]] internal method of proto with property name P.
@item
If inherited is undefined@comma{} return the value of the [[Extensible]] internal property of O.
@item
If @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(inherited) is true@comma{} then
@enumerate
@item
If inherited.[[Set]] is undefined@comma{} then return false.
@item
Else return true.
@end enumerate

@item
Else@comma{} inherited must be a DataDescriptor
@enumerate
@item
If the [[Extensible]] internal property of O is false@comma{} return false.
@item
Else return the value of inherited.[[Writable]].
@end enumerate

@end enumerate

Host objects may define additional constraints upon [[Put]] operations. If possible@comma{} host objects should not allow [[Put]] operations in situations where this definition of [[CanPut]] returns false.


@node 8125 [[Put]]  P V Throw
@chapter @uref{#sec-8.12.5,8.12.5} [[Put]] ( P@comma{} V@comma{} Throw )
When the [[Put]] internal method of O is called with property P@comma{} value V@comma{} and Boolean flag Throw@comma{} the following steps are taken:

@enumerate
@item
If the result of calling the [[CanPut]] internal method of O with argument P is false@comma{} then
@enumerate
@item
If Throw is true@comma{} then throw a TypeError exception.
@item
Else return.
@end enumerate

@item
Let ownDesc be the result of calling the [[GetOwnProperty]] internal method of O with argument P.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(ownDesc) is true@comma{} then
@enumerate
@item
Let valueDesc be the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: V@}.
@item
Call the [[DefineOwnProperty]] internal method of O passing P@comma{} valueDesc@comma{} and Throw as arguments.
@item
Return.
@end enumerate

@item
Let desc be the result of calling the [[GetProperty]] internal method of O with argument P. This may be either an own or inherited @uref{#def-accessor-property-descriptor,accessor property descriptor} or an inherited @uref{#def-data-property-descriptor,data property descriptor}.
@item
If @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(desc) is true@comma{} then
@enumerate
@item
Let setter be desc.[[Set]] which cannot be undefined.
@item
Call the [[Call]] internal method of setter providing O as the this value and providing V as the sole argument.
@end enumerate

@item
Else@comma{} create a named data property named P on object O as follows
@enumerate
@item
Let newDesc be the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: V@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}.
@item
Call the [[DefineOwnProperty]] internal method of O passing P@comma{} newDesc@comma{} and Throw as arguments.
@end enumerate

@item
Return.
@end enumerate


@node 8126 [[HasProperty]] P
@chapter @uref{#sec-8.12.6,8.12.6} [[HasProperty]] (P)
When the [[HasProperty]] internal method of O is called with property name P@comma{} the following steps are taken:

@enumerate
@item
Let desc be the result of calling the [[GetProperty]] internal method of O with property name P.
@item
If desc is undefined@comma{} then return false.
@item
Else return true.
@end enumerate


@node 8127 [[Delete]] P Throw
@chapter @uref{#sec-8.12.7,8.12.7} [[Delete]] (P@comma{} Throw)
When the [[Delete]] internal method of O is called with property name P and the Boolean flag Throw@comma{} the following steps are taken:

@enumerate
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
@item
If desc is undefined@comma{} then return true.
@item
If desc.[[Configurable]] is true@comma{} then
@enumerate
@item
Remove the own property with name P from O.
@item
Return true.
@end enumerate

@item
Else if Throw@comma{} then throw a TypeError exception.
@item
Return false.
@end enumerate


@node 8128 [[DefaultValue]] hint
@chapter @uref{#sec-8.12.8,8.12.8} [[DefaultValue]] (hint)
When the [[DefaultValue]] internal method of O is called with hint String@comma{} the following steps are taken:

@enumerate
@item
Let toString be the result of calling the [[Get]] internal method of object O with argument "toString".
@item
If @uref{#sec-9.11,IsCallable}(toString) is true then@comma{}
@enumerate
@item
Let str be the result of calling the [[Call]] internal method of toString@comma{} with O as the this value and an empty argument list.
@item
If str is a primitive value@comma{} return str.
@end enumerate

@item
Let valueOf be the result of calling the [[Get]] internal method of object O with argument "valueOf".
@item
If @uref{#sec-9.11,IsCallable}(valueOf) is true then@comma{}
@enumerate
@item
Let val be the result of calling the [[Call]] internal method of valueOf@comma{} with O as the this value and an empty argument list.
@item
If val is a primitive value@comma{} return val.
@end enumerate

@item
Throw a TypeError exception.
@end enumerate

When the [[DefaultValue]] internal method of O is called with hint Number@comma{} the following steps are taken:

@enumerate
@item
Let valueOf be the result of calling the [[Get]] internal method of object O with argument "valueOf".
@item
If @uref{#sec-9.11,IsCallable}(valueOf) is true then@comma{}
@enumerate
@item
Let val be the result of calling the [[Call]] internal method of valueOf@comma{} with O as the this value and an empty argument list.
@item
If val is a primitive value@comma{} return val.
@end enumerate

@item
Let toString be the result of calling the [[Get]] internal method of object O with argument "toString".
@item
If @uref{#sec-9.11,IsCallable}(toString) is true then@comma{}
@enumerate
@item
Let str be the result of calling the [[Call]] internal method of toString@comma{} with O as the this value and an empty argument list.
@item
If str is a primitive value@comma{} return str.
@end enumerate

@item
Throw a TypeError exception.
@end enumerate

When the [[DefaultValue]] internal method of O is called with no hint@comma{} then it behaves as if the hint were Number@comma{} unless O is a Date object (@uref{#sec-15.9.6,see 15.9.6})@comma{} in which case it behaves as if the hint were String.

The above specification of [[DefaultValue]] for native objects can return only primitive values. If a host object implements its own [[DefaultValue]] internal method@comma{} it must ensure that its [[DefaultValue]] internal method can return only primitive values.


@node 8129 [[DefineOwnProperty]] P Desc Throw
@chapter @uref{#sec-8.12.9,8.12.9} [[DefineOwnProperty]] (P@comma{} Desc@comma{} Throw)
In the following algorithm@comma{} the term “Reject” means “If Throw is true@comma{} then throw a TypeError exception@comma{} otherwise return false”. The algorithm contains steps that test various fields of the @uref{#sec-8.10,Property Descriptor} Desc for specific values. The fields that are tested in this manner need not actually exist in Desc. If a field is absent then its value is considered to be false.

When the [[DefineOwnProperty]] internal method of O is called with property name P@comma{} property descriptor Desc@comma{} and Boolean flag Throw@comma{} the following steps are taken:

@enumerate
@item
Let current be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
@item
Let extensible be the value of the [[Extensible]] internal property of O.
@item
If current is undefined and extensible is false@comma{} then @uref{#def-reject-for-object,Reject}.
@item
If current is undefined and extensible is true@comma{} then
@enumerate
@item
If @uref{#def-IsGenericDescriptor,IsGenericDescriptor}(Desc) or @uref{#def-IsDataDescriptor,IsDataDescriptor}(Desc) is true@comma{} then
@enumerate
@item
Create an own data property named P of object O whose [[Value]]@comma{} [[Writable]]@comma{} [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent@comma{} the attribute of the newly created property is set to its default value.
@end enumerate

@item

@enumerate
@item
Create an own accessor property named P of object O whose [[Get]]@comma{} [[Set]]@comma{} [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent@comma{} the attribute of the newly created property is set to its default value.
@end enumerate

@item
Return true.
@end enumerate

@item
Return true@comma{} if every field in Desc is absent.
@item
Return true@comma{} if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using @uref{#sec-9.12,the SameValue algorithm (9.12)}.
@item
If the [[Configurable]] field of current is false then
@enumerate
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Configurable]] field of Desc is true.
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.
@end enumerate

@item
If @uref{#def-IsGenericDescriptor,IsGenericDescriptor}(Desc) is true@comma{} then no further validation is required.
@item
Else@comma{} if @uref{#def-IsDataDescriptor,IsDataDescriptor}(current) and @uref{#def-IsDataDescriptor,IsDataDescriptor}(Desc) have different results@comma{} then
@enumerate
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Configurable]] field of current is false.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(current) is true@comma{} then
@enumerate
@item
Convert the property named P of object O from a data property to an accessor property. Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and set the rest of the property’s attributes to their default values.
@end enumerate

@item
Else@comma{}
@enumerate
@item
Convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and set the rest of the property’s attributes to their default values.
@end enumerate

@end enumerate

@item
Else@comma{} if @uref{#def-IsDataDescriptor,IsDataDescriptor}(current) and @uref{#def-IsDataDescriptor,IsDataDescriptor}(Desc) are both true@comma{} then
@enumerate
@item
If the [[Configurable]] field of current is false@comma{} then
@enumerate
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
@item
If the [[Writable]] field of current is false@comma{} then
@enumerate
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Value]] field of Desc is present and @uref{#sec-9.12,SameValue}(Desc.[[Value]]@comma{} current.[[Value]]) is false.
@end enumerate

@end enumerate

@item
else@comma{} the [[Configurable]] field of current is true@comma{} so any change is acceptable.
@end enumerate

@item
Else@comma{} @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(current) and @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(Desc) are both true so@comma{}
@enumerate
@item
If the [[Configurable]] field of current is false@comma{} then
@enumerate
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Set]] field of Desc is present and @uref{#sec-9.12,SameValue}(Desc.[[Set]]@comma{} current.[[Set]]) is false.
@item
@uref{#def-reject-for-object,Reject}@comma{} if the [[Get]] field of Desc is present and @uref{#sec-9.12,SameValue}(Desc.[[Get]]@comma{} current.[[Get]]) is false.
@end enumerate

@end enumerate

@item
For each attribute field of Desc that is present@comma{} set the correspondingly named attribute of the property named P of object O to the value of the field.
@item
Return true. However@comma{} if O is an Array object@comma{} it has a more elaborate [[DefineOwnProperty]] internal method defined in @uref{#sec-15.4.5.1,15.4.5.1}.
@end enumerate

NOTE Step 10.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is true. This even permits changing the [[Value]] of a property whose [[Writable]] attribute is false. This is allowed because a true [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to true@comma{} a new [[Value]] is set@comma{} and then [[Writable]] is set to false.


@node 9 Type Conversion and Testing
@chapter @uref{#sec-9,9} Type Conversion and Testing
The ECMAScript runtime system performs automatic type conversion as needed. To clarify the semantics of certain constructs it is useful to define a set of conversion abstract operations. These abstract operations are not a part of the language; they are defined here to aid the specification of the semantics of the language. The conversion abstract operations are polymorphic; that is@comma{} they can accept a value of any ECMAScript language type@comma{} but not of specification types.



@node 91 ToPrimitive
@chapter @uref{#sec-9.1,9.1} ToPrimitive
The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type@comma{} it may use the optional hint PreferredType to favour that type. Conversion occurs according to Table 10:

Table 10 — ToPrimitive Conversions
Input Type
Result
Undefined
The result equals the input argument (no conversion).
Null
The result equals the input argument (no conversion).
Boolean
The result equals the input argument (no conversion).
Number
The result equals the input argument (no conversion).
String
The result equals the input argument (no conversion).
Object
Return a default value for the Object. The default value of an object is retrieved by calling the [[DefaultValue]] internal method of the object@comma{} passing the optional hint PreferredType. The behaviour of the [[DefaultValue]] internal method is defined by this specification for all native ECMAScript objects in @uref{#sec-8.12.8,8.12.8}.

@node 92 ToBoolean
@chapter @uref{#sec-9.2,9.2} ToBoolean
The abstract operation ToBoolean converts its argument to a value of type Boolean according to Table 11:

Table 11 — ToBoolean Conversions
Argument Type
Result
Undefined
false
Null
false
Boolean
The result equals the input argument (no conversion).
Number
The result is false if the argument is +0@comma{} −0@comma{} or NaN; otherwise the result is true.
String
The result is false if the argument is the empty String (its length is zero); otherwise the result is true.
Object
true

@node 93 ToNumber
@chapter @uref{#sec-9.3,9.3} ToNumber
The abstract operation ToNumber converts its argument to a value of type Number according to Table 12:


Argument Type
Result
Undefined
NaN
Null
+0
Boolean
The result is 1 if the argument is true. The result is +0 if the argument is false.
Number
The result equals the input argument (no conversion).
String
See grammar and note below.
Object
Apply the following steps:
@enumerate
@item
Let primValue be @uref{#sec-9.1,ToPrimitive}(input argument@comma{} hint Number).
@item
Return ToNumber(primValue).
@end enumerate


@node 931 ToNumber Applied to the String Type
@chapter @uref{#sec-9.3.1,9.3.1} ToNumber Applied to the String Type
@uref{#sec-9.3,ToNumber} applied to Strings applies the following grammar to the input String. If the grammar cannot interpret the String as an expansion of StringNumericLiteral@comma{} then the result of ToNumber is NaN.

StringNumericLiteral :::
StrWhiteSpace_opt_
StrWhiteSpace_opt_ StrNumericLiteral StrWhiteSpace_opt_
StrWhiteSpace :::
StrWhiteSpaceChar StrWhiteSpace_opt_
StrWhiteSpaceChar :::
WhiteSpace
LineTerminator
StrNumericLiteral :::
StrDecimalLiteral
HexIntegerLiteral
StrDecimalLiteral :::
StrUnsignedDecimalLiteral
@code{+} StrUnsignedDecimalLiteral
@code{-} StrUnsignedDecimalLiteral
StrUnsignedDecimalLiteral :::
@code{Infinity}
DecimalDigits @code{.} DecimalDigits_opt_ ExponentPart_opt_
@code{.} DecimalDigits ExponentPart_opt_
DecimalDigits ExponentPart_opt_
DecimalDigits :::
DecimalDigit
DecimalDigits DecimalDigit
DecimalDigit ::: one of
@code{0  1  2  3  4  5  6  7  8  9}
ExponentPart :::
ExponentIndicator SignedInteger
ExponentIndicator ::: one of
@code{e  E}

SignedInteger :::
DecimalDigits
@code{+} DecimalDigits
@code{-} DecimalDigits
HexIntegerLiteral :::
@code{0x} HexDigit
@code{0X} HexDigit
HexIntegerLiteral HexDigit
HexDigit ::: one of
@code{0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  A  B  C  D  E  F}
Some differences should be noted between the syntax of a StringNumericLiteral and a NumericLiteral (@uref{#sec-7.8.3,see 7.8.3}):

@itemize
@item
A StringNumericLiteral may be preceded and/or followed by white space and/or line terminators.
@item
A StringNumericLiteral that is decimal may have any number of leading @code{0} digits.
@item
A StringNumericLiteral that is decimal may be preceded by @code{+} or @code{-} to indicate its sign.
@item
A StringNumericLiteral that is empty or contains only white space is converted to +0.
@end itemize

The conversion of a String to a Number value is similar overall to the determination of the Number value for a numeric literal (@uref{#sec-7.8.3,see 7.8.3})@comma{} but some of the details are different@comma{} so the process for converting a String numeric literal to a value of Number type is given here in full. This value is determined in two steps: first@comma{} a mathematical value (MV) is derived from the String numeric literal; second@comma{} this mathematical value is rounded as described below.

@itemize
@item
The MV of StringNumericLiteral ::: [empty] is 0.
@item
The MV of StringNumericLiteral ::: StrWhiteSpace is 0.
@item
The MV of StringNumericLiteral ::: StrWhiteSpace_opt_ StrNumericLiteral StrWhiteSpace_opt_ is the MV of StrNumericLiteral@comma{} no matter whether white space is present or not.
@item
The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of StrDecimalLiteral.
@item
The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of HexIntegerLiteral.
@item
The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the MV of StrUnsignedDecimalLiteral.
@item
The MV of StrDecimalLiteral ::: @code{+} StrUnsignedDecimalLiteral is the MV of StrUnsignedDecimalLiteral.
@item
The MV of StrDecimalLiteral ::: @code{-} StrUnsignedDecimalLiteral is the negative of the MV of StrUnsignedDecimalLiteral. (Note that if the MV of StrUnsignedDecimalLiteral is 0@comma{} the negative of this MV is also 0. The rounding rule described below handles the conversion of this signless mathematical zero to a floating-point +0 or −0 as appropriate.)
@item
The MV of StrUnsignedDecimalLiteral ::: @code{Infinity} is 10^10000 (a value so large that it will round to +∞).
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits @code{.} is the MV of DecimalDigits.
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits @code{.} DecimalDigits is the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10^−n)@comma{} where n is the number of characters in the second DecimalDigits.
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits @code{.} ExponentPart is the MV of DecimalDigits times 10^e@comma{} where e is the MV of ExponentPart.
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits @code{.} DecimalDigits ExponentPart is (the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10^−n)) times 10^e@comma{} where n is the number of characters in the second DecimalDigits and e is the MV of ExponentPart.
@item
The MV of StrUnsignedDecimalLiteral ::: @code{.} DecimalDigits is the MV of DecimalDigits times 10^−n@comma{} where n is the number of characters in DecimalDigits.
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart is the MV of DecimalDigits times 10^e−n@comma{} where n is the number of characters in DecimalDigits and e is the MV of ExponentPart.
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits is the MV of DecimalDigits.
@item
The MV of StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart is the MV of DecimalDigits times 10^e@comma{} where e is the MV of ExponentPart.
@item
The MV of DecimalDigits ::: DecimalDigit is the MV of DecimalDigit.
@item

@item
The MV of ExponentPart ::: ExponentIndicator SignedInteger is the MV of SignedInteger.
@item
The MV of SignedInteger ::: DecimalDigits is the MV of DecimalDigits.
@item
The MV of SignedInteger ::: @code{+} DecimalDigits is the MV of DecimalDigits.
@item
The MV of SignedInteger ::: @code{-} DecimalDigits is the negative of the MV of DecimalDigits.
@item
The MV of DecimalDigit ::: @code{0} or of HexDigit ::: @code{0} is 0.
@item
The MV of DecimalDigit ::: @code{1} or of HexDigit ::: @code{1} is 1.
@item
The MV of DecimalDigit ::: @code{2} or of HexDigit ::: @code{2} is 2.
@item
The MV of DecimalDigit ::: @code{3} or of HexDigit ::: @code{3} is 3.
@item
The MV of DecimalDigit ::: @code{4} or of HexDigit ::: @code{4} is 4.
@item
The MV of DecimalDigit ::: @code{5} or of HexDigit ::: @code{5} is 5.
@item
The MV of DecimalDigit ::: @code{6} or of HexDigit ::: @code{6} is 6.
@item
The MV of DecimalDigit ::: @code{7} or of HexDigit ::: @code{7} is 7.
@item
The MV of DecimalDigit ::: @code{8} or of HexDigit ::: @code{8} is 8.
@item
The MV of DecimalDigit ::: @code{9} or of HexDigit ::: @code{9} is 9.
@item
The MV of HexDigit ::: @code{a} or of HexDigit ::: @code{A} is 10.
@item
The MV of HexDigit ::: @code{b} or of HexDigit ::: @code{B} is 11.
@item
The MV of HexDigit ::: @code{c} or of HexDigit ::: @code{C} is 12.
@item
The MV of HexDigit ::: @code{d} or of HexDigit ::: @code{D} is 13.
@item
The MV of HexDigit ::: @code{e} or of HexDigit ::: @code{E} is 14.
@item
The MV of HexDigit ::: @code{f} or of HexDigit ::: @code{F} is 15.
@item
The MV of HexIntegerLiteral ::: @code{0x} HexDigit is the MV of HexDigit.
@item
The MV of HexIntegerLiteral ::: @code{0X} HexDigit is the MV of HexDigit.
@item
The MV of HexIntegerLiteral ::: HexIntegerLiteral HexDigit is (the MV of HexIntegerLiteral times 16) plus the MV of HexDigit.
@end itemize

Once the exact MV for a String numeric literal has been determined@comma{} it is then rounded to a value of the Number type. If the MV is 0@comma{} then the rounded value is +0 unless the first non white space character in the String numeric literal is ‘@code{-}’@comma{} in which case the rounded value is −0. Otherwise@comma{} the rounded value must be the Number value for the MV (in the sense defined in @uref{#sec-8.5,8.5})@comma{} unless the literal includes a StrUnsignedDecimalLiteral and the literal has more than 20 significant digits@comma{} in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit and then incrementing the literal at the 20th digit position. A digit is significant if it is not part of an ExponentPart and

@itemize
@item
it is not @code{0}; or
@item
there is a nonzero digit to its left and there is a nonzero digit@comma{} not in the ExponentPart@comma{} to its right.
@end itemize


@node 94 ToInteger
@chapter @uref{#sec-9.4,9.4} ToInteger
The abstract operation ToInteger converts its argument to an integral numeric value. This abstract operation functions as follows:

@enumerate
@item
Let number be the result of calling @uref{#sec-9.3,ToNumber} on the input argument.
@item
If number is NaN@comma{} return +0.
@item
If number is +0@comma{} −0@comma{} +∞@comma{} or −∞@comma{} return number.
@item
Return the result of computing @uref{#def-sign,sign}(number) * @uref{#def-floor,floor}(@uref{#def-abs,abs}(number)).
@end enumerate


@node 95 ToInt32 Signed 32 Bit Integer
@chapter @uref{#sec-9.5,9.5} ToInt32: (Signed 32 Bit Integer)
The abstract operation ToInt32 converts its argument to one of 2^32 integer values in the range −2^31 through 2^31−1@comma{} inclusive. This abstract operation functions as follows:


@enumerate
@item
Let number be the result of calling @uref{#sec-9.3,ToNumber} on the input argument.
@item
If number is NaN@comma{} +0@comma{} −0@comma{} +∞@comma{} or −∞@comma{} return +0.
@item
Let posInt be @uref{#def-sign,sign}(number) * @uref{#def-floor,floor}(@uref{#def-abs,abs}(number)).
@item
Let int32bit be posInt @uref{#def-modulo,modulo} 2^32; that is@comma{} a finite integer value k of Number type with positive sign and less than 2^32 in magnitude such that the mathematical difference of posInt and k is mathematically an integer multiple of 2^32.
@item
If int32bit is greater than or equal to 2^31@comma{} return int32bit − 2^32@comma{} otherwise return int32bit.
@end enumerate

NOTE Given the above definition of ToInt32:

@itemize
@item
The ToInt32 abstract operation is idempotent: if applied to a result that it produced@comma{} the second application leaves that value unchanged.
@item
ToInt32(@uref{#sec-9.6,ToUint32}(x)) is equal to ToInt32(x) for all values of x. (It is to preserve this latter property that +∞ and −∞ are mapped to +0.)
@item
ToInt32 maps −0 to +0.
@end itemize


@node 96 ToUint32 Unsigned 32 Bit Integer
@chapter @uref{#sec-9.6,9.6} ToUint32: (Unsigned 32 Bit Integer)
The abstract operation ToUint32 converts its argument to one of 2^32 integer values in the range 0 through 2^32−1@comma{} inclusive. This abstraction operation functions as follows:

@enumerate
@item
Let number be the result of calling @uref{#sec-9.3,ToNumber} on the input argument.
@item
If number is NaN@comma{} +0@comma{} −0@comma{} +∞@comma{} or −∞@comma{} return +0.
@item
Let posInt be @uref{#def-sign,sign}(number) * @uref{#def-floor,floor}(@uref{#def-abs,abs}(number)).
@item
Let int32bit be posInt @uref{#def-modulo,modulo} 2^32; that is@comma{} a finite integer value k of Number type with positive sign and less than 2^32 in magnitude such that the mathematical difference of posInt and k is mathematically an integer multiple of 2^32.
@item
Return int32bit.
@end enumerate

NOTE Given the above definition of ToUInt32:

@itemize
@item
Step 5 is the only difference between ToUint32 and @uref{#sec-9.5,ToInt32}.
@item
The ToUint32 abstract operation is idempotent: if applied to a result that it produced@comma{} the second application leaves that value unchanged.
@item
ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of x. (It is to preserve this latter property that +∞ and −∞ are mapped to +0.)
@item
ToUint32 maps −0 to +0.
@end itemize


@node 97 ToUint16 Unsigned 16 Bit Integer
@chapter @uref{#sec-9.7,9.7} ToUint16: (Unsigned 16 Bit Integer)
The abstract operation ToUint16 converts its argument to one of 2^16 integer values in the range 0 through 2^16−1@comma{} inclusive. This abstract operation functions as follows:

@enumerate
@item
Let number be the result of calling @uref{#sec-9.3,ToNumber} on the input argument.
@item
If number is NaN@comma{} +0@comma{} −0@comma{} +∞@comma{} or −∞@comma{} return +0.
@item
Let posInt be @uref{#def-sign,sign}(number) * @uref{#def-floor,floor}(@uref{#def-abs,abs}(number)).
@item
Let int16bit be posInt @uref{#def-modulo,modulo} 2^16; that is@comma{} a finite integer value k of Number type with positive sign and less than 2^16 in magnitude such that the mathematical difference of posInt and k is mathematically an integer multiple of 2^16.
@item
Return int16bit.
@end enumerate

NOTE Given the above definition of ToUint16:

@itemize
@item
The substitution of 2^16 for 2^32 in step 4 is the only difference between @uref{#sec-9.6,ToUint32} and ToUint16.
@item
ToUint16 maps −0 to +0.
@end itemize


@node 98 ToString
@chapter @uref{#sec-9.8,9.8} ToString
The abstract operation ToString converts its argument to a value of type String according to Table 13:


Argument Type
Result
Undefined
"undefined"
Null
"null"
Boolean
If the argument is true@comma{} then the result is "true". If the argument is false@comma{} then the result is "false".
Number
@uref{#sec-9.8.1,See 9.8.1}.
String
Return the input argument (no conversion)
Object
Apply the following steps:
@enumerate
@item
Let primValue be @uref{#sec-9.1,ToPrimitive}(input argument@comma{} hint String).
@item
Return ToString(primValue).
@end enumerate


@node 981 ToString Applied to the Number Type
@chapter @uref{#sec-9.8.1,9.8.1} ToString Applied to the Number Type
The abstract operation @uref{#sec-9.8,ToString} converts a Number m to String format as follows:

@enumerate
@item
If m is NaN@comma{} return the String "NaN".
@item
If m is +0 or −0@comma{} return the String "0".
@item
If m is less than zero@comma{} return the String concatenation of the String "-" and ToString(−m).
@item
If m is infinity@comma{} return the String "Infinity".
@item
Otherwise@comma{} let n@comma{} k@comma{} and s be integers such that k ≥ 1@comma{} 10^k−1 ≤ s < 10^k@comma{} the Number value for s × 10^n−k is m@comma{} and k is as small as possible. Note that k is the number of digits in the decimal representation of s@comma{} that s is not divisible by 10@comma{} and that the least significant digit of s is not necessarily uniquely determined by these criteria.
@item
If k ≤ n ≤ 21@comma{} return the String consisting of the k digits of the decimal representation of s (in order@comma{} with no leading zeroes)@comma{} followed by n−k occurrences of the character ‘@code{0}’.
@item
If 0 < n ≤ 21@comma{} return the String consisting of the most significant n digits of the decimal representation of s@comma{} followed by a decimal point ‘@code{.}’@comma{} followed by the remaining k−n digits of the decimal representation of s.
@item
If −6 < n ≤ 0@comma{} return the String consisting of the character ‘@code{0}’@comma{} followed by a decimal point ‘@code{.}’@comma{} followed by −n occurrences of the character ‘@code{0}’@comma{} followed by the k digits of the decimal representation of s.
@item
Otherwise@comma{} if k = 1@comma{} return the String consisting of the single digit of s@comma{} followed by lowercase character ‘@code{e}’@comma{} followed by a plus sign ‘@code{+}’ or minus sign ‘@code{-}’ according to whether n−1 is positive or negative@comma{} followed by the decimal representation of the integer @uref{#def-abs,abs}(n−1) (with no leading zeros).
@item
Return the String consisting of the most significant digit of the decimal representation of s@comma{} followed by a decimal point ‘@code{.}’@comma{} followed by the remaining k−1 digits of the decimal representation of s@comma{} followed by the lowercase character ‘@code{e}’@comma{} followed by a plus sign ‘@code{+}’ or minus sign ‘@code{-}’ according to whether n−1 is positive or negative@comma{} followed by the decimal representation of the integer @uref{#def-abs,abs}(n−1) (with no leading zeros).
@end enumerate

NOTE 1 The following observations may be useful as guidelines for implementations@comma{} but are not part of the normative requirements of this Standard:

@itemize
@item
If x is any Number value other than −0@comma{} then @uref{#sec-9.3,ToNumber}(ToString(x)) is exactly the same Number value as x.
@item
The least significant digit of s is not always uniquely determined by the requirements listed in step 5.
@end itemize

NOTE 2 For implementations that provide more accurate conversions than required by the rules above@comma{} it is recommended that the following alternative version of step 5 be used as a guideline:

@quotation
Otherwise@comma{} let n@comma{} k@comma{} and s be integers such that k ≥ 1@comma{} 10^k−1 ≤ s < 10^k@comma{} the Number value for s × 10^n−k is m@comma{} and k is as small as possible. If there are multiple possibilities for s@comma{} choose the value of s for which s × 10^n−k is closest in value to m. If there are two such possible values of s@comma{} choose the one that is even. Note that k is the number of digits in the decimal representation of s and that s is not divisible by 10.

@end quotation
NOTE 3 Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:




@node 99 ToObject
@chapter @uref{#sec-9.9,9.9} ToObject
The abstract operation ToObject converts its argument to a value of type Object according to Table 14:

Table 14 — ToObject
Argument Type
Result
Undefined
Throw a TypeError exception.
Null
Throw a TypeError exception.
Boolean
Create a new Boolean object whose [[PrimitiveValue]] internal property is set to the value of the argument. @uref{#sec-15.6,See 15.6} for a description of Boolean objects.
Number
Create a new Number object whose [[PrimitiveValue]] internal property is set to the value of the argument. @uref{#sec-15.7,See 15.7} for a description of Number objects.
String
Create a new String object whose [[PrimitiveValue]] internal property is set to the value of the argument. @uref{#sec-15.5,See 15.5} for a description of String objects.
Object
The result is the input argument (no conversion).

@node 910 CheckObjectCoercible
@chapter @uref{#sec-9.10,9.10} CheckObjectCoercible
The abstract operation CheckObjectCoercible throws an error if its argument is a value that cannot be converted to an Object using @uref{#sec-9.9,ToObject}. It is defined by Table 15:

Table 15 — CheckObjectCoercible Results
Argument Type
Result
Undefined
Throw a TypeError exception.
Null
Throw a TypeError exception.
Boolean
Return
Number
Return
String
Return
Object
Return

@node 911 IsCallable
@chapter @uref{#sec-9.11,9.11} IsCallable
The abstract operation IsCallable determines if its argument@comma{} which must be an ECMAScript language value@comma{} is a callable function Object according to Table 16:


Argument Type
Result
Undefined
Return false.
Null
Return false.
Boolean
Return false.
Number
Return false.
String
Return false.
Object
If the argument object has a [[Call]] internal method@comma{} then return true@comma{} otherwise return false.

@node 912 The SameValue Algorithm
@chapter @uref{#sec-9.12,9.12} The SameValue Algorithm
The internal comparison abstract operation SameValue(x@comma{} y)@comma{} where x and y are ECMAScript language values@comma{} produces true or false. Such a comparison is performed as follows:

@enumerate
@item
If @uref{#def-type,Type}(x) is different from @uref{#def-type,Type}(y)@comma{} return false.
@item
If @uref{#def-type,Type}(x) is Undefined@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Null@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Number@comma{} then.
@enumerate
@item
If x is NaN and y is NaN@comma{} return true.
@item
If x is +0 and y is −0@comma{} return false.
@item
If x is −0 and y is +0@comma{} return false.
@item
If x is the same Number value as y@comma{} return true.
@item
Return false.
@end enumerate

@item
If @uref{#def-type,Type}(x) is String@comma{} then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise@comma{} return false.
@item
If @uref{#def-type,Type}(x) is Boolean@comma{} return true if x and y are both true or both false; otherwise@comma{} return false.
@item
Return true if x and y refer to the same object. Otherwise@comma{} return false.
@end enumerate


@node 10 Executable Code and Execution Contexts
@chapter @uref{#sec-10,10} Executable Code and Execution Contexts

@node 101 Types of Executable Code
@chapter @uref{#sec-10.1,10.1} Types of Executable Code
There are three types of ECMAScript executable code:

@itemize
@item
Global code is source text that is treated as an ECMAScript Program. The global code of a particular Program does not include any source text that is parsed as part of a FunctionBody.

@item
Eval code is the source text supplied to the built-in @uref{#sec-15.1.2.1,eval} function. More precisely@comma{} if the parameter to the built-in eval function is a String@comma{} it is treated as an ECMAScript Program. The eval code for a particular invocation of eval is the @uref{#def-global-code,global code} portion of that Program.

@item
Function code is source text that is parsed as part of a FunctionBody. The @emph{function code} of a particular FunctionBody does not include any source text that is parsed as part of a nested FunctionBody. @emph{Function code} also denotes the source text supplied when @uref{#sec-15.3.2,using the built-in Function object as a constructor}. More precisely@comma{} the last parameter provided to the Function constructor is converted to a String and treated as the FunctionBody. If more than one parameter is provided to the Function constructor@comma{} all parameters except the last one are converted to Strings and concatenated together@comma{} separated by commas. The resulting String is interpreted as the FormalParameterList for the FunctionBody defined by the last parameter. The function code for a particular instantiation of a Function does not include any source text that is parsed as part of a nested FunctionBody.

@end itemize



@node 1011 Strict Mode Code
@chapter @uref{#sec-10.1.1,10.1.1} Strict Mode Code
An ECMAScript Program syntactic unit may be processed using either unrestricted or strict mode syntax and semantics. When processed using strict mode the three types of ECMAScript code are referred to as strict global code@comma{} strict eval code@comma{} and strict function code. Code is interpreted as strict mode code in the following situations:

@itemize
@item
@uref{#def-global-code,Global code} is strict global code if it begins with a Directive Prologue that contains a Use Strict Directive (@uref{#sec-14.1,see 14.1}).

@item
@uref{#def-eval-code,Eval code} is strict eval code if it begins with a Directive Prologue that contains a Use Strict Directive or if the call to eval is a @uref{#sec-15.1.2.1.1,direct call (see 15.1.2.1.1) to the eval function} that is contained in strict mode code.

@item
@uref{#def-function-code,Function code} that is part of a FunctionDeclaration@comma{} FunctionExpression@comma{} or accessor PropertyAssignment is strict function code if its FunctionDeclaration@comma{} FunctionExpression@comma{} or PropertyAssignment is contained in strict mode code or if the function code begins with a Directive Prologue that contains a Use Strict Directive.

@item
@uref{#def-function-code,Function code} that is supplied as the last argument to the built-in Function constructor is strict function code if the last argument is a String that when processed as a FunctionBody begins with a Directive Prologue that contains a Use Strict Directive.

@end itemize


@node 102 Lexical Environments
@chapter @uref{#sec-10.2,10.2} Lexical Environments
A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an @uref{#sec-10.2.1,Environment Record} and a possibly null reference to an outer Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration@comma{} a WithStatement@comma{} or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.

An @uref{#sec-10.2.1,Environment Record} records the identifier bindings that are created within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may@comma{} of course@comma{} have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example@comma{} if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current execution of the surrounding function.

Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.


@node 1021 Environment Records
@chapter @uref{#sec-10.2.1,10.2.1} Environment Records
There are two kinds of Environment Record values used in this specification: @uref{#sec-10.2.1.1,declarative environment records} and @uref{#sec-10.2.1.2,object environment records}. @uref{#sec-10.2.1.1,Declarative environment records} are used to define the effect of ECMAScript language syntactic elements such as FunctionDeclarations@comma{} VariableDeclarations@comma{} and Catch clauses that directly associate identifier bindings with ECMAScript language values. @uref{#sec-10.2.1.2,Object environment records} are used to define the effect of ECMAScript elements such as Program and WithStatement that associate identifier bindings with the properties of some object.

For specification purposes Environment Record values can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with two concrete subclasses@comma{} declarative environment record and object environment record. The abstract class includes the abstract specification

Table 17 — Abstract Methods of Environment Records
Method
Purpose
HasBinding(N)
Determine if an environment record has a binding for an identifier. Return true if it does and false if it does not. The String value N is the text of the identifier.
CreateMutableBinding(N@comma{}@ D)
Create a new mutable binding in an environment record. The String value N is the text of the bound name. If the optional Boolean argument D is true the binding is may be subsequently deleted.
SetMutableBinding(N@comma{}@ V@comma{}@ S)
Set the value of an already existing mutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and may be a value of any ECMAScript language type. S is a Boolean flag. If S is true and the binding cannot be set throw a TypeError exception. S is used to identify strict mode references.
GetBindingValue(N@comma{}@ S)
Returns the value of an already existing binding from an environment record. The String value N is the text of the bound name. S is used to identify strict mode references. If S is true and the binding does not exist or is uninitialized throw a ReferenceError exception.
DeleteBinding(N)
Delete a binding from an environment record. The String value N is the text of the bound name If a binding for N exists@comma{} remove the binding and return true. If the binding exists but cannot be removed return false. If the binding does not exist return true.
ImplicitThisValue()
Returns the value to use as the this value on calls to function objects that are obtained as binding values from this environment record.

@node 10211 Declarative Environment Records
@chapter @uref{#sec-10.2.1.1,10.2.1.1} Declarative Environment Records
Each declarative environment record is associated with an ECMAScript program scope containing variable and/or function declarations. A declarative environment record binds the set of identifiers defined by the declarations contained within its scope.

In addition to the mutable bindings supported by all Environment Records@comma{} declarative environment records also provide for immutable bindings. An immutable binding is one where the association between an identifier and a value may not be modified once it has been established. Creation and initialization of immutable binding are distinct steps so it is possible for such bindings to exist in either an initialized or uninitialized state. Declarative environment records support the methods listed in Table 18 in addition to the Environment Record abstract specification methods:

Table 18 — Additional Methods of Declarative Environment Records
Method
Purpose
@uref{#sec-10.2.1.1.7,CreateImmutableBinding}(N)
Create a new but uninitialized immutable binding in an environment record. The String value N is the text of the bound name.
@uref{#sec-10.2.1.1.8,InitializeImmutableBinding}(N@comma{}@ V)
Set the value of an already existing but uninitialized immutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.



@node 102111 HasBindingN
@chapter @uref{#sec-10.2.1.1.1,10.2.1.1.1} HasBinding(N)
The concrete environment record method HasBinding for declarative environment records simply determines if the argument identifier is one of the identifiers bound by the record:

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
If envRec has a binding for the name that is the value of N@comma{} return true.
@item
If it does not have such a binding@comma{} return false.
@end enumerate


@node 102112 CreateMutableBinding N D
@chapter @uref{#sec-10.2.1.1.2,10.2.1.1.2} CreateMutableBinding (N@comma{} D)
The concrete Environment Record method CreateMutableBinding for declarative environment records creates a new mutable binding for the name N that is initialized to the value undefined. A binding must not already exist in this Environment Record for N. If Boolean argument D is provided and has the value true the new binding is marked as being subject to deletion.

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
Assert: envRec does not already have a binding for N.
@item
Create a mutable binding in envRec for N and set its bound value to undefined. If D is true record that the newly created binding may be deleted by a subsequent DeleteBinding call.
@end enumerate


@node 102113 SetMutableBindingNVS
@chapter @uref{#sec-10.2.1.1.3,10.2.1.1.3} SetMutableBinding(N@comma{}V@comma{}S)
The concrete Environment Record method SetMutableBinding for declarative environment records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. A binding for N must already exist. If the binding is an @uref{#def-immutable-binding,immutable binding}@comma{} a TypeError is thrown if S is true.

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
Assert: envRec must have a binding for N.
@item
If the binding for N in envRec is a mutable binding@comma{} change its bound value to V.
@item
Else this must be an attempt to change the value of an @uref{#def-immutable-binding,immutable binding} so if S is true throw a TypeError exception.
@end enumerate


@node 102114 GetBindingValueNS
@chapter @uref{#sec-10.2.1.1.4,10.2.1.1.4} GetBindingValue(N@comma{}S)
The concrete Environment Record method GetBindingValue for declarative environment records simply returns the value of its bound identifier whose name is the value of the argument N. The binding must already exist. If S is true and the binding is an uninitialized @uref{#def-immutable-binding,immutable binding} throw a ReferenceError exception.

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
Assert: envRec has a binding for N.
@item
If the binding for N in envRec is an uninitialized immutable binding@comma{} then
@enumerate
@item
If S is false@comma{} return the value undefined@comma{} otherwise throw a ReferenceError exception.
@end enumerate

@item
Else@comma{} return the value currently bound to N in envRec.
@end enumerate


@node 102115 DeleteBinding N
@chapter @uref{#sec-10.2.1.1.5,10.2.1.1.5} DeleteBinding (N)
The concrete Environment Record method DeleteBinding for declarative environment records can only delete bindings that have been explicitly designated as being subject to deletion.

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
If envRec does not have a binding for the name that is the value of N@comma{} return true.
@item
If the binding for N in envRec is cannot be deleted@comma{} return false.
@item
Remove the binding for N from envRec.
@item
Return true.
@end enumerate


@node 102116 ImplicitThisValue
@chapter @uref{#sec-10.2.1.1.6,10.2.1.1.6} ImplicitThisValue()
Declarative Environment Records always return undefined as their ImplicitThisValue.

@enumerate
@item
Return undefined.
@end enumerate


@node 102117 CreateImmutableBinding N
@chapter @uref{#sec-10.2.1.1.7,10.2.1.1.7} CreateImmutableBinding (N)
The concrete Environment Record method CreateImmutableBinding for declarative environment records creates a new immutable binding for the name N that is initialized to the value undefined. A binding must not already exist in this environment record for N.

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
Assert: envRec does not already have a binding for N.
@item
Create an immutable binding in envRec for N and record that it is uninitialized.
@end enumerate


@node 102118 InitializeImmutableBinding NV
@chapter @uref{#sec-10.2.1.1.8,10.2.1.1.8} InitializeImmutableBinding (N@comma{}V)
The concrete Environment Record method InitializeImmutableBinding for declarative environment records is used to set the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. An uninitialized immutable binding for N must already exist.

@enumerate
@item
Let envRec be the declarative environment record for which the method was invoked.
@item
Assert: envRec must have an uninitialized immutable binding for N.
@item
Set the bound value for N in envRec to V.
@item
Record that the immutable binding for N in envRec has been initialized.
@end enumerate


@node 10212 Object Environment Records
@chapter @uref{#sec-10.2.1.2,10.2.1.2} Object Environment Records
Each @uref{#sec-10.2.1,object environment record} is associated with an object called its binding object. An object environment record binds the set of identifier names that directly correspond to the property names of its binding object. Property names that are not an IdentifierName are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]] attribute. Because properties can be dynamically added and deleted from objects@comma{} the set of identifiers bound by an object environment record may potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property has the value false. Immutable bindings do not exist for object environment records.

Object environment records can be configured to provide their binding object as an implicit this value for use in function calls. This capability is used to specify the behaviour of With Statement (@uref{#sec-12.10,12.10}) induced bindings. The capability is controlled by a provideThis Boolean value that is associated with each object environment record. By default@comma{} the value of provideThis is false for any object environment record.

The behaviour of the concrete specification methods for Object Environment Records is defined by the following algorithms.


@node 102121 HasBindingN
@chapter @uref{#sec-10.2.1.2.1,10.2.1.2.1} HasBinding(N)
The concrete Environment Record method HasBinding for object environment records determines if its associated binding object has a property whose name is the value of the argument N:

@enumerate
@item
Let envRec be the object environment record for which the method was invoked.
@item
Let bindings be the binding object for envRec.
@item
Return the result of calling the [[HasProperty]] internal method of bindings@comma{} passing N as the property name.
@end enumerate



@node 102122 CreateMutableBinding N D
@chapter @uref{#sec-10.2.1.2.2,10.2.1.2.2} CreateMutableBinding (N@comma{} D)
The concrete Environment Record method CreateMutableBinding for object environment records creates in an environment record’s associated binding object a property whose name is the String value and initializes it to the value undefined. A property named N must not already exist in the binding object. If Boolean argument D is provided and has the value true the new property’s [[Configurable]] attribute is set to true@comma{} otherwise it is set to false.

@enumerate
@item
Let envRec be the object environment record for which the method was invoked.
@item
Let bindings be the binding object for envRec.
@item
Assert: The result of calling the [[HasProperty]] internal method of bindings@comma{} passing N as the property name@comma{} is false.
@item
If D is true then let configValue be true otherwise let configValue be false.
@item
Call the [[DefineOwnProperty]] internal method of bindings@comma{} passing N@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]:undefined@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true @comma{} [[Configurable]]: configValue@}@comma{} and true as arguments.
@end enumerate


@node 102123 SetMutableBinding NVS
@chapter @uref{#sec-10.2.1.2.3,10.2.1.2.3} SetMutableBinding (N@comma{}V@comma{}S)
The concrete Environment Record method SetMutableBinding for object environment records attempts to set the value of the environment record’s associated binding object’s property whose name is the value of the argument N to the value of argument V. A property named N should already exist but if it does not or is not currently writable@comma{} error handling is determined by the value of the Boolean argument S.

@enumerate
@item
Let envRec be the object environment record for which the method was invoked.
@item
Let bindings be the binding object for envRec.
@item
Call the [[Put]] internal method of bindings with arguments N@comma{} V@comma{} and S.
@end enumerate


@node 102124 GetBindingValueNS
@chapter @uref{#sec-10.2.1.2.4,10.2.1.2.4} GetBindingValue(N@comma{}S)
The concrete Environment Record method GetBindingValue for object environment records returns the value of its associated binding object’s property whose name is the String value of the argument identifier N. The property should already exist but if it does not the result depends upon the value of the S argument:

@enumerate
@item
Let envRec be the object environment record for which the method was invoked.
@item
Let bindings be the binding object for envRec.
@item
Let value be the result of calling the [[HasProperty]] internal method of bindings@comma{} passing N as the property name.
@item
If value is false@comma{} then
@enumerate
@item
If S is false@comma{} return the value undefined@comma{} otherwise throw a ReferenceError exception.
@end enumerate

@item
Return the result of calling the [[Get]] internal method of bindings@comma{} passing N for the argument.
@end enumerate


@node 102125 DeleteBindingN
@chapter @uref{#sec-10.2.1.2.5,10.2.1.2.5} DeleteBinding(N)
The concrete Environment Record method DeleteBinding for object environment records can only delete bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the value true.

@enumerate
@item
Let envRec be the object environment record for which the method was invoked.
@item
Let bindings be the binding object for envRec.
@item
Return the result of calling the [[Delete]] internal method of bindings@comma{} passing N and false as arguments.
@end enumerate


@node 102126 ImplicitThisValue
@chapter @uref{#sec-10.2.1.2.6,10.2.1.2.6} ImplicitThisValue()
Object Environment Records return undefined as their ImplicitThisValue unless their provideThis flag is true.

@enumerate
@item
Let envRec be the object environment record for which the method was invoked.
@item
If the provideThis flag of envRec is true@comma{} return the binding object for envRec.
@item
Otherwise@comma{} return undefined.
@end enumerate


@node 1022 Lexical Environment Operations
@chapter @uref{#sec-10.2.2,10.2.2} Lexical Environment Operations
The following abstract operations are used in this specification to operate upon @uref{#sec-10.2,lexical environments}:


@node 10221 GetIdentifierReference lex name strict
@chapter @uref{#sec-10.2.2.1,10.2.2.1} GetIdentifierReference (lex@comma{} name@comma{} strict)
The abstract operation GetIdentifierReference is called with a @uref{#sec-10.2,Lexical Environment} lex@comma{} an identifier String name@comma{} and a Boolean flag strict. The value of lex may be null. When called@comma{} the following steps are performed:

@enumerate
@item
If lex is the value null@comma{} then
@enumerate
@item
Return a value of type @uref{#sec-8.7,Reference} whose base value is undefined@comma{} whose referenced name is name@comma{} and whose strict mode flag is strict.
@end enumerate

@item
Let envRec be lex’s environment record.
@item
Let exists be the result of calling the HasBinding(N) concrete method of envRec passing name as the argument N.
@item
If exists is true@comma{} then
@enumerate
@item
Return a value of type @uref{#sec-8.7,Reference} whose base value is envRec@comma{} whose referenced name is name@comma{} and whose strict mode flag is strict.
@end enumerate

@item
Else
@enumerate
@item
Let outer be the value of lex’s @uref{#def-outer-environment,outer environment reference}.
@item
Return the result of calling @uref{#sec-10.2.2.1,GetIdentifierReference} passing outer@comma{} name@comma{} and strict as arguments.
@end enumerate

@end enumerate


@node 10222 NewDeclarativeEnvironmentE
@chapter @uref{#sec-10.2.2.2,10.2.2.2} NewDeclarativeEnvironment(E)
When the abstract operation NewDeclarativeEnvironment is called with either a @uref{#sec-10.2,Lexical Environment} or null as argument E the following steps are performed:

@enumerate
@item
Let env be a new @uref{#sec-10.2,Lexical Environment}.
@item
Let envRec be a new declarative environment record containing no bindings.
@item
Set env’s environment record to be envRec.
@item
Set the @uref{#def-outer-environment,outer lexical environment reference} of env to E.
@item
Return env.
@end enumerate


@node 10223 NewObjectEnvironment O E
@chapter @uref{#sec-10.2.2.3,10.2.2.3} NewObjectEnvironment (O@comma{} E)
When the abstract operation NewObjectEnvironmentis called with an Object O and a @uref{#sec-10.2,Lexical Environment} E (or null) as arguments@comma{} the following steps are performed:

@enumerate
@item
Let env be a new @uref{#sec-10.2,Lexical Environment}.
@item
Let envRec be a new object environment record containing O as the @uref{#sec-10.2.1.2,binding object}.
@item
Set env’s environment record to be envRec.
@item
Set the @uref{#def-outer-environment,outer lexical environment reference} of env to E.
@item
Return env.
@end enumerate


@node 1023 The Global Environment
@chapter @uref{#sec-10.2.3,10.2.3} The Global Environment
The global environment is a unique @uref{#sec-10.2,Lexical Environment} which is created before any ECMAScript code is executed. The global environment’s Environment Record is an @uref{#sec-10.2.1.2,object environment record} whose @uref{#sec-10.2.1.2,binding object} is the @uref{#sec-15.1,global object (15.1)}. The global environment’s @uref{#def-outer-environment,outer environment reference} is null.

As ECMAScript code is executed@comma{} additional properties may be added to the global object and the initial properties may be modified.


@node 103 Execution Contexts
@chapter @uref{#sec-10.3,10.3} Execution Contexts
When control is transferred to ECMAScript executable code@comma{} control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with

An execution context contains whatever state is necessary to track the execution progress of its associated code. In addition@comma{} each execution context has the state components listed in Table 19.

Table 19 — Execution Context State Components
Component
Purpose
LexicalEnvironment
Identifies the @uref{#sec-10.2,Lexical Environment} used to resolve identifier references made by code within this execution context.
VariableEnvironment
Identifies the @uref{#sec-10.2,Lexical Environment} whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context.
ThisBinding
The value associated with the @code{this} keyword within ECMAScript code associated with this execution context.
The LexicalEnvironment and VariableEnvironment components of an execution context are always @uref{#sec-10.2,Lexical Environments}. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.

In most situations only the running execution context (the top of the execution context stack) is directly manipulated by algorithms within this specification. Hence when the terms “LexicalEnvironment”@comma{} “VariableEnvironment” and “ThisBinding” are used without qualification they are in reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to access an execution context.


@node 1031 Identifier Resolution
@chapter @uref{#sec-10.3.1,10.3.1} Identifier Resolution
Identifier resolution is the process of determining the binding of an Identifier using the LexicalEnvironment of the running execution context. During execution of ECMAScript code@comma{} the syntactic production PrimaryExpression : Identifier is evaluated using the following algorithm:

@enumerate
@item
Let env be the running execution context’s LexicalEnvironment.
@item
If the syntactic production that is being evaluated is contained in a @uref{#sec-10.1.1,strict mode code}@comma{} then let strict be true@comma{} else let strict be false.
@item
Return the result of calling @uref{#sec-10.2.2.1,GetIdentifierReference} function passing env@comma{} Identifier@comma{} and strict as arguments.
@end enumerate

The result of evaluating an identifier is always a value of type @uref{#sec-8.7,Reference} with its referenced name component equal to the Identifier String.


@node 104 Establishing an Execution Context
@chapter @uref{#sec-10.4,10.4} Establishing an Execution Context
Evaluation of @uref{#def-global-code,global code} or code using the eval function (@uref{#sec-15.1.2.1,15.1.2.1}) establishes and enters a new execution context. Every invocation of an ECMAScript code function (@uref{#sec-13.2.1,13.2.1}) also establishes and enters a new execution context@comma{} even if a function is calling itself recursively. Every return exits an execution context. A thrown exception may also exit one or more execution contexts.

When control enters an execution context@comma{} the execution context’s ThisBinding is set@comma{} its VariableEnvironment and initial LexicalEnvironment are defined@comma{} and declaration binding instantiation (@uref{#sec-10.5,10.5}) is performed. The exact manner in which these actions occur depend on the type of code being entered.



@node 1041 Entering Global Code
@chapter @uref{#sec-10.4.1,10.4.1} Entering Global Code
The following steps are performed when control enters the execution context for @uref{#def-global-code,global code}:

@enumerate
@item
Initialize the execution context using the global code as described in @uref{#sec-10.4.1.1,10.4.1.1}.
@item
Perform Declaration Binding Instantiation as described in @uref{#sec-10.5,10.5} using the global code.
@end enumerate


@node 10411 Initial Global Execution Context
@chapter @uref{#sec-10.4.1.1,10.4.1.1} Initial Global Execution Context
The following steps are performed to initialize a global execution context for ECMAScript code C:

@enumerate
@item
Set the VariableEnvironment to the @uref{#sec-10.2.3,Global Environment}.
@item
Set the LexicalEnvironment to the @uref{#sec-10.2.3,Global Environment}.
@item
Set the ThisBinding to the global object.
@end enumerate


@node 1042 Entering Eval Code
@chapter @uref{#sec-10.4.2,10.4.2} Entering Eval Code
The following steps are performed when control enters the execution context for @uref{#def-eval-code,eval code}:

@enumerate
@item
If there is no calling context or if the eval code is not being evaluated by a @uref{#sec-15.1.2.1.1,direct call (15.1.2.1.1) to the eval function} then@comma{}
@enumerate
@item
Initialize the execution context as if it was a global execution context using the eval code as C as described in @uref{#sec-10.4.1.1,10.4.1.1}.
@end enumerate

@item
Else@comma{}
@enumerate
@item
Set the ThisBinding to the same value as the ThisBinding of the calling execution context.
@item
Set the LexicalEnvironment to the same value as the LexicalEnvironment of the calling execution context.
@item
Set the VariableEnvironment to the same value as the VariableEnvironment of the calling execution context.
@end enumerate

@item
If the eval code is @uref{#sec-10.1.1,strict code}@comma{} then
@enumerate
@item
Let strictVarEnv be the result of calling @uref{#sec-10.2.2.2,NewDeclarativeEnvironment} passing the LexicalEnvironment as the argument.
@item
Set the LexicalEnvironment to strictVarEnv. c. Set the VariableEnvironment to strictVarEnv.
@end enumerate

@item
Perform Declaration Binding Instantiation as described in @uref{#sec-10.5,10.5} using the @uref{#def-eval-code,eval code}.
@end enumerate


@node 10421 Strict Mode Restrictions
@chapter @uref{#sec-10.4.2.1,10.4.2.1} Strict Mode Restrictions
The @uref{#def-eval-code,eval code} cannot @uref{#sec-10.5,instantiate variable or function bindings} in the variable environment of the calling context that invoked the eval if either the code of the calling context or the @uref{#def-eval-code,eval code} is @uref{#sec-10.1.1,strict code}. Instead such bindings are instantiated in a new VariableEnvironment that is only accessible to the @uref{#def-eval-code,eval code}.


@node 1043 Entering Function Code
@chapter @uref{#sec-10.4.3,10.4.3} Entering Function Code
The following steps are performed when control enters the execution context for function code contained in function object F@comma{} a caller provided thisArg@comma{} and a caller provided argumentsList:

@enumerate
@item
If the function code is @uref{#sec-10.1.1,strict code}@comma{} set the ThisBinding to thisArg.
@item
Else if thisArg is null or undefined@comma{} set the ThisBinding to the global object.
@item
Else if @uref{#def-type,Type}(thisArg) is not Object@comma{} set the ThisBinding to @uref{#sec-9.9,ToObject}(thisArg).
@item
Else set the ThisBinding to thisArg.
@item
Let localEnv be the result of calling @uref{#sec-10.2.2.2,NewDeclarativeEnvironment} passing the value of the [[Scope]] internal property of F as the argument.
@item
Set the LexicalEnvironment to localEnv.
@item
Set the VariableEnvironment to localEnv.
@item
Let code be the value of F’s [[Code]] internal property.
@item
Perform Declaration Binding Instantiation using the function code code and argumentList as described in @uref{#sec-10.5,10.5}.
@end enumerate


@node 105 Declaration Binding Instantiation
@chapter @uref{#sec-10.5,10.5} Declaration Binding Instantiation
Every execution context has an associated VariableEnvironment. Variables and functions declared in ECMAScript code evaluated in an execution context are added as bindings in that VariableEnvironment’s @uref{#sec-10.2.1,Environment Record}. For function code@comma{} parameters are also added as bindings to that @uref{#sec-10.2.1,Environment Record}.

Which @uref{#sec-10.2.1,Environment Record} is used to bind a declaration and its kind depends upon the type of ECMAScript code executed by the execution context@comma{} but the remainder of the behaviour is generic. On entering an execution context@comma{} bindings are created in the VariableEnvironment as follows using the caller provided code and@comma{} if it is function code@comma{} argument @uref{#sec-8.8,List} args:

@enumerate
@item
Let env be the environment record component of the running execution context’s VariableEnvironment.
@item
If code is @uref{#def-eval-code,eval code}@comma{} then let configurableBindings be true else let configurableBindings be false.
@item
If code is @uref{#sec-10.1.1,strict mode code}@comma{} then let strict be true else let strict be false.
@item
If code is function code@comma{} then
@enumerate
@item
Let func be the function whose [[Call]] internal method initiated execution of code. Let names be the value of func’s [[FormalParameters]] internal property.
@item
Let argCount be the number of elements in args.
@item
Let n be the number 0.
@item
For each String argName in names@comma{} in list order do
@enumerate
@item
Let n be the current value of n plus 1.
@item
If n is greater than argCount@comma{} let v be undefined otherwise let v be the value of the nth element of args.
@item
Let argAlreadyDeclared be the result of calling env’s HasBinding concrete method passing argName as the argument.
@item
If argAlreadyDeclared is false@comma{} call env’s CreateMutableBinding concrete method passing argName as the argument.
@item
Call env’s SetMutableBinding concrete method passing argName@comma{} v@comma{} and strict as the arguments.
@end enumerate

@end enumerate

@item
For each FunctionDeclaration f in code@comma{} in source text order do
@enumerate
@item
Let fn be the Identifier in FunctionDeclaration f.
@item
Let fo be the result of instantiating FunctionDeclaration f as described in @uref{#sec-13,Clause 13}.
@item
Let funcAlreadyDeclared be the result of calling env’s HasBinding concrete method passing fn as the argument.
@item
If funcAlreadyDeclared is false@comma{} call env’s CreateMutableBinding concrete method passing fn and configurableBindings as the arguments.
@item
Else if env is the environment record component of the global environment then
@enumerate
@item
Let go be the global object.
@item
Let existingProp be the resulting of calling the [[GetProperty]] internal method of go with argument fn.
@item
If existingProp.[[Configurable]] is true@comma{} then
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of go@comma{} passing fn@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: undefined@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: configurableBindings @}@comma{} and true as arguments.
@end enumerate

@item
Else if @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(existingProp) or existingProp does not have attribute values @{[[Writable]]: true@comma{} [[Enumerable]]: true@}@comma{} then
@enumerate
@item
Throw a TypeError exception.
@end enumerate

@end enumerate

@item
Call env’s SetMutableBinding concrete method passing fn@comma{} fo@comma{} and strict as the arguments.
@end enumerate

@item
Let argumentsAlreadyDeclared be the result of calling env’s HasBinding concrete method passing "arguments" as the argument.
@item
If code is function code and argumentsAlreadyDeclared is false@comma{} then
@enumerate
@item
Let argsObj be the result of calling the abstract operation CreateArgumentsObject (@uref{#sec-10.6,10.6}) passing func@comma{} names@comma{} args@comma{} env and strict as arguments.
@item
If strict is true@comma{} then
@enumerate
@item
Call env’s @uref{#sec-10.2.1.1.7,CreateImmutableBinding} concrete method passing the String "arguments" as the argument.
@item
Call env’s @uref{#sec-10.2.1.1.8,InitializeImmutableBinding} concrete method passing "arguments" and argsObj as arguments.
@end enumerate

@item
Else@comma{}
@enumerate
@item
Call env’s CreateMutableBinding concrete method passing the String "arguments" as the argument.
@item
Call env’s SetMutableBinding concrete method passing "arguments"@comma{} argsObj@comma{} and false as arguments.
@end enumerate

@end enumerate

@item
For each VariableDeclaration and VariableDeclarationNoIn d in code@comma{} in source text order do
@enumerate
@item
Let dn be the Identifier in d.
@item
Let varAlreadyDeclared be the result of calling env’s HasBinding concrete method passing dn as the argument.
@item
If varAlreadyDeclared is false@comma{} then
@enumerate
@item
Call env’s CreateMutableBinding concrete method passing dn and configurableBindings as the arguments.
@item
Call env’s SetMutableBinding concrete method passing dn@comma{} undefined@comma{} and strict as the arguments.
@end enumerate

@end enumerate

@end enumerate


@node 106 Arguments Object
@chapter @uref{#sec-10.6,10.6} Arguments Object
When control enters an execution context for function code@comma{} an arguments object is created unless (as specified in @uref{#sec-10.5,10.5}) the identifier @code{arguments} occurs as an Identifier in the function’s FormalParameterList or occurs as the Identifier of a VariableDeclaration or FunctionDeclaration contained in the function code.

The arguments object is created by calling the abstract operation CreateArgumentsObject with arguments func the function object whose code is to be evaluated@comma{} names a @uref{#sec-8.8,List} containing the function’s formal parameter names@comma{} args the actual arguments passed to the [[Call]] internal method@comma{} env the variable environment for the function code@comma{} and strict a Boolean that indicates whether or not the function code is @uref{#sec-10.1.1,strict code}. When CreateArgumentsObject is called the following steps are performed:

@enumerate
@item
Let len be the number of elements in args.
@item
Let obj be the result of creating a new ECMAScript object.
@item
Set all the internal methods of obj as specified in @uref{#sec-8.12,8.12}.
@item
Set the [[Class]] internal property of obj to "Arguments".
@item
Let Object be the standard built-in Object constructor (@uref{#sec-15.2.2,15.2.2}).
@item
Set the [[Prototype]] internal property of obj to the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).
@item
Call the [[DefineOwnProperty]] internal method on obj passing "length"@comma{} the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: len@comma{} [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: true@}@comma{} and false as arguments.
@item
Let map be the result of creating a new object as if by the expression @code{new Object()} where @code{Object} is the standard built-in constructor with that name
@item
Let mappedNames be an empty @uref{#sec-8.8,List}.
@item
Let indx = len − 1.
@item
Repeat while indx >= 0@comma{}
@enumerate
@item
Let val be the element of args at 0-origined list position indx.
@item
Call the [[DefineOwnProperty]] internal method on obj passing @uref{#sec-9.8,ToString}(indx)@comma{} the property descriptor @{[[Value]]: val@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false as arguments.
@item
If indx is less than the number of elements in names@comma{} then
@enumerate
@item
Let name be the element of names at 0-origined list position indx.
@item
If strict is false and name is not an element of mappedNames@comma{} then
@enumerate
@item
Add name as an element of the list mappedNames.
@item
Let g be the result of calling the MakeArgGetter abstract operation with arguments name and env.
@item
Let p be the result of calling the MakeArgSetter abstract operation with arguments name and env.
@item
Call the [[DefineOwnProperty]] internal method of map passing @uref{#sec-9.8,ToString}(indx)@comma{} the @uref{#sec-8.10,Property Descriptor} @{[[Set]]: p@comma{} [[Get]]: g@comma{} [[Configurable]]: true@}@comma{} and false as arguments.
@end enumerate

@end enumerate

@item
Let indx = indx − 1
@end enumerate

@item
If mappedNames is not empty@comma{} then
@enumerate
@item
Set the [[ParameterMap]] internal property of obj to map.
@item
Set the [[Get]]@comma{} [[GetOwnProperty]]@comma{} [[DefineOwnProperty]]@comma{} and [[Delete]] internal methods of obj to the definitions provided below.
@end enumerate

@item
If strict is false@comma{} then
@enumerate
@item
Call the [[DefineOwnProperty]] internal method on obj passing "callee"@comma{} the property descriptor @{[[Value]]: func@comma{} [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: true@}@comma{} and false as arguments.
@end enumerate

@item
Else@comma{} strict is true so
@enumerate
@item
Let thrower be the [[ThrowTypeError]] function Object (@uref{#sec-13.2.3,13.2.3}).
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "caller"@comma{} PropertyDescriptor @{[[Get]]: thrower@comma{} [[Set]]: thrower@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments "callee"@comma{} PropertyDescriptor @{[[Get]]: thrower@comma{} [[Set]]: thrower@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@end enumerate

@item
Return obj
@end enumerate

The abstract operation MakeArgGetter called with String name and environment record env creates a function object that when executed returns the value bound for name in env. It performs the following steps:

@enumerate
@item
Let body be the result of concatenating the Strings "return "@comma{} name@comma{} and ";"
@item
Return the result of creating a function object as described in @uref{#sec-13.2,13.2} using no FormalParameterList@comma{} body for FunctionBody@comma{} env as Scope@comma{} and true for Strict.
@end enumerate

The abstract operation MakeArgSetter called with String name and environment record env creates a function object that when executed sets the value bound for name in env. It performs the following steps:

@enumerate
@item
Let param be the String name concatenated with the String "_arg".
@item
Let body be the String "<name> = <param>;" with <name> replaced by the value of name and <param> replaced by the value of param.
@item
Return the result of creating a function object as described in @uref{#sec-13.2,13.2} using a @uref{#sec-8.8,List} containing the single String param as FormalParameterList@comma{} body for FunctionBody@comma{} env as Scope@comma{} and true for Strict.
@end enumerate

The [[Get]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P performs the following steps:

@enumerate
@item
Let map be the value of the [[ParameterMap]] internal property of the arguments object.
@item
Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the argument.
@item
If the value of isMapped is undefined@comma{} then
@enumerate
@item
Let v be the result of calling the default [[Get]] internal method (@uref{#sec-8.12.3,8.12.3}) on the arguments object passing P as the argument.
@item
If P is "caller" and v is a strict mode Function object@comma{} throw a TypeError exception. c. Return v.
@end enumerate

@item
Else@comma{} map contains a formal parameter mapping for P so@comma{}
@enumerate
@item
Return the result of calling the [[Get]] internal method of map passing P as the argument.
@end enumerate

@end enumerate

The [[GetOwnProperty]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P performs the following steps:

@enumerate
@item
Let desc be the result of calling the default [[GetOwnProperty]] internal method (@uref{#sec-8.12.1,8.12.1}) on the arguments object passing P as the argument.
@item
If desc is undefined then return desc.
@item
Let map be the value of the [[ParameterMap]] internal property of the arguments object.
@item
Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the argument.
@item
If the value of isMapped is not undefined@comma{} then
@enumerate
@item
Set desc.[[Value]] to the result of calling the [[Get]] internal method of map passing P as the argument.
@end enumerate

@item
Return desc.
@end enumerate

The [[DefineOwnProperty]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P@comma{} @uref{#sec-8.10,Property Descriptor} Desc@comma{} and Boolean flag Throw performs the following steps:

@enumerate
@item
Let map be the value of the [[ParameterMap]] internal property of the arguments object.
@item
Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the argument.
@item
Let allowed be the result of calling the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on the arguments object passing P@comma{} Desc@comma{} and false as the arguments.
@item
If allowed is false@comma{} then
@enumerate
@item
If Throw is true then throw a TypeError exception@comma{} otherwise return false.
@end enumerate

@item
If the value of isMapped is not undefined@comma{} then
@enumerate
@item

@enumerate
@item
Call the [[Delete]] internal method of map passing P@comma{} and false as the arguments.
@end enumerate

@item
Else
@enumerate
@item
If Desc.[[Value]] is present@comma{} then
@enumerate
@item
Call the [[Put]] internal method of map passing P@comma{} Desc.[[Value]]@comma{} and Throw as the arguments.
@end enumerate

@item
If Desc.[[Writable]] is present and its value is false@comma{} then
@enumerate
@item
Call the [[Delete]] internal method of map passing P and false as arguments.
@end enumerate

@end enumerate

@end enumerate

@item
Return true.
@end enumerate

The [[Delete]] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P and Boolean flag Throw performs the following steps:

@enumerate
@item
Let map be the value of the [[ParameterMap]] internal property of the arguments object.
@item
Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the argument.
@item
Let result be the result of calling the default [[Delete]] internal method (@uref{#sec-8.12.7,8.12.7}) on the arguments object passing P and Throw as the arguments.
@item
If result is true and the value of isMapped is not undefined@comma{} then
@enumerate
@item
Call the [[Delete]] internal method of map passing P@comma{} and false as the arguments.
@end enumerate

@item
Return result.
@end enumerate

NOTE 1 For non-strict mode functions the array index (defined in @uref{#sec-15.4,15.4}) named data properties of an arguments object whose numeric name values are less than the number of formal parameters of the corresponding function object initially share their values with the corresponding argument bindings in the function’s execution context. This means that changing the property changes the corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is deleted and then redefined or if the property is changed into an accessor property. For strict mode functions@comma{} the values of the arguments object’s properties are simply a copy of the arguments passed to the function and there is no dynamic linkage between the property values and the formal parameter values.

NOTE 2 The ParameterMap object and its property values are used as a device for specifying the arguments object correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties are not directly accessible from ECMAScript code. An ECMAScript implementation does not need to actually create or use such objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define non-configurable accessor properties named “@code{caller}” and “@code{callee}” which throw a TypeError exception on access. The “@code{callee}” property has a more specific meaning for non-strict mode functions and a “@code{caller}” property has historically been provided as an implementation-defined extension by some ECMAScript implementations. The strict mode definition of these properties exists to ensure that neither of them is defined in any other manner by conforming ECMAScript implementations.


@node 11 Expressions
@chapter @uref{#sec-11,11} Expressions

@node 111 Primary Expressions
@chapter @uref{#sec-11.1,11.1} Primary Expressions
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
PrimaryExpression :
@code{this}
Identifier
Literal
ArrayLiteral
ObjectLiteral
@code{(} Expression @code{)}

@node 1111 The this Keyword
@chapter @uref{#sec-11.1.1,11.1.1} The this Keyword
The @code{this} keyword evaluates to the value of the ThisBinding of the current execution context.



@node 1112 Identifier Reference
@chapter @uref{#sec-11.1.2,11.1.2} Identifier Reference
An Identifier is evaluated by performing Identifier Resolution as specified in @uref{#sec-10.3.1,10.3.1}. The result of evaluating an Identifier is always a value of type @uref{#sec-8.7,Reference}.


@node 1113 Literal Reference
@chapter @uref{#sec-11.1.3,11.1.3} Literal Reference
A Literal is evaluated as described in @uref{#sec-7.8,7.8}.


@node 1114 Array Initialiser
@chapter @uref{#sec-11.1.4,11.1.4} Array Initialiser
An array initialiser is an expression describing the initialisation of an Array object@comma{} written in a form of a literal. It is a list of zero or more expressions@comma{} each of which represents an @uref{#def-array-element,array element}@comma{} enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initialiser is evaluated.

Array elements may be elided at the beginning@comma{} middle or end of the element list. Whenever a comma in the element list is not preceded by an AssignmentExpression (i.e.@comma{} a comma at the beginning or after another comma)@comma{} the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array@comma{} that element does not contribute to the length of the Array.

@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ArrayLiteral :
@code{[} Elision_opt_ @code{]}
@code{[} ElementList @code{]}
@code{[} ElementList @code{@comma{}} Elision_opt_ @code{]}
ElementList :
Elision_opt_ AssignmentExpression
ElementList @code{@comma{}} Elision_opt_ AssignmentExpression
Elision :
@code{@comma{}}
Elision @code{@comma{}}

@node Semantics
@section Semantics
The production ArrayLiteral : @code{[} Elision_opt_ @code{]} is evaluated as follows:

@enumerate
@item
Let array be the result of creating a new object as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let pad be the result of evaluating Elision; if not present@comma{} use the numeric value zero.
@item
Call the [[Put]] internal method of array with arguments "length"@comma{} pad@comma{} and false.
@item
Return array.
@end enumerate

The production ArrayLiteral : @code{[} ElementList @code{]} is evaluated as follows:

@enumerate
@item
Return the result of evaluating ElementList.
@end enumerate

The production ArrayLiteral : @code{[} ElementList @code{@comma{}} Elision_opt_ @code{]} is evaluated as follows:

@enumerate
@item
Let array be the result of evaluating ElementList.
@item
Let pad be the result of evaluating Elision; if not present@comma{} use the numeric value zero.
@item
Let len be the result of calling the [[Get]] internal method of array with argument "length".
@item
Call the [[Put]] internal method of array with arguments "length"@comma{} @uref{#sec-9.6,ToUint32}(pad+len)@comma{} and false.
@item
Return array.
@end enumerate

The production ElementList : Elision_opt_ AssignmentExpression is evaluated as follows:

@enumerate
@item

@item
Let firstIndex be the result of evaluating Elision; if not present@comma{} use the numeric value zero.
@item
Let initResult be the result of evaluating AssignmentExpression.
@item
Let initValue be @uref{#sec-8.7.1,GetValue}(initResult).
@item
Call the [[DefineOwnProperty]] internal method of array with arguments @uref{#sec-9.8,ToString}(firstIndex)@comma{} the @uref{#sec-8.10,Property Descriptor} @{ [[Value]]: initValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return array.
@end enumerate

The production ElementList : ElementList @code{@comma{}} Elision_opt_ AssignmentExpression is evaluated as follows:

@enumerate
@item
Let array be the result of evaluating ElementList.
@item
Let pad be the result of evaluating Elision; if not present@comma{} use the numeric value zero.
@item
Let initResult be the result of evaluating AssignmentExpression.
@item
Let initValue be @uref{#sec-8.7.1,GetValue}(initResult).
@item
Let len be the result of calling the [[Get]] internal method of array with argument "length".
@item
Call the [[DefineOwnProperty]] internal method of array with arguments @uref{#sec-9.8,ToString}(@uref{#sec-9.6,ToUint32}((pad+len)) and the @uref{#sec-8.10,Property Descriptor} @{ [[Value]]: initValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return array.
@end enumerate

The production Elision : @code{@comma{}} is evaluated as follows:

@enumerate
@item
Return the numeric value 1.
@end enumerate

The production Elision : Elision @code{@comma{}} is evaluated as follows:

@enumerate
@item
Let preceding be the result of evaluating Elision.
@item
Return preceding+1.
@end enumerate

NOTE [[DefineOwnProperty]] is used to ensure that own properties are defined for the array even if the standard built-in Array prototype object has been modified in a manner that would preclude the creation of new own properties using [[Put]].


@node 1115 Object Initialiser
@chapter @uref{#sec-11.1.5,11.1.5} Object Initialiser
An object initialiser is an expression describing the initialisation of an Object@comma{} written in a form resembling a literal. It is a list of zero or more pairs of property names and associated values@comma{} enclosed in curly braces. The values need not be literals; they are evaluated each time the object initialiser is evaluated.

@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ObjectLiteral :
@code{@{} @code{@}}
@code{@{} PropertyNameAndValueList @code{@}}
@code{@{} PropertyNameAndValueList @code{@comma{}} @code{@}}
PropertyNameAndValueList :
PropertyAssignment
PropertyNameAndValueList @code{@comma{}} PropertyAssignment
PropertyAssignment :
PropertyName @code{:} AssignmentExpression
@code{get} PropertyName @code{(} @code{)} @code{@{} FunctionBody @code{@}}
@code{set} PropertyName @code{(} PropertySetParameterList @code{)} @code{@{} FunctionBody @code{@}}

PropertyName :
IdentifierName
StringLiteral
NumericLiteral
PropertySetParameterList :
Identifier

@node Semantics
@section Semantics
The production ObjectLiteral : @code{@{} @code{@}} is evaluated as follows:

@enumerate
@item
Return a new object created as if by the expression @code{new Object()} where @code{Object} is the standard built-in constructor with that name.
@end enumerate

The productions ObjectLiteral : @code{@{} PropertyNameAndValueList @code{@}} and ObjectLiteral : @code{@{} PropertyNameAndValueList @code{@comma{}} @code{@}} are evaluated as follows:

@enumerate
@item
Return the result of evaluating PropertyNameAndValueList.
@end enumerate

The production PropertyNameAndValueList : PropertyAssignment is evaluated as follows:

@enumerate
@item
Let obj be the result of creating a new object as if by the expression @code{new Object()} where @code{Object} is the standard built-in constructor with that name.
@item
Let propId be the result of evaluating PropertyAssignment.
@item
Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name@comma{} propId.descriptor@comma{} and false.
@item
Return obj.
@end enumerate

The production PropertyNameAndValueList : PropertyNameAndValueList @code{@comma{}} PropertyAssignment is evaluated as follows:

@enumerate
@item
Let obj be the result of evaluating PropertyNameAndValueList.
@item
Let propId be the result of evaluating PropertyAssignment.
@item
Let previous be the result of calling the [[GetOwnProperty]] internal method of obj with argument propId.name.
@item
If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
@enumerate
@item
This production is contained in @uref{#sec-10.1.1,strict code} and @uref{#def-IsDataDescriptor,IsDataDescriptor}(previous) is true and @uref{#def-IsDataDescriptor,IsDataDescriptor}(propId.descriptor) is true.
@item
@uref{#def-IsDataDescriptor,IsDataDescriptor}(previous) is true and @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(propId.descriptor) is true.
@item
@uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(previous) is true and @uref{#def-IsDataDescriptor,IsDataDescriptor}(propId.descriptor) is true.
@item
@uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(previous) is true and @uref{#def-IsAccessorDescriptor,IsAccessorDescriptor}(propId.descriptor) is true and either both previous and propId.descriptor have [[Get]] fields or both previous and propId.descriptor have [[Set]] fields
@end enumerate

@item
Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name@comma{} propId.descriptor@comma{} and false.
@item
Return obj.
@end enumerate

If the above steps would throw a SyntaxError then an implementation must treat the error as an early error (@uref{#sec-16,Clause 16}).

The production PropertyAssignment : PropertyName @code{:} AssignmentExpression is evaluated as follows:

@enumerate
@item
Let propName be the result of evaluating PropertyName.
@item
Let exprValue be the result of evaluating AssignmentExpression.
@item
Let propValue be @uref{#sec-8.7.1,GetValue}(exprValue).
@item
Let desc be the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: propValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}
@item
Return @uref{#def-property-identifier,Property Identifier} (propName@comma{} desc).
@end enumerate



@enumerate
@item
Let propName be the result of evaluating PropertyName.
@item
Let closure be the result of creating a new Function object as specified in @uref{#sec-13.2,13.2} with an empty parameter list and body specified by FunctionBody. Pass in the LexicalEnvironment of the running execution context as the Scope. Pass in true as the Strict flag if the PropertyAssignment is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code}.
@item
Let desc be the @uref{#sec-8.10,Property Descriptor} @{[[Get]]: closure@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}
@item
Return @uref{#def-property-identifier,Property Identifier} (propName@comma{} desc).
@end enumerate

The production PropertyAssignment : @code{set} PropertyName @code{(} PropertySetParameterList @code{)} @code{@{} FunctionBody @code{@}} is evaluated as follows:

@enumerate
@item
Let propName be the result of evaluating PropertyName.
@item
Let closure be the result of creating a new Function object as specified in @uref{#sec-13.2,13.2} with parameters specified by PropertySetParameterList and body specified by FunctionBody. Pass in the LexicalEnvironment of the running execution context as the Scope. Pass in true as the Strict flag if the PropertyAssignment is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code}.
@item
Let desc be the @uref{#sec-8.10,Property Descriptor} @{[[Set]]: closure@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}
@item
Return @uref{#def-property-identifier,Property Identifier} (propName@comma{} desc).
@end enumerate

It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code}.

The production PropertyName : IdentifierName is evaluated as follows:

@enumerate
@item
Return the String value containing the same sequence of characters as the IdentifierName.
@end enumerate

The production PropertyName : StringLiteral is evaluated as follows:

@enumerate
@item
Return the SV of the StringLiteral.
@end enumerate

The production PropertyName : NumericLiteral is evaluated as follows:

@enumerate
@item
Let nbr be the result of forming the value of the NumericLiteral.
@item
Return @uref{#sec-9.8,ToString}(nbr).
@end enumerate


@node 1116 The Grouping Operator
@chapter @uref{#sec-11.1.6,11.1.6} The Grouping Operator
The production PrimaryExpression : @code{(} Expression @code{)} is evaluated as follows:

@enumerate
@item
Return the result of evaluating Expression. This may be of type @uref{#sec-8.7,Reference}.
@end enumerate

NOTE This algorithm does not apply @uref{#sec-8.7.1,GetValue} to the result of evaluating Expression. The principal motivation for this is so that operators such as @code{delete} and @code{typeof} may be applied to parenthesised expressions.


@node 112 Left-Hand-Side Expressions
@chapter @uref{#sec-11.2,11.2} Left-Hand-Side Expressions
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
MemberExpression :
PrimaryExpression
FunctionExpression
MemberExpression @code{[} Expression @code{]}
MemberExpression @code{.} IdentifierName
@code{new} MemberExpression Arguments

NewExpression :
MemberExpression
@code{new} NewExpression
CallExpression :
MemberExpression Arguments
CallExpression Arguments
CallExpression @code{[} Expression @code{]}
CallExpression @code{.} IdentifierName
Arguments :
@code{(} @code{)}
@code{(} ArgumentList @code{)}
ArgumentList :
AssignmentExpression
ArgumentList @code{@comma{}} AssignmentExpression
LeftHandSideExpression :
NewExpression
CallExpression

@node 1121 Property Accessors
@chapter @uref{#sec-11.2.1,11.2.1} Property Accessors
Properties are accessed by name@comma{} using either the dot notation:

MemberExpression @code{.} IdentifierName
CallExpression @code{.} IdentifierName
or the bracket notation:

MemberExpression @code{[} Expression @code{]}
CallExpression @code{[} Expression @code{]}
The dot notation is explained by the following syntactic conversion:

MemberExpression @code{.} IdentifierName
is identical in its behaviour to

MemberExpression @code{[} <identifier-name-string> @code{]}
and similarly

CallExpression @code{.} IdentifierName
is identical in its behaviour to

CallExpression @code{[} <identifier-name-string> @code{]}
where <identifier-name-string> is a string literal containing the same sequence of characters after processing of Unicode escape sequences as the IdentifierName.

The production MemberExpression : MemberExpression @code{[} Expression @code{]} is evaluated as follows:

@enumerate
@item
Let baseReference be the result of evaluating MemberExpression.
@item
Let baseValue be @uref{#sec-8.7.1,GetValue}(baseReference).
@item
Let propertyNameReference be the result of evaluating Expression.
@item
Let propertyNameValue be @uref{#sec-8.7.1,GetValue}(propertyNameReference).
@item
Call @uref{#sec-9.10,CheckObjectCoercible}(baseValue).
@item
Let propertyNameString be @uref{#sec-9.8,ToString}(propertyNameValue).
@item
If the syntactic production that is being evaluated is contained in @uref{#sec-10.1.1,strict mode code}@comma{} let strict be true@comma{} else let strict be false.
@item
Return a value of type @uref{#sec-8.7,Reference} whose base value is baseValue and whose referenced name is propertyNameString@comma{} and whose strict mode flag is strict.
@end enumerate

The production CallExpression : CallExpression @code{[} Expression @code{]} is evaluated in exactly the same manner@comma{} except that the contained CallExpression is evaluated in step 1.


@node 1122 The new Operator
@chapter @uref{#sec-11.2.2,11.2.2} The new Operator
The production NewExpression : @code{new} NewExpression is evaluated as follows:

@enumerate
@item
Let ref be the result of evaluating NewExpression.
@item
Let constructor be @uref{#sec-8.7.1,GetValue}(ref).
@item
If @uref{#def-type,Type}(constructor) is not Object@comma{} throw a TypeError exception.
@item
If constructor does not implement the [[Construct]] internal method@comma{} throw a TypeError exception.
@item
Return the result of calling the [[Construct]] internal method on constructor@comma{} providing no arguments (that is@comma{} an empty list of arguments).
@end enumerate

The production MemberExpression : @code{new} MemberExpression Arguments is evaluated as follows:

@enumerate
@item
Let ref be the result of evaluating MemberExpression.
@item
Let constructor be @uref{#sec-8.7.1,GetValue}(ref).
@item
Let argList be the result of evaluating Arguments@comma{} producing an internal list of argument values (@uref{#sec-11.2.4,11.2.4}).
@item
If @uref{#def-type,Type}(constructor) is not Object@comma{} throw a TypeError exception.
@item
If constructor does not implement the [[Construct]] internal method@comma{} throw a TypeError exception.
@item
Return the result of calling the [[Construct]] internal method on constructor@comma{} providing the list argList as the argument values.
@end enumerate


@node 1123 Function Calls
@chapter @uref{#sec-11.2.3,11.2.3} Function Calls
The production CallExpression : MemberExpression Arguments is evaluated as follows:

@enumerate
@item
Let ref be the result of evaluating MemberExpression.
@item
Let func be @uref{#sec-8.7.1,GetValue}(ref).
@item
Let argList be the result of evaluating Arguments@comma{} producing an internal list of argument values (@uref{#sec-11.2.4,see 11.2.4}).
@item
If @uref{#def-type,Type}(func) is not Object@comma{} throw a TypeError exception.
@item
If @uref{#sec-9.11,IsCallable}(func) is false@comma{} throw a TypeError exception.
@item
If @uref{#def-type,Type}(ref) is @uref{#sec-8.7,Reference}@comma{} then
@enumerate
@item
If @uref{#def-IsPropertyReference,IsPropertyReference}(ref) is true@comma{} then
@enumerate
@item
Let thisValue be @uref{#def-GetBase,GetBase}(ref).
@end enumerate

@item
Else@comma{} the base of ref is an @uref{#sec-10.2.1,Environment Record}
@enumerate
@item
Let thisValue be the result of calling the ImplicitThisValue concrete method of @uref{#def-GetBase,GetBase}(ref).
@end enumerate

@end enumerate

@item
Else@comma{} @uref{#def-type,Type}(ref) is not @uref{#sec-8.7,Reference}.
@enumerate
@item
Let thisValue be undefined.
@end enumerate

@item
Return the result of calling the [[Call]] internal method on func@comma{} providing thisValue as the this value and providing the list argList as the argument values.
@end enumerate

The production CallExpression : CallExpression Arguments is evaluated in exactly the same manner@comma{} except that the contained CallExpression is evaluated in step 1.

NOTE The returned result will never be of type @uref{#sec-8.7,Reference} if func is a native ECMAScript object. Whether calling a host object can return a value of type @uref{#sec-8.7,Reference} is implementation-dependent. If a value of type @uref{#sec-8.7,Reference} is returned@comma{} it must be a non-strict @uref{#def-IsPropertyReference,Property Reference}.


@node 1124 Argument Lists
@chapter @uref{#sec-11.2.4,11.2.4} Argument Lists
The evaluation of an argument list produces a @uref{#sec-8.8,List} of values (@uref{#sec-8.8,see 8.8}).

The production Arguments : @code{(} @code{)} is evaluated as follows:

@enumerate
@item

@end enumerate

The production Arguments : @code{(} ArgumentList @code{)} is evaluated as follows:

@enumerate
@item
Return the result of evaluating ArgumentList.
@end enumerate

The production ArgumentList : AssignmentExpression is evaluated as follows:

@enumerate
@item
Let ref be the result of evaluating AssignmentExpression.
@item
Let arg be @uref{#sec-8.7.1,GetValue}(ref).
@item
Return a @uref{#sec-8.8,List} whose sole item is arg.
@end enumerate

The production ArgumentList : ArgumentList @code{@comma{}} AssignmentExpression is evaluated as follows:

@enumerate
@item
Let precedingArgs be the result of evaluating ArgumentList.
@item
Let ref be the result of evaluating AssignmentExpression.
@item
Let arg be @uref{#sec-8.7.1,GetValue}(ref).
@item
Return a @uref{#sec-8.8,List} whose length is one greater than the length of precedingArgs and whose items are the items of precedingArgs@comma{} in order@comma{} followed at the end by arg which is the last item of the new list.
@end enumerate


@node 1125 Function Expressions
@chapter @uref{#sec-11.2.5,11.2.5} Function Expressions
The production MemberExpression : FunctionExpression is evaluated as follows:

@enumerate
@item
Return the result of evaluating FunctionExpression.
@end enumerate


@node 113 Postfix Expressions
@chapter @uref{#sec-11.3,11.3} Postfix Expressions
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
PostfixExpression :
LeftHandSideExpression
LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{++}
LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{--}

@node 1131 Postfix Increment Operator
@chapter @uref{#sec-11.3.1,11.3.1} Postfix Increment Operator
The production PostfixExpression : LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{++} is evaluated as follows:

@enumerate
@item
Let lhs be the result of evaluating LeftHandSideExpression.
@item
Throw a SyntaxError exception if the following conditions are all true:
@itemize
@item
@uref{#def-type,Type}(lhs) is @uref{#sec-8.7,Reference} is true
@item
@uref{#def-IsStrictReference,IsStrictReference}(lhs) is true
@item
@uref{#def-type,Type}(@uref{#def-GetBase,GetBase}(lhs)) is Enviroment Record
@item
@uref{#def-GetReferencedName,GetReferencedName}(lhs) is either "eval" or "arguments"
@end itemize

@item
Let oldValue be @uref{#sec-9.3,ToNumber}(@uref{#sec-8.7.1,GetValue}(lhs)).
@item
Let newValue be the result of adding the value 1 to oldValue@comma{} using the same rules as for the @code{+} operator (@uref{#sec-11.6.3,see 11.6.3}).
@item
Call @uref{#sec-8.7.2,PutValue}(lhs@comma{} newValue).
@item
Return oldValue.
@end enumerate


@node 1132 Postfix Decrement Operator
@chapter @uref{#sec-11.3.2,11.3.2} Postfix Decrement Operator
The production PostfixExpression : LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{--} is evaluated as follows:

@enumerate
@item
Let lhs be the result of evaluating LeftHandSideExpression.
@item
Throw a SyntaxError exception if the following conditions are all true:
@itemize
@item
@uref{#def-type,Type}(lhs) is @uref{#sec-8.7,Reference} is true
@item

@item
@uref{#def-type,Type}(@uref{#def-GetBase,GetBase}(lhs)) is Enviroment Record
@item
@uref{#def-GetReferencedName,GetReferencedName}(lhs) is either "eval" or "arguments"
@end itemize

@item
Let oldValue be @uref{#sec-9.3,ToNumber}(@uref{#sec-8.7.1,GetValue}(lhs)).
@item
Let newValue be the result of subtracting the value 1 from oldValue@comma{} using the same rules as for the @code{-} operator (@uref{#sec-11.6.3,11.6.3}).
@item
Call @uref{#sec-8.7.2,PutValue}(lhs@comma{} newValue).
@item
Return oldValue.
@end enumerate


@node 114 Unary Operators
@chapter @uref{#sec-11.4,11.4} Unary Operators
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
UnaryExpression :
PostfixExpression
@code{delete} UnaryExpression
@code{void} UnaryExpression
@code{typeof} UnaryExpression
@code{++} UnaryExpression
@code{--} UnaryExpression
@code{+} UnaryExpression
@code{-} UnaryExpression
@code{~} UnaryExpression
@code{!} UnaryExpression

@node 1141 The delete Operator
@chapter @uref{#sec-11.4.1,11.4.1} The @code{delete} Operator
The production UnaryExpression : @code{delete} UnaryExpression is evaluated as follows:

@enumerate
@item
Let ref be the result of evaluating UnaryExpression.
@item
If @uref{#def-type,Type}(ref) is not @uref{#sec-8.7,Reference}@comma{} return true.
@item
If @uref{#def-IsUnresolvableReference,IsUnresolvableReference}(ref) then@comma{}
@enumerate
@item
If @uref{#def-IsStrictReference,IsStrictReference}(ref) is true@comma{} throw a SyntaxError exception.
@item
Else@comma{} return true.
@end enumerate

@item
If @uref{#def-IsPropertyReference,IsPropertyReference}(ref) is true@comma{} then
@enumerate
@item
Return the result of calling the [[Delete]] internal method on @uref{#sec-9.9,ToObject}(@uref{#def-GetBase,GetBase}(ref)) providing @uref{#def-GetReferencedName,GetReferencedName}(ref) and @uref{#def-IsStrictReference,IsStrictReference}(ref) as the arguments.
@end enumerate

@item
Else@comma{} ref is a @uref{#sec-8.7,Reference} to an @uref{#sec-10.2.1,Environment Record} binding@comma{} so
@enumerate
@item
If @uref{#def-IsStrictReference,IsStrictReference}(ref) is true@comma{} throw a SyntaxError exception.
@item
Let bindings be @uref{#def-GetBase,GetBase}(ref).
@item
Return the result of calling the DeleteBinding concrete method of bindings@comma{} providing @uref{#def-GetReferencedName,GetReferencedName}(ref) as the argument.
@end enumerate

@end enumerate

NOTE When a @code{delete} operator occurs within @uref{#sec-10.1.1,strict mode code}@comma{} a SyntaxError exception is thrown if its UnaryExpression is a direct reference to a variable@comma{} function argument@comma{} or function name. In addition@comma{} if a @code{delete} operator occurs within @uref{#sec-10.1.1,strict mode code} and the property to be deleted has the attribute @{ [[Configurable]]: false @}@comma{} a TypeError exception is thrown.


@node 1142 The void Operator
@chapter @uref{#sec-11.4.2,11.4.2} The @code{void} Operator
The production UnaryExpression : @code{void} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Call @uref{#sec-8.7.1,GetValue}(expr).
@item
Return undefined.
@end enumerate

NOTE @uref{#sec-8.7.1,GetValue} must be called even though its value is not used because it may have observable side-effects.



@node 1143 The typeof Operator
@chapter @uref{#sec-11.4.3,11.4.3} The @code{typeof} Operator
The production UnaryExpression : @code{typeof} UnaryExpression is evaluated as follows:

@enumerate
@item
Let val be the result of evaluating UnaryExpression.
@item
If @uref{#def-type,Type}(val) is @uref{#sec-8.7,Reference}@comma{} then
@enumerate
@item
If @uref{#def-IsUnresolvableReference,IsUnresolvableReference}(val) is true@comma{} return "undefined".
@item
Let val be @uref{#sec-8.7.1,GetValue}(val).
@end enumerate

@item
Return a String determined by @uref{#def-type,Type}(val) according to Table 20.
@end enumerate

Table 20 — typeof Operator Results
Type of val
Result
Undefined
"undefined"
Null
"object"
Boolean
"boolean"
Number
"number"
String
"string"
Object (native and does not implement [[Call]])
"object"
Object (native or host and does implement [[Call]])
"function"
Object (host and does not implement [[Call]])
Implementation-defined except may not be "undefined"@comma{} "boolean"@comma{} "number"@comma{} or "string".

@node 1144 Prefix Increment Operator
@chapter @uref{#sec-11.4.4,11.4.4} Prefix Increment Operator
The production UnaryExpression : @code{++} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Throw a SyntaxError exception if the following conditions are all true:
@itemize
@item
@uref{#def-type,Type}(expr) is @uref{#sec-8.7,Reference} is true
@item
@uref{#def-IsStrictReference,IsStrictReference}(expr) is true
@item
@uref{#def-type,Type}(@uref{#def-GetBase,GetBase}(expr)) is Enviroment Record
@item
@uref{#def-GetReferencedName,GetReferencedName}(expr) is either "eval" or "arguments"
@end itemize

@item
Let oldValue be @uref{#sec-9.3,ToNumber}(@uref{#sec-8.7.1,GetValue}(expr)).
@item
Let newValue be the result of adding the value 1 to oldValue@comma{} using the same rules as for the @code{+} operator (@uref{#sec-11.6.3,see 11.6.3}).
@item
Call @uref{#sec-8.7.2,PutValue}(expr@comma{} newValue).
@item
Return newValue.
@end enumerate


@node 1145 Prefix Decrement Operator
@chapter @uref{#sec-11.4.5,11.4.5} Prefix Decrement Operator
The production UnaryExpression : @code{--} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Throw a SyntaxError exception if the following conditions are all true:
@itemize
@item
@uref{#def-type,Type}(expr) is @uref{#sec-8.7,Reference} is true
@item
@uref{#def-IsStrictReference,IsStrictReference}(expr) is true
@item
@uref{#def-type,Type}(@uref{#def-GetBase,GetBase}(expr)) is Enviroment Record
@item
@uref{#def-GetReferencedName,GetReferencedName}(expr) is either "eval" or "arguments"
@end itemize

@item
Let oldValue be @uref{#sec-9.3,ToNumber}(@uref{#sec-8.7.1,GetValue}(expr)).
@item
Let newValue be the result of subtracting the value 1 from oldValue@comma{} using the same rules as for the @code{-} operator (@uref{#sec-11.6.3,see 11.6.3}).
@item
Call @uref{#sec-8.7.2,PutValue}(expr@comma{} newValue).
@item
Return newValue.
@end enumerate


@node 1146 Unary + Operator
@chapter @uref{#sec-11.4.6,11.4.6} Unary @code{+} Operator
The unary + operator converts its operand to Number type.

The production UnaryExpression : @code{+} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Return @uref{#sec-9.3,ToNumber}(@uref{#sec-8.7.1,GetValue}(expr)).
@end enumerate


@node 1147 Unary - Operator
@chapter @uref{#sec-11.4.7,11.4.7} Unary @code{-} Operator
The unary @code{-} operator converts its operand to Number type and then negates it. Note that negating +0 produces −0@comma{} and negating −0 produces +0.

The production UnaryExpression : @code{-} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Let oldValue be @uref{#sec-9.3,ToNumber}(@uref{#sec-8.7.1,GetValue}(expr)).
@item
If oldValue is NaN@comma{} return NaN.
@item
Return the result of negating oldValue; that is@comma{} compute a Number with the same magnitude but opposite sign.
@end enumerate


@node 1148 Bitwise NOT Operator  ~
@chapter @uref{#sec-11.4.8,11.4.8} Bitwise NOT Operator ( @code{~} )
The production UnaryExpression : @code{~} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Let oldValue be @uref{#sec-9.5,ToInt32}(@uref{#sec-8.7.1,GetValue}(expr)).
@item
Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
@end enumerate


@node 1149 Logical NOT Operator  !
@chapter @uref{#sec-11.4.9,11.4.9} Logical NOT Operator ( @code{!} )
The production UnaryExpression : @code{!} UnaryExpression is evaluated as follows:

@enumerate
@item
Let expr be the result of evaluating UnaryExpression.
@item
Let oldValue be @uref{#sec-9.2,ToBoolean}(@uref{#sec-8.7.1,GetValue}(expr)).
@item
If oldValue is true@comma{} return false.
@item
Return true.
@end enumerate


@node 115 Multiplicative Operators
@chapter @uref{#sec-11.5,11.5} Multiplicative Operators
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
MultiplicativeExpression :
UnaryExpression
MultiplicativeExpression @code{*} UnaryExpression
MultiplicativeExpression @code{/} UnaryExpression
MultiplicativeExpression @code{%} UnaryExpression

@node Semantics
@section Semantics
The production MultiplicativeExpression : MultiplicativeExpression @@ UnaryExpression@comma{} where @@ stands for one of the operators in the above definitions@comma{} is evaluated as follows:

@enumerate
@item

@item
Let leftValue be @uref{#sec-8.7.1,GetValue}(left).
@item
Let right be the result of evaluating UnaryExpression.
@item
Let rightValue be @uref{#sec-8.7.1,GetValue}(right).
@item
Let leftNum be @uref{#sec-9.3,ToNumber}(leftValue).
@item
Let rightNum be @uref{#sec-9.3,ToNumber}(rightValue).
@item
Return the result of applying the specified operation (*@comma{} /@comma{} or %) to leftNum and rightNum. See the Notes below @uref{#sec-11.5.1,11.5.1}@comma{} @uref{#sec-11.5.2,11.5.2}@comma{} @uref{#sec-11.5.3,11.5.3}.
@end enumerate


@node 1151 Applying the * Operator
@chapter @uref{#sec-11.5.1,11.5.1} Applying the @code{*} Operator
The @code{*} operator performs multiplication@comma{} producing the product of its operands. Multiplication is commutative. Multiplication is not always associative in ECMAScript@comma{} because of finite precision.

The result of a floating-point multiplication is governed by the rules of IEEE 754 binary double-precision arithmetic:

@itemize
@item
If either operand is NaN@comma{} the result is NaN.
@item
The sign of the result is positive if both operands have the same sign@comma{} negative if the operands have different signs.
@item
Multiplication of an infinity by a zero results in NaN.
@item
Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.
@item
Multiplication of an infinity by a finite non-zero value results in a signed infinity. The sign is determined by the rule already stated above.
@item
In the remaining cases@comma{} where neither an infinity or NaN is involved@comma{} the product is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent@comma{} the result is then an infinity of appropriate sign. If the magnitude is too small to represent@comma{} the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.
@end itemize


@node 1152 Applying the / Operator
@chapter @uref{#sec-11.5.2,11.5.2} Applying the @code{/} Operator
The @code{/} operator performs division@comma{} producing the quotient of its operands. The left operand is the dividend and the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all division operations are double-precision floating-point numbers. The result of division is determined by the specification of IEEE 754 arithmetic:

@itemize
@item
If either operand is NaN@comma{} the result is NaN.
@item
The sign of the result is positive if both operands have the same sign@comma{} negative if the operands have different signs.
@item
Division of an infinity by an infinity results in NaN.
@item
Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.
@item
Division of an infinity by a non-zero finite value results in a signed infinity. The sign is determined by the rule already stated above.
@item
Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.
@item
Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero@comma{} with the sign determined by the rule already stated above.
@item
Division of a non-zero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.
@item
In the remaining cases@comma{} where neither an infinity@comma{} nor a zero@comma{} nor NaN is involved@comma{} the quotient is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent@comma{} the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent@comma{} the
@end itemize


@node 1153 Applying the % Operator
@chapter @uref{#sec-11.5.3,11.5.3} Applying the @code{%} Operator
The @code{%} operator yields the remainder of its operands from an implied division; the left operand is the dividend and the right operand is the divisor.

NOTE In C and C++@comma{} the remainder operator accepts only integral operands; in ECMAScript@comma{} it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the @code{%} operator is not the same as the “remainder” operation defined by IEEE 754. The IEEE 754 “remainder” operation computes the remainder from a rounding division@comma{} not a truncating division@comma{} and so its behaviour is not analogous to that of the usual integer remainder operator. Instead the ECMAScript language defines @code{%} on floating-point operations to behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:

@itemize
@item
If either operand is NaN@comma{} the result is NaN.
@item
The sign of the result equals the sign of the dividend.
@item
If the dividend is an infinity@comma{} or the divisor is a zero@comma{} or both@comma{} the result is NaN.
@item
If the dividend is finite and the divisor is an infinity@comma{} the result equals the dividend.
@item
If the dividend is a zero and the divisor is finite@comma{} the result is the same as the dividend.
@item
In the remaining cases@comma{} where neither an infinity@comma{} nor a zero@comma{} nor NaN is involved@comma{} the floating-point remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n − (d × q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive@comma{} and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d.
@end itemize


@node 116 Additive Operators
@chapter @uref{#sec-11.6,11.6} Additive Operators
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
AdditiveExpression :
MultiplicativeExpression
AdditiveExpression @code{+} MultiplicativeExpression
AdditiveExpression @code{-} MultiplicativeExpression

@node 1161 The Addition operator  +
@chapter @uref{#sec-11.6.1,11.6.1} The Addition operator ( @code{+} )
The addition operator either performs string concatenation or numeric addition.

The production AdditiveExpression : AdditiveExpression @code{+} MultiplicativeExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating AdditiveExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating MultiplicativeExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let lprim be @uref{#sec-9.1,ToPrimitive}(lval).
@item
Let rprim be @uref{#sec-9.1,ToPrimitive}(rval).
@item
If @uref{#def-type,Type}(lprim) is String or @uref{#def-type,Type}(rprim) is String@comma{} then
@enumerate
@item
Return the String that is the result of concatenating @uref{#sec-9.8,ToString}(lprim) followed by @uref{#sec-9.8,ToString}(rprim)
@end enumerate

@item
Return the result of applying the addition operation to @uref{#sec-9.3,ToNumber}(lprim) and @uref{#sec-9.3,ToNumber}(rprim). See the Note below @uref{#sec-11.6.3,11.6.3}.
@end enumerate

NOTE 1 No hint is provided in the calls to @uref{#sec-9.1,ToPrimitive} in steps 5 and 6. All native ECMAScript objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner.




@node 1162 The Subtraction Operator  -
@chapter @uref{#sec-11.6.2,11.6.2} The Subtraction Operator ( @code{-} )
The production AdditiveExpression : AdditiveExpression @code{-} MultiplicativeExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating AdditiveExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating MultiplicativeExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let lnum be @uref{#sec-9.3,ToNumber}(lval).
@item
Let rnum be @uref{#sec-9.3,ToNumber}(rval).
@item
Return the result of applying the subtraction operation to lnum and rnum. See the note below @uref{#sec-11.6.3,11.6.3}.
@end enumerate


@node 1163 Applying the Additive Operators to Numbers
@chapter @uref{#sec-11.6.3,11.6.3} Applying the Additive Operators to Numbers
The @code{+} operator performs addition when applied to two operands of numeric type@comma{} producing the sum of the operands. The @code{-} operator performs subtraction@comma{} producing the difference of two numeric operands.

Addition is a commutative operation@comma{} but not always associative.

The result of an addition is determined using the rules of IEEE 754 binary double-precision arithmetic:

@itemize
@item
If either operand is NaN@comma{} the result is NaN.
@item
The sum of two infinities of opposite sign is NaN.
@item
The sum of two infinities of the same sign is the infinity of that sign.
@item
The sum of an infinity and a finite value is equal to the infinite operand.
@item
The sum of two negative zeros is −0. The sum of two positive zeros@comma{} or of two zeros of opposite sign@comma{} is +0.
@item
The sum of a zero and a nonzero finite value is equal to the nonzero operand.
@item
The sum of two nonzero finite values of the same magnitude and opposite sign is +0.
@item
In the remaining cases@comma{} where neither an infinity@comma{} nor a zero@comma{} nor NaN is involved@comma{} and the operands have the same sign or have different magnitudes@comma{} the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent@comma{} the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.
@end itemize

The @code{-} operator performs subtraction when applied to two operands of numeric type@comma{} producing the difference of its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operands a and b@comma{} it is always the case that @code{<var>a</var>-<var>b</var>} produces the same result as @code{<var>a</var> +(-<var>b</var>)}.


@node 117 Bitwise Shift Operators
@chapter @uref{#sec-11.7,11.7} Bitwise Shift Operators
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
ShiftExpression :
AdditiveExpression
ShiftExpression @code{<<} AdditiveExpression
ShiftExpression @code{>>} AdditiveExpression
ShiftExpression @code{>>>} AdditiveExpression

@node 1171 The Left Shift Operator  <<
@chapter @uref{#sec-11.7.1,11.7.1} The Left Shift Operator ( @code{<<} )
Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.



@enumerate
@item
Let lref be the result of evaluating ShiftExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating AdditiveExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let lnum be @uref{#sec-9.5,ToInt32}(lval).
@item
Let rnum be @uref{#sec-9.6,ToUint32}(rval).
@item
Let shiftCount be the result of masking out all but the least significant 5 bits of rnum@comma{} that is@comma{} compute rnum & 0x1F.
@item
Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.
@end enumerate


@node 1172 The Signed Right Shift Operator  >>
@chapter @uref{#sec-11.7.2,11.7.2} The Signed Right Shift Operator ( @code{>>} )
Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.

The production ShiftExpression : ShiftExpression @code{>>} AdditiveExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating ShiftExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating AdditiveExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let lnum be @uref{#sec-9.5,ToInt32}(lval).
@item
Let rnum be @uref{#sec-9.6,ToUint32}(rval).
@item
Let shiftCount be the result of masking out all but the least significant 5 bits of rnum@comma{} that is@comma{} compute rnum & 0x1F.
@item
Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.
@end enumerate


@node 1173 The Unsigned Right Shift Operator  >>>
@chapter @uref{#sec-11.7.3,11.7.3} The Unsigned Right Shift Operator ( @code{>>>} )
Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.

The production ShiftExpression : ShiftExpression @code{>>>} AdditiveExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating ShiftExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating AdditiveExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let lnum be @uref{#sec-9.6,ToUint32}(lval).
@item
Let rnum be @uref{#sec-9.6,ToUint32}(rval).
@item
Let shiftCount be the result of masking out all but the least significant 5 bits of rnum@comma{} that is@comma{} compute rnum & 0x1F.
@item
Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.
@end enumerate


@node 118 Relational Operators
@chapter @uref{#sec-11.8,11.8} Relational Operators
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
RelationalExpression :
ShiftExpression
RelationalExpression @code{<} ShiftExpression
RelationalExpression @code{>} ShiftExpression
RelationalExpression @code{<=} ShiftExpression
RelationalExpression @code{>=} ShiftExpression
RelationalExpression @code{instanceof} ShiftExpression
RelationalExpression @code{in} ShiftExpression
RelationalExpressionNoIn :
ShiftExpression
RelationalExpressionNoIn @code{<} ShiftExpression
RelationalExpressionNoIn @code{>} ShiftExpression
RelationalExpressionNoIn @code{<=} ShiftExpression
RelationalExpressionNoIn @code{>=} ShiftExpression
RelationalExpressionNoIn @code{instanceof} ShiftExpression
NOTE The “NoIn” variants are needed to avoid confusing the @code{in} operator in a relational expression with the @code{in} operator in a @code{for} statement.


@node Semantics
@section Semantics
The result of evaluating a relational operator is always of type Boolean@comma{} reflecting whether the relationship named by the operator holds between its two operands.

The RelationalExpressionNoIn productions are evaluated in the same manner as the RelationalExpression productions except that the contained RelationalExpressionNoIn is evaluated instead of the contained RelationalExpression.


@node 1181 The Less-than Operator  <
@chapter @uref{#sec-11.8.1,11.8.1} The Less-than Operator ( @code{<} )
The production RelationalExpression : RelationalExpression @code{<} ShiftExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating RelationalExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating ShiftExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of performing abstract relational comparison lval < rval. (@uref{#sec-11.8.5,see 11.8.5})
@item
If r is undefined@comma{} return false. Otherwise@comma{} return r.
@end enumerate


@node 1182 The Greater-than Operator  >
@chapter @uref{#sec-11.8.2,11.8.2} The Greater-than Operator ( @code{>} )
The production RelationalExpression : RelationalExpression @code{>} ShiftExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating RelationalExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating ShiftExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (@uref{#sec-11.8.5,see 11.8.5}).
@item
If r is undefined@comma{} return false. Otherwise@comma{} return r.
@end enumerate


@node 1183 The Less-than-or-equal Operator  <=
@chapter @uref{#sec-11.8.3,11.8.3} The Less-than-or-equal Operator ( @code{<=} )
The production RelationalExpression : RelationalExpression @code{<=} ShiftExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating RelationalExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating ShiftExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (@uref{#sec-11.8.5,see 11.8.5}).
@item
If r is true or undefined@comma{} return false. Otherwise@comma{} return true.
@end enumerate


@node 1184 The Greater-than-or-equal Operator  >=
@chapter @uref{#sec-11.8.4,11.8.4} The Greater-than-or-equal Operator ( @code{>=} )
The production RelationalExpression : RelationalExpression @code{>=} ShiftExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating RelationalExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating ShiftExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of performing abstract relational comparison lval < rval. (@uref{#sec-11.8.5,see 11.8.5})
@item
If r is true or undefined@comma{} return false. Otherwise@comma{} return true.
@end enumerate


@node 1185 The Abstract Relational Comparison Algorithm
@chapter @uref{#sec-11.8.5,11.8.5} The Abstract Relational Comparison Algorithm
The comparison x < y@comma{} where x and y are values@comma{} produces true@comma{} false@comma{} or undefined (which indicates that at least one operand is NaN). In addition to x and y the algorithm takes a Boolean flag named LeftFirst as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon x and y. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of LeftFirst is true and indicates that the x parameter corresponds to an expression that occurs to the left of the y parameter’s corresponding expression. If LeftFirst is false@comma{} the reverse is the case and operations must be performed upon y before x. Such a comparison is performed as follows:

@enumerate
@item
If the LeftFirst flag is true@comma{} then
@enumerate
@item
Let px be the result of calling @uref{#sec-9.1,ToPrimitive}(x@comma{} hint Number).
@item
Let py be the result of calling @uref{#sec-9.1,ToPrimitive}(y@comma{} hint Number).
@end enumerate

@item
Else the order of evaluation needs to be reversed to preserve left to right evaluation
@enumerate
@item
Let py be the result of calling @uref{#sec-9.1,ToPrimitive}(y@comma{} hint Number).
@item
Let px be the result of calling @uref{#sec-9.1,ToPrimitive}(x@comma{} hint Number).
@end enumerate

@item
If it is not the case that both @uref{#def-type,Type}(px) is String and @uref{#def-type,Type}(py) is String@comma{} then
@enumerate
@item
Let nx be the result of calling @uref{#sec-9.3,ToNumber}(px). Because px and py are primitive values evaluation order is not important.
@item
Let ny be the result of calling @uref{#sec-9.3,ToNumber}(py).
@item
If nx is NaN@comma{} return undefined.
@item
If ny is NaN@comma{} return undefined.
@item
If nx and ny are the same Number value@comma{} return false.
@item
If nx is +0 and ny is −0@comma{} return false.
@item
If nx is −0 and ny is +0@comma{} return false.
@item
If nx is +∞@comma{} return false.
@item
If ny is +∞@comma{} return true.
@item
If ny is −∞@comma{} return false.
@item
If nx is −∞@comma{} return true.
@item
If the mathematical value of nx is less than the mathematical value of ny —note that these mathematical values are both finite and not both zero—return true. Otherwise@comma{} return false.
@end enumerate

@item
Else@comma{} both px and py are Strings
@enumerate
@item
If py is a prefix of px@comma{} return false. (A String value p is a prefix of String value q if q can be the result of concatenating p and some other String r. Note that any String is a prefix of itself@comma{} because r may be the empty String.)
@item

@item
Let k be the smallest nonnegative integer such that the character at position k within px is different from the character at position k within py. (There must be such a k@comma{} for neither String is a prefix of the other.)
@item
Let m be the integer that is the code unit value for the character at position k within px.
@item
Let n be the integer that is the code unit value for the character at position k within py.
@item
If m < n@comma{} return true. Otherwise@comma{} return false.
@end enumerate

@end enumerate

NOTE 1 Step 3 differs from step 7 in the algorithm for the addition operator @code{+} (@uref{#sec-11.6.1,11.6.1}) in using and instead of or.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex@comma{} semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form. Also@comma{} note that for strings containing supplementary characters@comma{} lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.


@node 1186 The instanceof operator
@chapter @uref{#sec-11.8.6,11.8.6} The @code{instanceof} operator
The production RelationalExpression: RelationalExpression @code{instanceof} ShiftExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating RelationalExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating ShiftExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
If @uref{#def-type,Type}(rval) is not Object@comma{} throw a TypeError exception.
@item
If rval does not have a [[HasInstance]] internal method@comma{} throw a TypeError exception.
@item
Return the result of calling the [[HasInstance]] internal method of rval with argument lval.
@end enumerate


@node 1187 The in operator
@chapter @uref{#sec-11.8.7,11.8.7} The @code{in} operator
The production RelationalExpression : RelationalExpression @code{in} ShiftExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating RelationalExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating ShiftExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
If @uref{#def-type,Type}(rval) is not Object@comma{} throw a TypeError exception.
@item
Return the result of calling the [[HasProperty]] internal method of rval with argument @uref{#sec-9.8,ToString}(lval).
@end enumerate


@node 119 Equality Operators
@chapter @uref{#sec-11.9,11.9} Equality Operators
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
EqualityExpression :
RelationalExpression
EqualityExpression @code{==} RelationalExpression
EqualityExpression @code{!=} RelationalExpression
EqualityExpression @code{===} RelationalExpression
EqualityExpression @code{!==} RelationalExpression
EqualityExpressionNoIn :
RelationalExpressionNoIn
EqualityExpressionNoIn @code{==} RelationalExpressionNoIn
EqualityExpressionNoIn @code{!=} RelationalExpressionNoIn
EqualityExpressionNoIn @code{===} RelationalExpressionNoIn
EqualityExpressionNoIn @code{!==} RelationalExpressionNoIn


@node Semantics
@section Semantics
The result of evaluating an equality operator is always of type Boolean@comma{} reflecting whether the relationship named by the operator holds between its two operands.

The EqualityExpressionNoIn productions are evaluated in the same manner as the EqualityExpression productions except that the contained EqualityExpressionNoIn and RelationalExpressionNoIn are evaluated instead of the contained EqualityExpression and RelationalExpression@comma{} respectively.


@node 1191 The Equals Operator  ==
@chapter @uref{#sec-11.9.1,11.9.1} The Equals Operator ( @code{==} )
The production EqualityExpression : EqualityExpression @code{==} RelationalExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating EqualityExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating RelationalExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Return the result of performing abstract equality comparison rval == lval. (@uref{#sec-11.9.3,see 11.9.3}).
@end enumerate


@node 1192 The Does-not-equals Operator  !=
@chapter @uref{#sec-11.9.2,11.9.2} The Does-not-equals Operator ( @code{!=} )
The production EqualityExpression : EqualityExpression @code{!=} RelationalExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating EqualityExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating RelationalExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of performing abstract equality comparison rval == lval. (@uref{#sec-11.9.3,see 11.9.3}).
@item
If r is true@comma{} return false. Otherwise@comma{} return true.
@end enumerate


@node 1193 The Abstract Equality Comparison Algorithm
@chapter @uref{#sec-11.9.3,11.9.3} The Abstract Equality Comparison Algorithm
The comparison x == y@comma{} where x and y are values@comma{} produces true or false. Such a comparison is performed as follows:

@enumerate
@item
If @uref{#def-type,Type}(x) is the same as @uref{#def-type,Type}(y)@comma{} then
@enumerate
@item
If @uref{#def-type,Type}(x) is Undefined@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Null@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Number@comma{} then
@enumerate
@item
If x is NaN@comma{} return false.
@item
If y is NaN@comma{} return false.
@item
If x is the same Number value as y@comma{} return true.
@item
If x is +0 and y is −0@comma{} return true.
@item
If x is −0 and y is +0@comma{} return true.
@item
Return false.
@end enumerate

@item
If @uref{#def-type,Type}(x) is String@comma{} then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise@comma{} return false.
@item
If @uref{#def-type,Type}(x) is Boolean@comma{} return true if x and y are both true or both false. Otherwise@comma{} return false.
@item
Return true if x and y refer to the same object. Otherwise@comma{} return false.
@end enumerate

@item
If x is null and y is undefined@comma{} return true.
@item
If x is undefined and y is null@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Number and @uref{#def-type,Type}(y) is String@comma{} return the result of the comparison x == @uref{#sec-9.3,ToNumber}(y).
@item
If @uref{#def-type,Type}(x) is String and @uref{#def-type,Type}(y) is Number@comma{} return the result of the comparison @uref{#sec-9.3,ToNumber}(x) == y.
@item
If @uref{#def-type,Type}(x) is Boolean@comma{} return the result of the comparison @uref{#sec-9.3,ToNumber}(x) == y.
@item
If @uref{#def-type,Type}(y) is Boolean@comma{} return the result of the comparison x == @uref{#sec-9.3,ToNumber}(y).
@item
If @uref{#def-type,Type}(x) is either String or Number and @uref{#def-type,Type}(y) is Object@comma{} return the result of the comparison x == @uref{#sec-9.1,ToPrimitive}(y).
@item
If @uref{#def-type,Type}(x) is Object and @uref{#def-type,Type}(y) is either String or Number@comma{} return the result of the comparison @uref{#sec-9.1,ToPrimitive}(x) == y.
@item
Return false.
@end enumerate

NOTE 1 Given the above definition of equality:

@itemize
@item
String comparison can be forced by: @code{"" + a == "" +         b}.
@item
Numeric comparison can be forced by: @code{+a ==         +b}.
@item
Boolean comparison can be forced by: @code{!a ==         !b}.
@end itemize

NOTE 2 The equality operators maintain the following invariants:

@itemize
@item
@code{<var>A</var> != <var>B</var>} is equivalent to @code{!(<var>A</var> == <var>B</var>)}.
@item
@code{<var>A</var> == <var>B</var>} is equivalent to @code{<var>B</var> == <var>A</var>}@comma{} except in the order of evaluation of A and B.
@end itemize

NOTE 3 The equality operator is not always transitive. For example@comma{} there might be two distinct String objects@comma{} each representing the same String value; each String object would be considered equal to the String value by the @code{==} operator@comma{} but the two String objects would not be equal to each other.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex@comma{} semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.


@node 1194 The Strict Equals Operator  ===
@chapter @uref{#sec-11.9.4,11.9.4} The Strict Equals Operator ( @code{===} )
The production EqualityExpression : EqualityExpression @code{===} RelationalExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating EqualityExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating RelationalExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Return the result of performing the strict equality comparison rval === lval. (@uref{#sec-11.9.6,See 11.9.6})
@end enumerate


@node 1195 The Strict Does-not-equal Operator  !==
@chapter @uref{#sec-11.9.5,11.9.5} The Strict Does-not-equal Operator ( @code{!==} )
The production EqualityExpression : EqualityExpression @code{!==} RelationalExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating EqualityExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating RelationalExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of performing strict equality comparison rval === lval. (@uref{#sec-11.9.6,See 11.9.6})
@item
If r is true@comma{} return false. Otherwise@comma{} return true.
@end enumerate


@node 1196 The Strict Equality Comparison Algorithm
@chapter @uref{#sec-11.9.6,11.9.6} The Strict Equality Comparison Algorithm
The comparison x === y@comma{} where x and y are values@comma{} produces true or false. Such a comparison is performed as follows:

@enumerate
@item
If @uref{#def-type,Type}(x) is different from @uref{#def-type,Type}(y)@comma{} return false.
@item
If @uref{#def-type,Type}(x) is Undefined@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Null@comma{} return true.
@item
If @uref{#def-type,Type}(x) is Number@comma{} then
@enumerate
@item
If x is NaN@comma{} return false.
@item
If y is NaN@comma{} return false.
@item
If x is the same Number value as y@comma{} return true.
@item
If x is +0 and y is −0@comma{} return true.
@item
If x is −0 and y is +0@comma{} return true.
@item
Return false.
@end enumerate

@item
If @uref{#def-type,Type}(x) is String@comma{} then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise@comma{} return false.
@item
If @uref{#def-type,Type}(x) is Boolean@comma{} return true if x and y are both true or both false; otherwise@comma{} return false.
@item
Return true if x and y refer to the same object. Otherwise@comma{} return false.
@end enumerate

NOTE This algorithm differs from @uref{#sec-9.12,the SameValue Algorithm (9.12)} in its treatment of signed zeroes and NaNs.


@node 1110 Binary Bitwise Operators
@chapter @uref{#sec-11.10,11.10} Binary Bitwise Operators
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
BitwiseANDExpression :
EqualityExpression
BitwiseANDExpression @code{&} EqualityExpression
BitwiseANDExpressionNoIn :
EqualityExpressionNoIn
BitwiseANDExpressionNoIn @code{&} EqualityExpressionNoIn
BitwiseXORExpression :
BitwiseANDExpression
BitwiseXORExpression @code{^} BitwiseANDExpression
BitwiseXORExpressionNoIn :
BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn @code{^} BitwiseANDExpressionNoIn
BitwiseORExpression :
BitwiseXORExpression
BitwiseORExpression @code{|} BitwiseXORExpression
BitwiseORExpressionNoIn :
BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn @code{|} BitwiseXORExpressionNoIn

@node Semantics
@section Semantics
The production A : A @@ B@comma{} where @@ is one of the bitwise operators in the productions above@comma{} is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating A.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating B.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let lnum be @uref{#sec-9.5,ToInt32}(lval).
@item
Let rnum be @uref{#sec-9.5,ToInt32}(rval).
@item
Return the result of applying the bitwise operator @@ to lnum and rnum. The result is a signed 32 bit integer.
@end enumerate


@node 1111 Binary Logical Operators
@chapter @uref{#sec-11.11,11.11} Binary Logical Operators
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
LogicalANDExpression :
BitwiseORExpression
LogicalANDExpression @code{&&} BitwiseORExpression
LogicalANDExpressionNoIn :
BitwiseORExpressionNoIn
LogicalANDExpressionNoIn @code{&&} BitwiseORExpressionNoIn

LogicalORExpression :
LogicalANDExpression
LogicalORExpression @code{||} LogicalANDExpression
LogicalORExpressionNoIn :
LogicalANDExpressionNoIn
LogicalORExpressionNoIn @code{||} LogicalANDExpressionNoIn

@node Semantics
@section Semantics
The production LogicalANDExpression : LogicalANDExpression @code{&&} BitwiseORExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating LogicalANDExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
If @uref{#sec-9.2,ToBoolean}(lval) is false@comma{} return lval.
@item
Let rref be the result of evaluating BitwiseORExpression.
@item
Return @uref{#sec-8.7.1,GetValue}(rref).
@end enumerate

The production LogicalORExpression : LogicalORExpression @code{||} LogicalANDExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating LogicalORExpression.
@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
If @uref{#sec-9.2,ToBoolean}(lval) is true@comma{} return lval.
@item
Let rref be the result of evaluating LogicalANDExpression.
@item
Return @uref{#sec-8.7.1,GetValue}(rref).
@end enumerate

The LogicalANDExpressionNoIn and LogicalORExpressionNoIn productions are evaluated in the same manner as the LogicalANDExpression and LogicalORExpression productions except that the contained LogicalANDExpressionNoIn@comma{} BitwiseORExpressionNoIn and LogicalORExpressionNoIn are evaluated instead of the contained LogicalANDExpression@comma{} BitwiseORExpression and LogicalORExpression@comma{} respectively.

NOTE The value produced by a @code{&&} or @code{||} operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.


@node 1112 Conditional Operator  ?
@chapter @uref{#sec-11.12,11.12} Conditional Operator ( @code{?} @code{:} )
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ConditionalExpression :
LogicalORExpression
LogicalORExpression @code{?} AssignmentExpression @code{:} AssignmentExpression
ConditionalExpressionNoIn :
LogicalORExpressionNoIn
LogicalORExpressionNoIn @code{?} AssignmentExpression @code{:} AssignmentExpressionNoIn

@node Semantics
@section Semantics
The production ConditionalExpression : LogicalORExpression @code{?} AssignmentExpression @code{:} AssignmentExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating LogicalORExpression.
@item
If @uref{#sec-9.2,ToBoolean}(@uref{#sec-8.7.1,GetValue}(lref)) is true@comma{} then
@enumerate
@item
Let trueRef be the result of evaluating the first AssignmentExpression.
@item
Return @uref{#sec-8.7.1,GetValue}(trueRef).
@end enumerate

@item
Else
@enumerate
@item
Let falseRef be the result of evaluating the second AssignmentExpression.
@item
Return @uref{#sec-8.7.1,GetValue}(falseRef).
@end enumerate

@end enumerate



NOTE The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java@comma{} which each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.


@node 1113 Assignment Operators
@chapter @uref{#sec-11.13,11.13} Assignment Operators
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
AssignmentExpression :
ConditionalExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
AssignmentExpressionNoIn :
ConditionalExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn
AssignmentOperator : one of
@code{=    *=   /=   %=   +=   -=   <<=  >>=  >>>= &=   ^=    |=}

@node Semantics
@section Semantics
The AssignmentExpressionNoIn productions are evaluated in the same manner as the AssignmentExpression productions except that the contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained ConditionalExpression and AssignmentExpression@comma{} respectively.


@node 11131 Simple Assignment  =
@chapter @uref{#sec-11.13.1,11.13.1} Simple Assignment ( @code{=} )
The production AssignmentExpression : LeftHandSideExpression @code{=} AssignmentExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating LeftHandSideExpression.
@item
Let rref be the result of evaluating AssignmentExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Throw a SyntaxError exception if the following conditions are all true:
@itemize
@item
@uref{#def-type,Type}(lref) is @uref{#sec-8.7,Reference} is true
@item
@uref{#def-IsStrictReference,IsStrictReference}(lref) is true
@item
@uref{#def-type,Type}(@uref{#def-GetBase,GetBase}(lref)) is Enviroment Record
@item
@uref{#def-GetReferencedName,GetReferencedName}(lref) is either "eval" or "arguments"
@end itemize

@item
Call @uref{#sec-8.7.2,PutValue}(lref@comma{} rval).
@item
Return rval.
@end enumerate

NOTE When an assignment occurs within @uref{#sec-10.1.1,strict mode code}@comma{} its LeftHandSide must not evaluate to an @uref{#def-IsUnresolvableReference,unresolvable reference}. If it does a ReferenceError exception is thrown upon assignment. The LeftHandSide also may not be a reference to a data property with the attribute value @{[[Writable]]:false@}@comma{} to an accessor property with the attribute value @{[[Set]]:undefined@}@comma{} nor to a non-existent property of an object whose [[Extensible]] internal property has the value false. In these cases a TypeError exception is thrown.


@node 11132 Compound Assignment  <var>op</var>=
@chapter @uref{#sec-11.13.2,11.13.2} Compound Assignment ( @code{<var>op</var>=} )
The production AssignmentExpression : LeftHandSideExpression @@ @code{=} AssignmentExpression@comma{} where @@ represents one of the operators indicated above@comma{} is evaluated as follows:

@enumerate
@item

@item
Let lval be @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating AssignmentExpression.
@item
Let rval be @uref{#sec-8.7.1,GetValue}(rref).
@item
Let r be the result of applying operator @@ to lval and rval.
@item
Throw a SyntaxError exception if the following conditions are all true:
@itemize
@item
@uref{#def-type,Type}(lref) is @uref{#sec-8.7,Reference} is true
@item
@uref{#def-IsStrictReference,IsStrictReference}(lref) is true
@item
@uref{#def-type,Type}(@uref{#def-GetBase,GetBase}(lref)) is Enviroment Record
@item
@uref{#def-GetReferencedName,GetReferencedName}(lref) is either "eval" or "arguments"
@end itemize

@item
Call @uref{#sec-8.7.2,PutValue}(lref@comma{} r).
@item
Return r.
@end enumerate

NOTE See NOTE @uref{#sec-11.13.1,11.13.1}.


@node 1114 Comma Operator
@chapter @uref{#sec-11.14,11.14} Comma Operator ( @code{@comma{}} )
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
Expression :
AssignmentExpression
Expression @code{@comma{}} AssignmentExpression
ExpressionNoIn :
AssignmentExpressionNoIn
ExpressionNoIn @code{@comma{}} AssignmentExpressionNoIn

@node Semantics
@section Semantics
The production Expression : Expression @code{@comma{}} AssignmentExpression is evaluated as follows:

@enumerate
@item
Let lref be the result of evaluating Expression.
@item
Call @uref{#sec-8.7.1,GetValue}(lref).
@item
Let rref be the result of evaluating AssignmentExpression.
@item
Return @uref{#sec-8.7.1,GetValue}(rref).
@end enumerate

The ExpressionNoIn production is evaluated in the same manner as the Expression production except that the contained ExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained Expression and AssignmentExpression@comma{} respectively.

NOTE @uref{#sec-8.7.1,GetValue} must be called even though its value is not used because it may have observable side-effects.



@node 12 Statements
@chapter @uref{#sec-12,12} Statements
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
Statement :
Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

@node Semantics
@section Semantics
A Statement can be part of a LabelledStatement@comma{} which itself can be part of a LabelledStatement@comma{} and so on. The labels introduced this way are collectively referred to as the “current label set” when describing the semantics of individual statements. A LabelledStatement has no semantic meaning other than the introduction of a label to a label set. The label set of an IterationStatement or a SwitchStatement initially contains the single element empty. The label set of any other statement is initially empty.

NOTE Several widely used implementations of ECMAScript are known to support the use of FunctionDeclaration as a Statement. However there are significant and irreconcilable variations among the implementations in the semantics applied to such FunctionDeclarations. Because of these irreconcilable difference@comma{} the use of a FunctionDeclaration as a Statement results in code that is not reliably portable among implementations. It is recommended that ECMAScript implementations either disallow this usage of FunctionDeclaration or issue a warning when such a usage is encountered. Future editions of ECMAScript may define alternative portable means for declaring functions in a Statement context.


@node 121 Block
@chapter @uref{#sec-12.1,12.1} Block
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
Block :
@code{@{} StatementList_opt_ @code{@}}
StatementList :
Statement
StatementList Statement

@node Semantics
@section Semantics
The production Block : @code{@{} @code{@}} is evaluated as follows:

@enumerate
@item
Return (normal@comma{} empty@comma{} empty).
@end enumerate

The production Block : @code{@{} StatementList @code{@}} is evaluated as follows:

@enumerate
@item
Return the result of evaluating StatementList.
@end enumerate

The production StatementList : Statement is evaluated as follows:

@enumerate
@item

@item
If an exception was thrown@comma{} return (throw@comma{} V@comma{} empty) where V is the exception. (Execution now proceeds as if no exception were thrown.)
@item
Return s.
@end enumerate

The production StatementList : StatementList Statement is evaluated as follows:

@enumerate
@item
Let sl be the result of evaluating StatementList.
@item
If sl is an @uref{#sec-8.9,abrupt completion}@comma{} return sl.
@item
Let s be the result of evaluating Statement.
@item
If an exception was thrown@comma{} return (throw@comma{} V@comma{} empty) where V is the exception. (Execution now proceeds as if no exception were thrown.)
@item
If s.value is empty@comma{} let V = sl.value@comma{} otherwise let V = s.value.
@item
Return (s.type@comma{} V@comma{} s.target).
@end enumerate


@node 122 Variable Statement
@chapter @uref{#sec-12.2,12.2} Variable Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
VariableStatement :
@code{var} VariableDeclarationList @code{;}
VariableDeclarationList :
VariableDeclaration
VariableDeclarationList @code{@comma{}} VariableDeclaration
VariableDeclarationListNoIn :
VariableDeclarationNoIn
VariableDeclarationListNoIn @code{@comma{}} VariableDeclarationNoIn
VariableDeclaration :
Identifier Initialiser_opt_
VariableDeclarationNoIn :
Identifier InitialiserNoIn_opt_
Initialiser :
@code{=} AssignmentExpression
InitialiserNoIn :
@code{=} AssignmentExpressionNoIn
A variable statement declares variables that are created as defined in @uref{#sec-10.5,10.5}. Variables are initialised to undefined when created. A variable with an Initialiser is assigned the value of its AssignmentExpression when the VariableStatement is executed@comma{} not when the variable is created.


@node Semantics
@section Semantics
The production VariableStatement : @code{var} VariableDeclarationList @code{;} is evaluated as follows:

@enumerate
@item
Evaluate VariableDeclarationList.
@item
Return (normal@comma{} empty@comma{} empty).
@end enumerate

The production VariableDeclarationList :VariableDeclaration is evaluated as follows:

@enumerate
@item
Evaluate VariableDeclaration.
@end enumerate

The production VariableDeclarationList : VariableDeclarationList @code{@comma{}} VariableDeclaration is evaluated as follows:

@enumerate
@item

@item
Evaluate VariableDeclaration.
@end enumerate

The production VariableDeclaration : Identifier is evaluated as follows:

@enumerate
@item
Return a String value containing the same sequence of characters as in the Identifier.
@end enumerate

The production VariableDeclaration : Identifier Initialiser is evaluated as follows:

@enumerate
@item
Let lhs be the result of evaluating Identifier as described in @uref{#sec-11.1.2,11.1.2}.
@item
Let rhs be the result of evaluating Initialiser.
@item
Let value be @uref{#sec-8.7.1,GetValue}(rhs).
@item
Call @uref{#sec-8.7.2,PutValue}(lhs@comma{} value).
@item
Return a String value containing the same sequence of characters as in the Identifier.
@end enumerate

NOTE The String value of a VariableDeclaration is used in the evaluation of for-in statements (@uref{#sec-12.6.4,12.6.4}).

If a VariableDeclaration is nested within a with statement and the Identifier in the VariableDeclaration is the same as a property name of the binding object of the with statement’s object environment record@comma{} then step 4 will assign value to the property instead of to the VariableEnvironment binding of the Identifier.

The production Initialiser : @code{=} AssignmentExpression is evaluated as follows:

@enumerate
@item
Return the result of evaluating AssignmentExpression.
@end enumerate

The VariableDeclarationListNoIn@comma{} VariableDeclarationNoIn and InitialiserNoIn productions are evaluated in the same manner as the VariableDeclarationList@comma{} VariableDeclaration and Initialiser productions except that the contained VariableDeclarationListNoIn@comma{} VariableDeclarationNoIn@comma{} InitialiserNoIn and AssignmentExpressionNoIn are evaluated instead of the contained VariableDeclarationList@comma{} VariableDeclaration@comma{} Initialiser and AssignmentExpression@comma{} respectively.


@node 1221 Strict Mode Restrictions
@chapter @uref{#sec-12.2.1,12.2.1} Strict Mode Restrictions
It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within @uref{#sec-10.1.1,strict code} and its Identifier is either "eval" or "arguments".


@node 123 Empty Statement
@chapter @uref{#sec-12.3,12.3} Empty Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
EmptyStatement :
@code{;}

@node Semantics
@section Semantics
The production EmptyStatement : @code{;} is evaluated as follows:

@enumerate
@item
Return (normal@comma{} empty@comma{} empty).
@end enumerate


@node 124 Expression Statement
@chapter @uref{#sec-12.4,12.4} Expression Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ExpressionStatement :
[@uref{#def-lookahead-notin,lookahead ∉} @{@code{@{}@comma{} @code{function}@}] Expression @code{;}
NOTE An ExpressionStatement cannot start with an opening curly brace because that might make it ambiguous with a Block. Also@comma{} an ExpressionStatement cannot start with the @code{function} keyword because that might make it ambiguous with a FunctionDeclaration.



@node Semantics
@section Semantics
The production ExpressionStatement : [@uref{#def-lookahead-notin,lookahead ∉} @{@code{@{}@comma{} @code{function}@}] Expression @code{;} is evaluated as follows:

@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
Return (normal@comma{} @uref{#sec-8.7.1,GetValue}(exprRef)@comma{} empty).
@end enumerate


@node 125 The if Statement
@chapter @uref{#sec-12.5,12.5} The @code{if} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
IfStatement :
@code{if} @code{(} Expression @code{)} Statement @code{else} Statement
@code{if} @code{(} Expression @code{)} Statement
Each @code{else} for which the choice of associated @code{if} is ambiguous shall be associated with the nearest possible @code{if} that would otherwise have no corresponding @code{else}.


@node Semantics
@section Semantics
The production IfStatement : @code{if} @code{(} Expression @code{)} Statement @code{else} Statement is evaluated as follows:

@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
If @uref{#sec-9.2,ToBoolean}(@uref{#sec-8.7.1,GetValue}(exprRef)) is true@comma{} then
@enumerate
@item
Return the result of evaluating the first Statement.
@end enumerate

@item
Else@comma{}
@enumerate
@item
Return the result of evaluating the second Statement.
@end enumerate

@end enumerate

The production IfStatement : @code{if} @code{(} Expression @code{)} Statement is evaluated as follows:

@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
If @uref{#sec-9.2,ToBoolean}(@uref{#sec-8.7.1,GetValue}(exprRef)) is false@comma{} return (normal@comma{} empty@comma{} empty).
@item
Return the result of evaluating Statement.
@end enumerate


@node 126 Iteration Statements
@chapter @uref{#sec-12.6,12.6} Iteration Statements
@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
IterationStatement :
@code{do} Statement @code{while} @code{(} Expression @code{)} @code{;}
@code{while} @code{(} Expression @code{)} Statement
@code{for} @code{(}ExpressionNoIn_opt_@code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} @code{var} VariableDeclarationListNoIn @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} LeftHandSideExpression @code{in} Expression @code{)} Statement
@code{for} @code{(} @code{var} VariableDeclarationNoIn @code{in} Expression @code{)} Statement

@node 1261 The do–while Statement
@chapter @uref{#sec-12.6.1,12.6.1} The @code{do}–@code{while} Statement
The production @code{do} Statement @code{while} @code{(} Expression @code{)} @code{;} is evaluated as follows:

@enumerate
@item
Let V = empty.
@item
Let iterating be true.
@item
Repeat@comma{} while iterating is true
@enumerate
@item
Let stmt be the result of evaluating Statement.
@item
If stmt.value is not empty@comma{} let V = stmt.value .
@item
If stmt.type is not continue || stmt.target is not in the current label set@comma{} then
@enumerate
@item
If stmt.type is break and stmt.target is in the current label set@comma{} return (normal@comma{} V@comma{} empty).
@item
If stmt is an @uref{#sec-8.9,abrupt completion}@comma{} return stmt.
@end enumerate

@item
Let exprRef be the result of evaluating Expression.
@item
If @uref{#sec-9.2,ToBoolean}(@uref{#sec-8.7.1,GetValue}(exprRef)) is false@comma{} set iterating to false.
@end enumerate

@item
Return (normal@comma{} V@comma{} empty);
@end enumerate


@node 1262 The while Statement
@chapter @uref{#sec-12.6.2,12.6.2} The @code{while} Statement
The production IterationStatement : @code{while} @code{(} Expression @code{)} Statement is evaluated as follows:

@enumerate
@item
Let V = empty.
@item
Repeat
@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
If @uref{#sec-9.2,ToBoolean}(@uref{#sec-8.7.1,GetValue}(exprRef)) is false@comma{} return (normal@comma{} V@comma{} empty).
@item
Let stmt be the result of evaluating Statement.
@item
If stmt.value is not empty@comma{} let V = stmt.value.
@item
If stmt.type is not continue || stmt.target is not in the current label set@comma{} then
@enumerate
@item
If stmt.type is break and stmt.target is in the current label set@comma{} then
@enumerate
@item
Return (normal@comma{} V@comma{} empty).
@end enumerate

@item
If stmt is an @uref{#sec-8.9,abrupt completion}@comma{} return stmt.
@end enumerate

@end enumerate

@end enumerate


@node 1263 The for Statement
@chapter @uref{#sec-12.6.3,12.6.3} The @code{for} Statement
The production IterationStatement : @code{for} @code{(} ExpressionNoIn_opt_ @code{;} Expression_opt_ @code{;} Expression_opt_@code{)} Statement is evaluated as follows:

@enumerate
@item
If ExpressionNoIn is present@comma{} then.
@enumerate
@item
Let exprRef be the result of evaluating ExpressionNoIn.
@item
Call @uref{#sec-8.7.1,GetValue}(exprRef). (This value is not used.)
@end enumerate

@item
Let V = empty.
@item
Repeat
@enumerate
@item
If the first Expression is present@comma{} then
@enumerate
@item
Let testExprRef be the result of evaluating the first Expression.
@item
If @uref{#sec-8.7.1,GetValue}(testExprRef) is false@comma{} return (normal@comma{} V@comma{} empty).
@end enumerate

@item
Let stmt be the result of evaluating Statement.
@item
If stmt.value is not empty@comma{} let V = stmt.value
@item
If stmt.type is break and stmt.target is in the current label set@comma{} return (normal@comma{} V@comma{} empty).
@item
If stmt.type is not continue || stmt.target is not in the current label set@comma{} then
@enumerate
@item
If stmt is an @uref{#sec-8.9,abrupt completion}@comma{} return stmt.
@end enumerate

@item
If the second Expression is present@comma{} then
@enumerate
@item
Let incExprRef be the result of evaluating the second Expression.
@item
Call @uref{#sec-8.7.1,GetValue}(incExprRef). (This value is not used.)
@end enumerate

@end enumerate

@end enumerate

The production IterationStatement : @code{for} @code{(} @code{var} VariableDeclarationListNoIn @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement is evaluated as follows:

@enumerate
@item
Evaluate VariableDeclarationListNoIn.
@item
Let V = empty.
@item
Repeat
@enumerate
@item
If the first Expression is present@comma{} then
@enumerate
@item
Let testExprRef be the result of evaluating the first Expression.
@item
If @uref{#sec-8.7.1,GetValue}(testExprRef) is false@comma{} then return (normal@comma{} V@comma{} empty).
@end enumerate

@item
Let stmt be the result of evaluating Statement.
@item
If stmt.value is not empty@comma{} let V = stmt.value.
@item
If stmt.type is break and stmt.target is in the current label set@comma{} return (normal@comma{} V@comma{} empty).
@item
If stmt.type is not continue || stmt.target is not in the current label set@comma{} then
@enumerate
@item
If stmt is an @uref{#sec-8.9,abrupt completion}@comma{} return stmt.
@end enumerate

@item
If the second Expression is present@comma{} then.
@enumerate
@item
Let incExprRef be the result of evaluating the second Expression.
@item
Call @uref{#sec-8.7.1,GetValue}(incExprRef). (This value is not used.)
@end enumerate

@end enumerate

@end enumerate



@node 1264 The for–in Statement
@chapter @uref{#sec-12.6.4,12.6.4} The @code{for}–@code{in} Statement
The production IterationStatement : @code{for} @code{(} LeftHandSideExpression @code{in} Expression @code{)} Statement is evaluated as follows:

@enumerate
@item
Let exprRef be the result of evaluating the Expression.
@item
Let experValue be @uref{#sec-8.7.1,GetValue}(exprRef).
@item
If experValue is null or undefined@comma{} return (normal@comma{} empty@comma{} empty).
@item
Let obj be @uref{#sec-9.9,ToObject}(experValue).
@item
Let V = empty.
@item
Repeat
@enumerate
@item
Let P be the name of the next property of obj whose [[Enumerable]] attribute is true. If there is no such property@comma{} return (normal@comma{} V@comma{} empty).
@item
Let lhsRef be the result of evaluating the LeftHandSideExpression ( it may be evaluated repeatedly).
@item
Call @uref{#sec-8.7.2,PutValue}(lhsRef@comma{} P).
@item
Let stmt be the result of evaluating Statement.
@item
If stmt.value is not empty@comma{} let V = stmt.value.
@item
If stmt.type is break and stmt.target is in the current label set@comma{} return (normal@comma{} V@comma{} empty).
@item
If stmt.type is not continue || stmt.target is not in the current label set@comma{} then
@enumerate
@item
If stmt is an @uref{#sec-8.9,abrupt completion}@comma{} return stmt.
@end enumerate

@end enumerate

@end enumerate

The production IterationStatement : @code{for} @code{(} @code{var} VariableDeclarationNoIn @code{in} Expression @code{)} Statement is evaluated as follows:

@enumerate
@item
Let varName be the result of evaluating VariableDeclarationNoIn.
@item
Let exprRef be the result of evaluating the Expression.
@item
Let experValue be @uref{#sec-8.7.1,GetValue}(exprRef).
@item
If experValue is null or undefined@comma{} return (normal@comma{} empty@comma{} empty).
@item
Let obj be @uref{#sec-9.9,ToObject}(experValue).
@item
Let V = empty.
@item
Repeat
@enumerate
@item
Let P be the name of the next property of obj whose [[Enumerable]] attribute is true. If there is no such property@comma{} return (normal@comma{} V@comma{} empty).
@item
Let varRef be the result of evaluating varName as if it were an Identifier Reference (@uref{#sec-11.1.2,11.1.2}); it may be evaluated repeatedly.
@item
Call @uref{#sec-8.7.2,PutValue}(varRef@comma{} P).
@item
Let stmt be the result of evaluating Statement.
@item
If stmt.value is not empty@comma{} let V = stmt.value.
@item
If stmt.type is break and stmt.target is in the current label set@comma{} return (normal@comma{} V@comma{} empty).
@item
If stmt.type is not continue || stmt.target is not in the current label set@comma{} then
@enumerate
@item
If stmt is an @uref{#sec-8.9,abrupt completion}@comma{} return stmt.
@end enumerate

@end enumerate

@end enumerate

The mechanics and order of enumerating the properties (step 6.a in the first algorithm@comma{} step 7.a in the second) is not specified. Properties of the object being enumerated may be deleted during enumeration. If a property that has not yet been visited during enumeration is deleted@comma{} then it will not be visited. If new properties are added to the object being enumerated during enumeration@comma{} the newly added properties are not guaranteed to be visited in the active enumeration. A property name must not be visited more than once in any enumeration.

Enumerating the properties of an object includes enumerating properties of its prototype@comma{} and the prototype of the prototype@comma{} and so on@comma{} recursively; but a property of a prototype is not enumerated if it is “shadowed” because some previous object in the prototype chain has a property with the same name. The values of [[Enumerable]] attributes are not considered when determining if a property of a prototype object is shadowed by a previous object on the prototype chain.

NOTE See NOTE @uref{#sec-11.13.1,11.13.1}.



@node 127 The continue Statement
@chapter @uref{#sec-12.7,12.7} The @code{continue} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ContinueStatement :
@code{continue} @uref{#def-restricted-production,[no LineTerminator here]} Identifier_opt_ @code{;}

@node Semantics
@section Semantics
A program is considered syntactically incorrect if either of the following is true:

@itemize
@item
The program contains a @code{continue} statement without the optional Identifier@comma{} which is not nested@comma{} directly or indirectly (but not crossing function boundaries)@comma{} within an IterationStatement.
@item
The program contains a @code{continue} statement with the optional Identifier@comma{} where Identifier does not appear in the label set of an enclosing (but not crossing function boundaries) IterationStatement.
@end itemize

A ContinueStatement without an Identifier is evaluated as follows:

@enumerate
@item
Return (continue@comma{} empty@comma{} empty).
@end enumerate

A ContinueStatement with the optional Identifier is evaluated as follows:

@enumerate
@item
Return (continue@comma{} empty@comma{} Identifier).
@end enumerate


@node 128 The break Statement
@chapter @uref{#sec-12.8,12.8} The @code{break} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
BreakStatement :
@code{break} @uref{#def-restricted-production,[no LineTerminator here]} Identifier_opt_ @code{;}

@node Semantics
@section Semantics
A program is considered syntactically incorrect if either of the following is true:

@itemize
@item
The program contains a @code{break} statement without the optional Identifier@comma{} which is not nested@comma{} directly or indirectly (but not crossing function boundaries)@comma{} within an IterationStatement or a SwitchStatement.
@item
The program contains a @code{break} statement with the optional Identifier@comma{} where Identifier does not appear in the label set of an enclosing (but not crossing function boundaries) Statement.
@end itemize

A BreakStatement without an Identifier is evaluated as follows:

@enumerate
@item
Return (break@comma{} empty@comma{} empty).
@end enumerate

A BreakStatement with an Identifier is evaluated as follows:

@enumerate
@item
Return (break@comma{} empty@comma{} Identifier).
@end enumerate


@node 129 The return Statement
@chapter @uref{#sec-12.9,12.9} The @code{return} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ReturnStatement :
@code{return} @uref{#def-restricted-production,[no LineTerminator here]} Expression_opt_ @code{;}


@node Semantics
@section Semantics
An ECMAScript program is considered syntactically incorrect if it contains a @code{return} statement that is not within a FunctionBody. A @code{return} statement causes a function to cease execution and return a value to the caller. If Expression is omitted@comma{} the return value is undefined. Otherwise@comma{} the return value is the value of Expression.

The production ReturnStatement : @code{return} @uref{#def-restricted-production,[no LineTerminator here]} Expression_opt_ @code{;} is evaluated as:

@enumerate
@item
If the Expression is not present@comma{} return (return@comma{} undefined@comma{} empty).
@item
Let exprRef be the result of evaluating Expression.
@item
Return (return@comma{} @uref{#sec-8.7.1,GetValue}(exprRef)@comma{} empty).
@end enumerate


@node 1210 The with Statement
@chapter @uref{#sec-12.10,12.10} The @code{with} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
WithStatement :
@code{with} @code{(} Expression @code{)} Statement
The @code{with} statement adds an object environment record for a computed object to the @uref{#sec-10.2,lexical environment} of the current execution context. It then executes a statement using this augmented lexical environment. Finally@comma{} it restores the original lexical environment.


@node Semantics
@section Semantics
The production WithStatement : @code{with} @code{(} Expression @code{)} Statement is evaluated as follows:

@enumerate
@item
Let val be the result of evaluating Expression.
@item
Let obj be @uref{#sec-9.9,ToObject}(@uref{#sec-8.7.1,GetValue}(val)).
@item
Let oldEnv be the running execution context’s LexicalEnvironment.
@item
Let newEnv be the result of calling @uref{#sec-10.2.2.3,NewObjectEnvironment} passing obj and oldEnv as the arguments.
@item
Set the provideThis flag of newEnv to true.
@item
Set the running execution context’s LexicalEnvironment to newEnv.
@item
Let C be the result of evaluating Statement but if an exception is thrown during the evaluation@comma{} let C be (throw@comma{} V@comma{} empty)@comma{} where V is the exception. (Execution now proceeds as if no exception were thrown.)
@item
Set the running execution context’s @uref{#sec-10.2,Lexical Environment} to oldEnv.
@item
Return C.
@end enumerate

NOTE No matter how control leaves the embedded Statement@comma{} whether normally or by some form of @uref{#sec-8.9,abrupt completion} or exception@comma{} the LexicalEnvironment is always restored to its former state.


@node 12101 Strict Mode Restrictions
@chapter @uref{#sec-12.10.1,12.10.1} Strict Mode Restrictions
@uref{#sec-10.1.1,Strict mode code} may not include a WithStatement. The occurrence of a WithStatement in such a context is treated as a SyntaxError.


@node 1211 The switch Statement
@chapter @uref{#sec-12.11,12.11} The @code{switch} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
SwitchStatement :
@code{switch} @code{(} Expression @code{)} CaseBlock
CaseBlock :
@code{@{} CaseClauses_opt_ @code{@}}
@code{@{} CaseClauses_opt_ DefaultClause CaseClauses_opt_ @code{@}}

CaseClauses :
CaseClause
CaseClauses CaseClause
CaseClause :
@code{case} Expression @code{:} StatementList_opt_
DefaultClause :
@code{default} @code{:} StatementList_opt_

@node Semantics
@section Semantics
The production SwitchStatement : @code{switch} @code{(} Expression @code{)} CaseBlock is evaluated as follows:

@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
Let R be the result of evaluating CaseBlock@comma{} passing it @uref{#sec-8.7.1,GetValue}(exprRef) as a parameter.
@item
If R.type is break and R.target is in the current label set@comma{} return (normal@comma{} R.value@comma{} empty).
@item
Return R.
@end enumerate

The production CaseBlock : @code{@{} CaseClauses_opt_ @code{@}} is given an input parameter@comma{} input@comma{} and is evaluated as follows:

@enumerate
@item
Let V = empty.
@item
Let A be the list of CaseClause items in source text order.
@item
Let searching be true.
@item
Repeat@comma{} while searching is true
@enumerate
@item
Let C be the next CaseClause in A. If there is no such CaseClause@comma{} return (normal@comma{} V@comma{} empty).
@item
Let clauseSelector be the result of evaluating C.
@item
If input is equal to clauseSelector as defined by the === operator@comma{} then
@enumerate
@item
Set searching to false.
@item
If C has a StatementList@comma{} then
@enumerate
@item
Evaluate C’s StatementList and let R be the result.
@item
If R is an @uref{#sec-8.9,abrupt completion}@comma{} then return R.
@item
Let V = R.value.
@end enumerate

@end enumerate

@end enumerate

@item
Repeat
@enumerate
@item
Let C be the next CaseClause in A. If there is no such CaseClause@comma{} return (normal@comma{} V@comma{} empty).
@item
If C has a StatementList@comma{} then
@enumerate
@item
Evaluate C’s StatementList and let R be the result.
@item
If R.value is not empty@comma{} then let V = R.value.
@item
If R is an @uref{#sec-8.9,abrupt completion}@comma{} then return (R.type@comma{} V@comma{} R.target).
@end enumerate

@end enumerate

@end enumerate

The production CaseBlock : @{ CaseClauses_opt_ DefaultClause CaseClauses_opt_ @} is given an input parameter@comma{} input@comma{} and is evaluated as follows:

@enumerate
@item
Let V = empty.
@item
Let A be the list of CaseClause items in the first CaseClauses@comma{} in source text order.
@item
Let B be the list of CaseClause items in the second CaseClauses@comma{} in source text order.
@item
Let found be false.
@item
Repeat letting C be in order each CaseClause in A
@enumerate
@item
If found is false@comma{} then
@enumerate
@item
Let clauseSelector be the result of evaluating C.
@item
If input is equal to clauseSelector as defined by the === operator@comma{} then set found to true.
@end enumerate

@item
If found is true@comma{} then
@enumerate
@item
If C has a StatementList@comma{} then
@enumerate
@item
Evaluate C’s StatementList and let R be the result.
@item
If R.value is not empty@comma{} then let V = R.value.
@item
R is an @uref{#sec-8.9,abrupt completion}@comma{} then return (R.type@comma{} V@comma{} R.target).
@end enumerate

@end enumerate

@end enumerate

@item
Let foundInB be false.
@item
If found is false@comma{} then
@enumerate
@item
Repeat@comma{} while foundInB is false and all elements of B have not been processed
@enumerate
@item

@item
Let clauseSelector be the result of evaluating C.
@item
If input is equal to clauseSelector as defined by the === operator@comma{} then
@enumerate
@item
Set foundInB to true.
@item
If C has a StatementList@comma{} then
@enumerate
@item
Evaluate C’s StatementList and let R be the result.
@item
If R.value is not empty@comma{} then let V = R.value.
@item
R is an @uref{#sec-8.9,abrupt completion}@comma{} then return (R.type@comma{} V@comma{} R.target).
@end enumerate

@end enumerate

@end enumerate

@end enumerate

@item
If foundInB is false and the DefaultClause has a StatementList@comma{} then
@enumerate
@item
Evaluate the DefaultClause’s StatementList and let R be the result.
@item
If R.value is not empty@comma{} then let V = R.value.
@item
If R is an @uref{#sec-8.9,abrupt completion}@comma{} then return (R.type@comma{} V@comma{} R.target).
@end enumerate

@item
Repeat (Note that if step 7.a.i has been performed this loop does not start at the beginning of B)
@enumerate
@item
Let C be the next CaseClause in B. If there is no such CaseClause@comma{} return (normal@comma{} V@comma{} empty).
@item
If C has a StatementList@comma{} then
@enumerate
@item
Evaluate C’s StatementList and let R be the result.
@item
If R.value is not empty@comma{} then let V = R.value.
@item
If R is an @uref{#sec-8.9,abrupt completion}@comma{} then return (R.type@comma{} V@comma{} R.target).
@end enumerate

@end enumerate

@end enumerate

The production CaseClause : @code{case} Expression @code{:} StatementList_opt_ is evaluated as follows:

@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
Return @uref{#sec-8.7.1,GetValue}(exprRef).
@end enumerate

NOTE Evaluating CaseClause does not execute the associated StatementList. It simply evaluates the Expression and returns the value@comma{} which the CaseBlock algorithm uses to determine which StatementList to start executing.


@node 1212 Labelled Statements
@chapter @uref{#sec-12.12,12.12} Labelled Statements
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
LabelledStatement :
Identifier @code{:} Statement

@node Semantics
@section Semantics
A Statement may be prefixed by a label. Labelled statements are only used in conjunction with labelled @code{break} and @code{continue} statements. ECMAScript has no @code{goto} statement.

An ECMAScript program is considered syntactically incorrect if it contains a LabelledStatement that is enclosed by a LabelledStatement with the same Identifier as label. This does not apply to labels appearing within the body of a FunctionDeclaration that is nested@comma{} directly or indirectly@comma{} within a labelled statement.

The production Identifier @code{:} Statement is evaluated by adding Identifier to the label set of Statement and then evaluating Statement. If the LabelledStatement itself has a non-empty label set@comma{} these labels are also added to the label set of Statement before evaluating it. If the result of evaluating Statement is (break@comma{} V@comma{} L) where L is equal to Identifier@comma{} the production results in (normal@comma{} V@comma{} empty).

Prior to the evaluation of a LabelledStatement@comma{} the contained Statement is regarded as possessing an empty label set@comma{} unless it is an IterationStatement or a SwitchStatement@comma{} in which case it is regarded as possessing a label set consisting of the single element@comma{} empty.


@node 1213 The throw Statement
@chapter @uref{#sec-12.13,12.13} The @code{throw} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
ThrowStatement :
@code{throw} @uref{#def-restricted-production,[no LineTerminator here]} Expression @code{;}


@node Semantics
@section Semantics
The production ThrowStatement : @code{throw} @uref{#def-restricted-production,[no LineTerminator here]} Expression @code{;} is evaluated as:

@enumerate
@item
Let exprRef be the result of evaluating Expression.
@item
Return (throw@comma{} @uref{#sec-8.7.1,GetValue}(exprRef)@comma{} empty).
@end enumerate


@node 1214 The try Statement
@chapter @uref{#sec-12.14,12.14} The @code{try} Statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
TryStatement :
@code{try} Block Catch
@code{try} Block Finally
@code{try} Block Catch Finally
Catch :
@code{catch} @code{(} Identifier @code{)} Block
Finally :
@code{finally} Block
The @code{try} statement encloses a block of code in which an exceptional condition can occur@comma{} such as a runtime error or a @code{throw} statement. The @code{catch} clause provides the exception-handling code. When a catch clause catches an exception@comma{} its Identifier is bound to that exception.


@node Semantics
@section Semantics
The production TryStatement : @code{try} Block Catch is evaluated as follows:

@enumerate
@item
Let B be the result of evaluating Block.
@item
If B.type is not throw@comma{} return B.
@item
Return the result of evaluating Catch with parameter B.
@end enumerate

The production TryStatement : @code{try} Block Finally is evaluated as follows:

@enumerate
@item
Let B be the result of evaluating Block.
@item
Let F be the result of evaluating Finally.
@item
If F.type is normal@comma{} return B.
@item
Return F.
@end enumerate

The production TryStatement : @code{try} Block Catch Finally is evaluated as follows:

@enumerate
@item
Let B be the result of evaluating Block.
@item
If B.type is throw@comma{} then
@enumerate
@item
Let C be the result of evaluating Catch with parameter B.
@end enumerate

@item
Else@comma{} B.type is not throw@comma{}
@enumerate
@item
Let C be B.
@end enumerate

@item
Let F be the result of evaluating Finally.
@item
If F.type is normal@comma{} return C.
@item
Return F.
@end enumerate

The production Catch : @code{catch} @code{(} Identifier @code{)} Block is evaluated as follows:

@enumerate
@item
Let C be the parameter that has been passed to this production.
@item
Let oldEnv be the running execution context’s LexicalEnvironment.
@item
Let catchEnv be the result of calling @uref{#sec-10.2.2.2,NewDeclarativeEnvironment} passing oldEnv as the argument.
@item
Call the CreateMutableBinding concrete method of catchEnv passing the Identifier String value as the argument.
@item
Call the SetMutableBinding concrete method of catchEnv passing the Identifier@comma{} C@comma{} and false as arguments. Note that the last argument is immaterial in this situation.
@item
Set the running execution context’s LexicalEnvironment to catchEnv.
@item
Let B be the result of evaluating Block.
@item
Set the running execution context’s LexicalEnvironment to oldEnv.
@item
Return B.
@end enumerate

NOTE No matter how control leaves the Block the LexicalEnvironment is always restored to its former state.

The production Finally : @code{finally} Block is evaluated as follows:

@enumerate
@item
Return the result of evaluating Block.
@end enumerate


@node 12141 Strict Mode Restrictions
@chapter @uref{#sec-12.14.1,12.14.1} Strict Mode Restrictions
It is a SyntaxError if a TryStatement with a Catch occurs within @uref{#sec-10.1.1,strict code} and the Identifier of the Catch production is either "eval" or "arguments".


@node 1215 The debugger statement
@chapter @uref{#sec-12.15,12.15} The @code{debugger} statement
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
DebuggerStatement :
debugger @code{;}

@node Semantics
@section Semantics
Evaluating the DebuggerStatement production may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.

The production DebuggerStatement : @code{debugger} @code{;} is evaluated as follows:

@enumerate
@item
If an implementation defined debugging facility is available and enabled@comma{} then
@enumerate
@item
Perform an implementation defined debugging action.
@item
Let result be an implementation defined @uref{#sec-8.9,Completion} value.
@end enumerate

@item
Else
@enumerate
@item
Let result be (normal@comma{} empty@comma{} empty).
@end enumerate

@item
Return result.
@end enumerate


@node 13 Function Definition
@chapter @uref{#sec-13,13} Function Definition
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
FunctionDeclaration :
@code{function} Identifier @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}}
FunctionExpression :
@code{function} Identifier_opt_ @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}}
FormalParameterList :
Identifier
FormalParameterList @code{@comma{}} Identifier
FunctionBody :
SourceElements_opt_


@node Semantics
@section Semantics
The production FunctionDeclaration : @code{function} Identifier @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}} is instantiated as follows during @uref{#sec-10.5,Declaration Binding instantiation (10.5)}:

Return the result of creating a new Function object as specified in @uref{#sec-13.2,13.2} with parameters specified by FormalParameterList
sub class="gopt">opt@comma{} and body specified by FunctionBody. Pass in the VariableEnvironment of the running execution context as the Scope. Pass in true as the Strict flag if the FunctionDeclaration is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code}.
The production FunctionExpression : @code{function} @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}} is evaluated as follows:

@enumerate
@item
Return the result of creating a new Function object as specified in @uref{#sec-13.2,13.2} with parameters specified by FormalParameterList_opt_ and body specified by FunctionBody. Pass in the LexicalEnvironment of the running execution context as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code}.
@end enumerate

The production FunctionExpression : @code{function} Identifier @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}} is evaluated as follows:

@enumerate
@item
Let funcEnv be the result of calling @uref{#sec-10.2.2.2,NewDeclarativeEnvironment} passing the running execution context’s @uref{#sec-10.2,Lexical Environment} as the argument
@item
Let envRec be funcEnv’s environment record.
@item
Call the @uref{#sec-10.2.1.1.7,CreateImmutableBinding(N)} concrete method of envRec passing the String value of Identifier as the argument.
@item
Let closure be the result of creating a new Function object as specified in @uref{#sec-13.2,13.2} with parameters specified by FormalParameterList_opt_ and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code}.
@item
Call the @uref{#sec-10.2.1.1.8,InitializeImmutableBinding(N@comma{}@ V)} concrete method of envRec passing the String value of Identifier and closure as the arguments.
@item
Return closure.
@end enumerate

NOTE The Identifier in a FunctionExpression can be referenced from inside the FunctionExpression’s FunctionBody to allow the function to call itself recursively. However@comma{} unlike in a FunctionDeclaration@comma{} the Identifier in a FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression.

The production FunctionBody : SourceElements_opt_ is evaluated as follows:

@enumerate
@item
The code of this FunctionBody is @uref{#sec-10.1.1,strict mode code} if it is part of a FunctionDeclaration or FunctionExpression that is contained in @uref{#sec-10.1.1,strict mode code} or if the Directive Prologue (@uref{#sec-14.1,14.1}) of its SourceElements contains a Use Strict Directive or if any of the conditions in @uref{#sec-10.1.1,10.1.1} apply. If the code of this FunctionBody is @uref{#sec-10.1.1,strict mode code}@comma{} SourceElements is evaluated in the following steps as @uref{#sec-10.1.1,strict mode code}. Otherwise@comma{} SourceElements is evaluated in the following steps as non-strict mode code.
@item
If SourceElements is present return the result of evaluating SourceElements.
@item
Else return (normal@comma{} undefined@comma{} empty).
@end enumerate


@node 131 Strict Mode Restrictions
@chapter @uref{#sec-13.1,13.1} Strict Mode Restrictions
It is a SyntaxError if any Identifier value occurs more than once within a FormalParameterList of a strict mode FunctionDeclaration or FunctionExpression.

It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs within a FormalParameterList of a strict mode FunctionDeclaration or FunctionExpression.




@node 132 Creating Function Objects
@chapter @uref{#sec-13.2,13.2} Creating Function Objects
Given an optional parameter list specified by FormalParameterList@comma{} a body specified by FunctionBody@comma{} a @uref{#sec-10.2,Lexical Environment} specified by Scope@comma{} and a Boolean flag Strict@comma{} a Function object is constructed as follows:

@enumerate
@item
Create a new native ECMAScript object and let F be that object.
@item
Set all the internal methods@comma{} except for [[Get]]@comma{} of F as described in @uref{#sec-8.12,8.12}.
@item
Set the [[Class]] internal property of F to "Function".
@item
Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in @uref{#sec-15.3.3.1,15.3.3.1}.
@item
Set the [[Get]] internal property of F as described in @uref{#sec-15.3.5.4,15.3.5.4}.
@item
Set the [[Call]] internal property of F as described in @uref{#sec-13.2.1,13.2.1}.
@item
Set the [[Construct]] internal property of F as described in @uref{#sec-13.2.2,13.2.2}.
@item
Set the [[HasInstance]] internal property of F as described in @uref{#sec-15.3.5.3,15.3.5.3}.
@item
Set the [[Scope]] internal property of F to the value of Scope.
@item
Let names be a @uref{#sec-8.8,List} containing@comma{} in left to right textual order@comma{} the Strings corresponding to the identifiers of FormalParameterList.
@item
Set the [[FormalParameters]] internal property of F to names.
@item
Set the [[Code]] internal property of F to FunctionBody.
@item
Set the [[Extensible]] internal property of F to true.
@item
Let len be the number of formal parameters specified in FormalParameterList. If no parameters are specified@comma{} let len be 0.
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "length"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: len@comma{} [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
Let proto be the result of creating a new object as would be constructed by the expression @code{new Object()} where Object is @uref{#sec-15.2,the standard built-in constructor with that name}.
@item
Call the [[DefineOwnProperty]] internal method of proto with arguments "constructor"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: F@comma{} @{ [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "prototype"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: proto@comma{} @{ [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
If Strict is true@comma{} then
@enumerate
@item
Let thrower be the [[ThrowTypeError]] function Object (@uref{#sec-13.2.3,13.2.3}).
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "caller"@comma{} PropertyDescriptor @{[[Get]]: thrower@comma{} [[Set]]: thrower@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "arguments"@comma{} PropertyDescriptor @{[[Get]]: thrower@comma{} [[Set]]: thrower@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@end enumerate

@item
Return F.
@end enumerate

NOTE A @code{prototype} property is automatically created for every function@comma{} to allow for the possibility that the function will be used as a constructor.


@node 1321 [[Call]]
@chapter @uref{#sec-13.2.1,13.2.1} [[Call]]
When the [[Call]] internal method for a Function object F is called with a this value and a list of arguments@comma{} the following steps are taken:

@enumerate
@item
Let funcCtx be the result of establishing a new execution context for function code using the value of F’s [[FormalParameters]] internal property@comma{} the passed arguments @uref{#sec-8.8,List} args@comma{} and the this value as described in @uref{#sec-10.4.3,10.4.3}.
@item
Let result be the result of evaluating the FunctionBody that is the value of F’s [[Code]] internal property. If F does not have a [[Code]] internal property or if its value is an empty FunctionBody@comma{} then result is (normal@comma{} undefined@comma{} empty).
@item
Exit the execution context funcCtx@comma{} restoring the previous execution context.
@item
If result.type is throw then throw result.value.
@item
If result.type is return then return result.value.
@item
Otherwise result.type must be normal. Return undefined.
@end enumerate


@node 1322 [[Construct]]
@chapter @uref{#sec-13.2.2,13.2.2} [[Construct]]
When the [[Construct]] internal method for a Function object F is called with a possibly empty list of arguments@comma{} the following steps are taken:

@enumerate
@item
Let obj be a newly created native ECMAScript object.
@item
Set all the internal methods of obj as specified in @uref{#sec-8.12,8.12}.
@item
Set the [[Class]] internal property of obj to "Object".
@item
Set the [[Extensible]] internal property of obj to true.
@item
Let proto be the value of calling the [[Get]] internal property of F with argument "prototype".
@item
If @uref{#def-type,Type}(proto) is Object@comma{} set the [[Prototype]] internal property of obj to proto.
@item
If @uref{#def-type,Type}(proto) is not Object@comma{} set the [[Prototype]] internal property of obj to the standard built-in Object prototype object as described in @uref{#sec-15.2.4,15.2.4}.
@item
Let result be the result of calling the [[Call]] internal property of F@comma{} providing obj as the this value and providing the argument list passed into [[Construct]] as args.
@item
If @uref{#def-type,Type}(result) is Object then return result.
@item
Return obj.
@end enumerate


@node 1323 The [[ThrowTypeError]] Function Object
@chapter @uref{#sec-13.2.3,13.2.3} The [[ThrowTypeError]] Function Object
@enumerate
@item
The [[ThrowTypeError]] object is a unique function object that is defined once as follows:
@item
Create a new native ECMAScript object and let F be that object.
@item
Set all the internal methods of F as described in @uref{#sec-8.12,8.12}.
@item
Set the [[Class]] internal property of F to "Function".
@item
Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in @uref{#sec-15.3.3.1,15.3.3.1}.
@item
Set the [[Call]] internal property of F as described in @uref{#sec-13.2.1,13.2.1}.
@item
Set the [[Scope]] internal property of F to the Global Environment.
@item
Set the [[FormalParameters]] internal property of F to an empty @uref{#sec-8.8,List}.
@item
Set the [[Code]] internal property of F to be a FunctionBody that unconditionally throws a TypeError exception and performs no other action.
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "length"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: 0@comma{} [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
Set the [[Extensible]] internal property of F to false.
@item
Let [[ThrowTypeError]] be F.
@end enumerate


@node 14 Program
@chapter @uref{#sec-14,14} Program
@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
Program :
SourceElements_opt_
SourceElements :
SourceElement
SourceElements SourceElement
SourceElement :
Statement FunctionDeclaration

@node Semantics
@section Semantics
The production Program : SourceElements_opt_ is evaluated as follows:

@enumerate
@item
The code of this Program is @uref{#sec-10.1.1,strict mode code} if the Directive Prologue (@uref{#sec-14.1,14.1}) of its SourceElements contains a Use Strict Directive or if any of the conditions of @uref{#sec-10.1.1,10.1.1} apply. If the code of this Program is @uref{#sec-10.1.1,strict mode code}@comma{} SourceElements is evaluated in the following steps as @uref{#sec-10.1.1,strict mode code}. Otherwise SourceElements is evaluated in the following steps as non-strict mode code.
@item
If SourceElements is not present@comma{} return (normal@comma{} empty@comma{} empty).
@item
Let progCxt be a new execution context for @uref{#def-global-code,global code} as described in @uref{#sec-10.4.1,10.4.1}.
@item
Let result be the result of evaluating SourceElements.
@item
Exit the execution context progCxt.
@item
Return result.
@end enumerate

NOTE The processes for initiating the evaluation of a Program and for dealing with the result of such an evaluation are defined by an ECMAScript implementation and not by this specification.

The production SourceElements : SourceElements SourceElement is evaluated as follows:

@enumerate
@item
Let headResult be the result of evaluating SourceElements.
@item
If headResult is an @uref{#sec-8.9,abrupt completion}@comma{} return headResult.
@item
Let tailResult be result of evaluating SourceElement.
@item
If tailResult.value is empty@comma{} let V = headResult.value@comma{} otherwise let V = tailResult.value.
@item
Return (tailResult.type@comma{} V@comma{} tailResult.target).
@end enumerate

The production SourceElement : Statement is evaluated as follows:

@enumerate
@item
Return the result of evaluating Statement.
@end enumerate

The production SourceElement : FunctionDeclaration is evaluated as follows:

@enumerate
@item
Return (normal@comma{} empty@comma{} empty).
@end enumerate


@node 141 Directive Prologues and the Use Strict Directive
@chapter @uref{#sec-14.1,14.1} Directive Prologues and the Use Strict Directive
A Directive Prologue is the longest sequence of ExpressionStatement productions occurring as the initial SourceElement productions of a Program or FunctionBody and where each ExpressionStatement in the sequence consists entirely of a StringLiteral token followed a semicolon. The semicolon may appear explicitly or may be inserted by automatic semicolon insertion. A Directive Prologue may be an empty sequence.

A Use Strict Directive is an ExpressionStatement in a Directive Prologue whose StringLiteral is either the exact character sequences @code{"use strict"} or @code{'use strict'}. A Use Strict Directive may not contain an EscapeSequence or LineContinuation.

A Directive Prologue may contain more than one Use Strict Directive. However@comma{} an implementation may issue a warning if this occurs.

NOTE The ExpressionStatement productions of a Directive Prologue are evaluated normally during evaluation of the containing SourceElements production. Implementations may define implementation specific meanings for ExpressionStatement productions which are not a Use Strict Directive and which occur in a Directive Prologue. If an appropriate notification mechanism exists@comma{} an implementation should issue a warning if it encounters in a Directive Prologue an ExpressionStatement that is not a Use Strict Directive or which does not have a meaning defined by the implementation.


@node 15 Standard Built-in ECMAScript Objects
@chapter @uref{#sec-15,15} Standard Built-in ECMAScript Objects
There are certain built-in objects available whenever an ECMAScript program begins execution. One@comma{} the @uref{#sec-15.1,global object}@comma{} is part of the @uref{#sec-10.2,lexical environment} of the executing program. Others are accessible as initial properties of the global object.

Unless specified otherwise@comma{} the [[Class]] internal property of a built-in object is "Function" if that built-in object has a [[Call]] internal property@comma{} or "Object" if that built-in object does not have a [[Call]] internal property. Unless specified otherwise@comma{} the [[Extensible]] internal property of a built-in object initially has the value true.

Many built-in objects are functions: they can be invoked with arguments. Some of them furthermore are constructors: they are functions intended for use with the @code{new} operator. For each built-in function@comma{} this

Unless otherwise specified in the description of a particular function@comma{} if a function or constructor described in this clause is given fewer arguments than the function is specified to require@comma{} the function or constructor shall behave exactly as if it had been given sufficient additional arguments@comma{} each such argument being the undefined value.

Unless otherwise specified in the description of a particular function@comma{} if a function or constructor described in this clause is given more arguments than the function is specified to allow@comma{} the extra arguments are evaluated by the call and then ignored by the function. However@comma{} an implementation may define implementation specific behaviour relating to such arguments as long as the behaviour is not the throwing of a TypeError exception that is predicated simply on the presence of an extra argument.

NOTE Implementations that add additional capabilities to the set of built-in functions are encouraged to do so by adding new functions rather than adding new parameters to existing functions.

Every built-in function and every built-in constructor has the @uref{#sec-15.3.4,Function prototype object}@comma{} which is the initial value of the expression @code{Function.prototype} (@uref{#sec-15.3.4,15.3.4})@comma{} as the value of its [[Prototype]] internal property.

Unless otherwise specified every built-in prototype object has the Object prototype object@comma{} which is the initial value of the expression @code{Object.prototype} (@uref{#sec-15.2.4,15.2.4})@comma{} as the value of its [[Prototype]] internal property@comma{} except the Object prototype object itself.

None of the built-in functions described in this clause that are not constructors shall implement the [[Construct]] internal method unless otherwise specified in the description of a particular function. None of the built-in functions described in this clause shall have a @code{prototype} property unless otherwise specified in the description of a particular function.

This clause generally describes distinct behaviours for when a constructor is “called as a function” and for when it is “called as part of a @code{new} expression”. The “called as a function” behaviour corresponds to the invocation of the constructor’s [[Call]] internal method and the “called as part of a new expression” behaviour corresponds to the invocation of the constructor’s [[Construct]] internal method.

Every built-in Function object described in this clause—whether as a constructor@comma{} an ordinary function@comma{} or both—has a @code{length} property whose value is an integer. Unless otherwise specified@comma{} this value is equal to the largest number of named arguments shown in the subclause headings for the function description@comma{} including optional parameters.

NOTE For example@comma{} the Function object that is the initial value of the @code{slice} property of the String prototype object is described under the subclause heading “String.prototype.slice (start@comma{} end)” which shows the two named arguments start and end; therefore the value of the @code{length} property of that Function object is 2.

In every case@comma{} the @code{length} property of a built-in Function object described in this clause has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}. Every other property described in this clause has the attributes @{ [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: true @} unless otherwise specified.


@node 151 The Global Object
@chapter @uref{#sec-15.1,15.1} The Global Object
The unique global object is created before control enters any execution context.

Unless otherwise specified@comma{} the standard built-in properties of the global object have attributes @{[[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: true@}.

The global object does not have a [[Construct]] internal property; it is not possible to use the global object as a constructor with the @code{new} operator.



The values of the [[Prototype]] and [[Class]] internal properties of the global object are implementation-dependent.

In addition to the properties defined in this specification the global object may have additional host defined properties. This may include a property whose value is the global object itself; for example@comma{} in the HTML document object model the @code{window} property of the global object is the global object itself.


@node 1511 Value Properties of the Global Object
@chapter @uref{#sec-15.1.1,15.1.1} Value Properties of the Global Object

@node 15111 NaN
@chapter @uref{#sec-15.1.1.1,15.1.1.1} NaN
The value of NaN is NaN (@uref{#sec-8.5,see 8.5}). This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15112 Infinity
@chapter @uref{#sec-15.1.1.2,15.1.1.2} Infinity
The value of Infinity is +∞ (@uref{#sec-8.5,see 8.5}). This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15113 undefined
@chapter @uref{#sec-15.1.1.3,15.1.1.3} undefined
The value of undefined is undefined (@uref{#sec-8.1,see 8.1}). This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 1512 Function Properties of the Global Object
@chapter @uref{#sec-15.1.2,15.1.2} Function Properties of the Global Object

@node 15121 eval x
@chapter @uref{#sec-15.1.2.1,15.1.2.1} eval (x)
When the eval function is called with one argument x@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(x) is not String@comma{} return x.
@item
Let prog be the ECMAScript code that is the result of parsing x as a Program. If the parse fails@comma{} throw a SyntaxError exception (but see also @uref{#sec-16,clause 16}).
@item
Let evalCtx be the result of establishing a new execution context (@uref{#sec-10.4.2,10.4.2}) for the @uref{#def-eval-code,eval code} prog.
@item
Let result be the result of evaluating the program prog.
@item
Exit the running execution context evalCtx@comma{} restoring the previous execution context.
@item
If result.type is normal and its completion value is a value V@comma{} then return the value V.
@item
If result.type is normal and its completion value is empty@comma{} then return the value undefined.
@item
Otherwise@comma{} result.type must be throw. Throw result.value as an exception.
@end enumerate


@node 151211 Direct Call to Eval
@chapter @uref{#sec-15.1.2.1.1,15.1.2.1.1} Direct Call to Eval
A direct call to the eval function is one that is expressed as a CallExpression that meets the following two conditions:

The @uref{#sec-8.7,Reference} that is the result of evaluating the MemberExpression in the CallExpression has an environment record as its base value and its reference name is "eval".

The result of calling the abstract operation @uref{#sec-8.7.1,GetValue} with that @uref{#sec-8.7,Reference} as the argument is the standard built-in function defined in @uref{#sec-15.1.2.1,15.1.2.1}.



@node 15122 parseInt string  radix
@chapter @uref{#sec-15.1.2.2,15.1.2.2} parseInt (string @comma{} radix)
The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0@comma{} it is assumed to be 10 except when the number begins with the character pairs @code{0x} or @code{0X}@comma{} in which case a radix of 16 is assumed. If radix is 16@comma{} the number may also optionally begin with the character pairs @code{0x} or @code{0X}.

When the parseInt function is called@comma{} the following steps are taken:

@enumerate
@item
Let inputString be @uref{#sec-9.8,ToString}(string).
@item
Let S be a newly created substring of inputString consisting of the first character that is not a StrWhiteSpaceChar and all characters following that character. (In other words@comma{} remove leading white space.)
@item
Let sign be 1.
@item
If S is not empty and the first character of S is a minus sign @code{-}@comma{} let sign be −1.
@item
If S is not empty and the first character of S is a plus sign @code{+} or a minus sign @code{-}@comma{} then remove the first character from S.
@item
Let R = @uref{#sec-9.5,ToInt32}(radix).
@item
Let stripPrefix be true.
@item
If R ≠ 0@comma{} then
@enumerate
@item
If R < 2 or R > 36@comma{} then return NaN.
@item
If R 16@comma{} let stripPrefix be false.
@end enumerate

@item
Else@comma{} R = 0
@enumerate
@item
Let R = 10.
@end enumerate

@item
If stripPrefix is true@comma{} then
@enumerate
@item
If the length of S is at least 2 and the first two characters of S are either “@code{0x}” or “@code{0X}”@comma{} then remove the first two characters from S and let R = 16.
@end enumerate

@item
If S contains any character that is not a radix-R digit@comma{} then let Z be the substring of S consisting of all characters before the first such character; otherwise@comma{} let Z be S.
@item
If Z is empty@comma{} return NaN.
@item
Let mathInt be the mathematical integer value that is represented by Z in radix-R notation@comma{} using the letters @code{A}–@code{Z} and @code{a}–@code{z} for digits with values 10 through 35. (However@comma{} if R is 10 and Z contains more than 20 significant digits@comma{} every significant digit after the 20th may be replaced by a @code{0} digit@comma{} at the option of the implementation; and if R is not 2@comma{} 4@comma{} 8@comma{} 10@comma{} 16@comma{} or 32@comma{} then mathInt may be an implementation-dependent approximation to the mathematical integer value that is represented by Z in radix-R notation.)
@item
Let number be the Number value for mathInt.
@item
Return sign × number.
@end enumerate

NOTE parseInt may interpret only a leading portion of string as an integer value; it ignores any characters that cannot be interpreted as part of the notation of an integer@comma{} and no indication is given that any such characters were ignored.


@node 15123 parseFloatstring
@chapter @uref{#sec-15.1.2.3,15.1.2.3} parseFloat(string)
The parseFloat function produces a Number value dictated by interpretation of the contents of the string argument as a decimal literal.

When the parseFloat function is called@comma{} the following steps are taken:

@enumerate
@item
Let inputString be @uref{#sec-9.8,ToString}(string).
@item
Let trimmedString be a substring of inputString consisting of the leftmost character that is not a StrWhiteSpaceChar and all characters to the right of that character.(In other words@comma{} remove leading white space.)
@item
If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (@uref{#sec-9.3.1,see 9.3.1})@comma{} return NaN.
@item
Let numberString be the longest prefix of trimmedString@comma{} which might be trimmedString itself@comma{} that satisfies the syntax of a StrDecimalLiteral.
@item
Return the Number value for the MV of numberString.
@end enumerate




@node 15124 isNaN number
@chapter @uref{#sec-15.1.2.4,15.1.2.4} isNaN (number)
Returns true if the argument coerces to NaN@comma{} and otherwise returns false.

@enumerate
@item
If @uref{#sec-9.3,ToNumber}(number) is NaN@comma{} return true.
@item
Otherwise@comma{} return false.
@end enumerate

NOTE A reliable way for ECMAScript code to test if a value X is a NaN is an expression of the form @code{X !== X}. The result will be true if and only if X is a NaN.


@node 15125 isFinitenumber
@chapter @uref{#sec-15.1.2.5,15.1.2.5} isFinite(number)
Returns false if the argument coerces to NaN@comma{} +∞@comma{} or −∞@comma{} and otherwise returns true.

@enumerate
@item
If @uref{#sec-9.3,ToNumber}(number) is NaN@comma{} +∞@comma{} or −∞@comma{} return false.
@item
Otherwise@comma{} return true.
@end enumerate


@node 1513 URI Handling Function Properties
@chapter @uref{#sec-15.1.3,15.1.3} URI Handling Function Properties
Uniform Resource Identifiers@comma{} or URIs@comma{} are Strings that identify resources (e.g. web pages or files) and transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language itself does not provide any support for using URIs except for functions that encode and decode URIs as described in @uref{#sec-15.1.3.1,15.1.3.1}@comma{} @uref{#sec-15.1.3.2,15.1.3.2}@comma{} @uref{#sec-15.1.3.3,15.1.3.3} and @uref{#sec-15.1.3.4,15.1.3.4}.

NOTE Many implementations of ECMAScript provide additional functions and methods that manipulate web pages; these functions are beyond the scope of this standard.

A URI is composed of a sequence of components separated by component separators. The general form is:

Scheme @code{:} First @code{/} Second @code{;} Third @code{?} Fourth
where the italicised names represent components and “@code{:}”@comma{} “@code{/}”@comma{} “@code{;}” and “@code{?}” are reserved characters used as separators. The @uref{#sec-15.1.3.3,encodeURI} and @uref{#sec-15.1.3.1,decodeURI} functions are intended to work with complete URIs; they assume that any reserved characters in the URI are intended to have special meaning and so are not encoded. The @uref{#sec-15.1.3.4,encodeURIComponent} and @uref{#sec-15.1.3.2,decodeURIComponent} functions are intended to work with the individual component parts of a URI; they assume that any reserved characters represent text and so must be encoded so that they are not interpreted as reserved characters when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

uri :::
uriCharacters_opt_
uriCharacters :::
uriCharacter uriCharacters_opt_
uriCharacter :::
uriReserved
uriUnescaped
uriEscaped
uriReserved ::: one of
@code{;  /  ?  :  @@  &  =  +  $  @comma{}}

uriUnescaped :::
uriAlpha
DecimalDigit
uriMark
uriEscaped :::
@code{%} HexDigit HexDigit
uriAlpha ::: one of
@code{a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z}
@code{A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z}
uriMark ::: one of
@code{-  _  .  !  ~  *  ?  (  )}
When a character to be included in a URI is not listed above or is not intended to have the special meaning sometimes given to the reserved characters@comma{} that character must be encoded. The character is transformed into its UTF-8 encoding@comma{} with surrogate pairs first converted from UTF-16 to the corresponding code point value. (Note that for code units in the range [0@comma{}127] this results in a single octet with the same value.) The resulting sequence of octets is then transformed into a String with each octet represented by an escape sequence of the form "%xx".

The encoding and escaping process is described by the abstract operation Encode taking two String arguments string and unescapedSet.

@enumerate
@item
Let strLen be the number of characters in string.
@item
Let R be the empty String.
@item
Let k be 0.
@item
Repeat
@enumerate
@item
If k equals strLen@comma{} return R.
@item
Let C be the character at position k within string.
@item
If C is in unescapedSet@comma{} then
@enumerate
@item
Let S be a String containing only the character C.
@item
Let R be a new String value computed by concatenating the previous value of R and S.
@end enumerate

@item
Else@comma{} C is not in unescapedSet
@enumerate
@item
If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF@comma{} throw a URIError exception.
@item
If the code unit value of C is less than 0xD800 or greater than 0xDBFF@comma{} then
@enumerate
@item
Let V be the code unit value of C.
@end enumerate

@item
Else@comma{}
@enumerate
@item
Increase k by 1.
@item
If k equals strLen@comma{} throw a URIError exception.
@item
Let kChar be the code unit value of the character at position k within string.
@item
If kChar is less than 0xDC00 or greater than 0xDFFF@comma{} throw a URIError exception.
@item
Let V be (((the code unit value of C) − 0xD800) × 0x400 + (kChar − 0xDC00) + 0x10000).
@end enumerate

@item
Let Octets be the array of octets resulting by applying the UTF-8 transformation to V@comma{} and let L be the array size.
@item
Let j be 0.
@item
Repeat@comma{} while j < L
@enumerate
@item
Let jOctet be the value at position j within Octets.
@item
Let S be a String containing three characters "%XY" where XY are two uppercase hexadecimal digits encoding the value of jOctet.
@item
Let R be a new String value computed by concatenating the previous value of R and S.
@item
Increase j by 1.
@end enumerate

@end enumerate

@item
Increase k by 1.
@end enumerate

@end enumerate



@enumerate
@item
Let strLen be the number of characters in string.
@item
Let R be the empty String.
@item
Let k be 0.
@item
Repeat
@enumerate
@item
If k equals strLen@comma{} return R.
@item
Let C be the character at position k within string.
@item
If C is not ‘@code{%}’@comma{} then
@enumerate
@item
Let S be the String containing only the character C.
@end enumerate

@item
Else@comma{} C is ‘@code{%}’
@enumerate
@item
Let start be k.
@item
If k + 2 is greater than or equal to strLen@comma{} throw a URIError exception.
@item
If the characters at position (k+1) and (k + 2) within string do not represent hexadecimal digits@comma{} throw a URIError exception.
@item
Let B be the 8-bit value represented by the two hexadecimal digits at position (k + 1) and (k + 2).
@item
Increment k by 2.
@item
If the most significant bit in B is 0@comma{} then
@enumerate
@item
Let C be the character with code unit value B.
@item
If C is not in reservedSet@comma{} then
@enumerate
@item
Let S be the String containing only the character C.
@end enumerate

@item
Else@comma{} C is in reservedSet
@enumerate
@item
Let S be the substring of string from position start to position k included.
@end enumerate

@end enumerate

@item
Else@comma{} the most significant bit in B is 1
@enumerate
@item
Let n be the smallest non-negative number such that (B << n) & 0x80 is equal to 0.
@item
If n equals 1 or n is greater than 4@comma{} throw a URIError exception.
@item
Let Octets be an array of 8-bit integers of size n.
@item
Put B into Octets at position 0.
@item
If k + (3 × (n − 1)) is greater than or equal to strLen@comma{} throw a URIError exception.
@item
Let j be 1.
@item
Repeat@comma{} while j < n
@enumerate
@item
Increment k by 1.
@item
If the character at position k is not ‘@code{%}’@comma{} throw a URIError exception.
@item
If the characters at position (k + 1) and (k + 2) within string do not represent hexadecimal digits@comma{} throw a URIError exception.
@item
Let B be the 8-bit value represented by the two hexadecimal digits at position (k + 1) and (k + 2).
@item
If the two most significant bits in B are not 10@comma{} throw a URIError exception.
@item
Increment k by 2.
@item
Put B into Octets at position j.
@item
Increment j by 1.
@end enumerate

@item
Let V be the value obtained by applying the UTF-8 transformation to Octets@comma{} that is@comma{} from an array of octets into a 32-bit value. If Octets does not contain a valid UTF-8 encoding of a Unicode code point throw a URIError exception.
@item
If V is less than 0x10000@comma{} then
@enumerate
@item
Let C be the character with code unit value V.
@item
If C is not in reservedSet@comma{} then
@enumerate
@item
Let S be the String containing only the character C.
@end enumerate

@item
Else@comma{} C is in reservedSet
@enumerate
@item
Let S be the substring of string from position start to position k included.
@end enumerate

@end enumerate

@item
Else@comma{} V is ≥ 0x10000
@enumerate
@item
If V is greater than 0x10FFFF@comma{} throw a URIError exception.
@item
Let L be (((V − 0x10000) & 0x3FF) + 0xDC00).
@item
Let H be ((((V − 0x10000) >> 10) & 0x3FF) + 0xD800).
@item
Let S be the String containing the two characters with code unit values H and L.
@end enumerate

@end enumerate

@end enumerate

@item

@item
Increase k by 1.
@end enumerate

@end enumerate

NOTE The syntax of Uniform Resource Identifiers is given in RFC 2396. A formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8@comma{} characters are encoded using sequences of 1 to 6 octets. The only octet of a “sequence” of one has the higher-order bit set to 0@comma{} the remaining 7 bits being used to encode the character value. In a sequence of n octets@comma{} n>1@comma{} the initial octet has the n higher-order bits set to 1@comma{} followed by a bit set to 0. The remaining bits of that octet contain bits from the value of the character to be encoded. The following octets all have the higher-order bit set to 1 and the following bit set to 0@comma{} leaving 6 bits in each to contain bits from the character to be encoded. The possible UTF-8 encodings of ECMAScript characters are specified in Table 21.

Table 21 — UTF-8 Encodings
Code Unit Value
Representation
1st Octet
2nd Octet
3rd Octet
4th Octet
@strong{0x0000 - 0x007F}
@strong{00000000} @code{0}zzzzzzz
@code{0}zzzzzzz
@strong{0x0080 - 0x07FF}
@strong{00000}yyy yyzzzzzz
@strong{110}yyyyy
@strong{10}zzzzzz
@strong{0x0800 - 0xD7FF}
xxxxyyyy yyzzzzzz
@strong{1110}xxxx
@strong{10}yyyyyy
@strong{10}zzzzzz
@strong{0xD800 - 0xDBFF} @emph{followed by} @strong{0xDC00 - 0xDFFF}
@strong{110110}vv vvwwwwxx @emph{followed by} @strong{110111}yy yyzzzzzz
@strong{11110}uuu
@strong{10}uuwwww
@strong{10}xxyyyy
@strong{10}zzzzzz
@strong{0xD800 - 0xDBFF} @emph{not followed by} @strong{0xDC00 - 0xDFFF}
@emph{causes} URIError
@strong{0xDC00 - 0xDFFF}
@emph{causes} URIError
@strong{0xE000 - 0xFFFF}
xxxxyyyy yyzzzzzz
@strong{1110}xxxx
@strong{10}yyyyyy
@strong{10}zzzzzz
Where

uuuuu = vvvv + 1
to account for the addition of 0x10000 as in Surrogates@comma{} section 3.7@comma{} of the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate pairs; the above transformation combines a UTF-16 surrogate pair into a UTF-32 representation and encodes the resulting 21-bit value in UTF-8. Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example@comma{} the invalid sequence C0 80 must not decode into the character U+0000. Implementations of the Decode algorithm are required to throw a URIError when encountering such invalid sequences.


@node 15131 decodeURI encodedURI
@chapter @uref{#sec-15.1.3.1,15.1.3.1} decodeURI (encodedURI)
The decodeURI function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the encodeURI function is replaced with the character that it represents. Escape sequences that could not have been introduced by encodeURI are not replaced.

When the decodeURI function is called with one argument encodedURI@comma{} the following steps are taken:

@enumerate
@item
Let uriString be @uref{#sec-9.8,ToString}(encodedURI).
@item
Let reservedURISet be a String containing one instance of each character valid in uriReserved plus "#".
@item
Return the result of calling Decode(uriString@comma{} reservedURISet)
@end enumerate

NOTE The character “@code{#}” is not decoded from escape sequences even though it is not a reserved URI character.



@node 15132 decodeURIComponent encodedURIComponent
@chapter @uref{#sec-15.1.3.2,15.1.3.2} decodeURIComponent (encodedURIComponent)
The decodeURIComponent function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the encodeURIComponent function is replaced with the character that it represents.

When the decodeURIComponent function is called with one argument encodedURIComponent@comma{} the following steps are taken:

@enumerate
@item
Let componentString be @uref{#sec-9.8,ToString}(encodedURIComponent).
@item
Let reservedURIComponentSet be the empty String.
@item
Return the result of calling Decode(componentString@comma{} reservedURIComponentSet)
@end enumerate


@node 15133 encodeURI uri
@chapter @uref{#sec-15.1.3.3,15.1.3.3} encodeURI (uri)
The encodeURI function computes a new version of a URI in which each instance of certain characters is replaced by one@comma{} two or three escape sequences representing the UTF-8 encoding of the character.

When the encodeURI function is called with one argument uri@comma{} the following steps are taken:

@enumerate
@item
Let uriString be @uref{#sec-9.8,ToString}(uri).
@item
Let unescapedURISet be a String containing one instance of each character valid in uriReserved and uriUnescaped plus "#".
@item
Return the result of calling Encode(uriString@comma{} unescapedURISet)
@end enumerate

NOTE The character “@code{#}” is not encoded to an escape sequence even though it is not a reserved or unescaped URI character.


@node 15134 encodeURIComponent uriComponent
@chapter @uref{#sec-15.1.3.4,15.1.3.4} encodeURIComponent (uriComponent)
The encodeURIComponent function computes a new version of a URI in which each instance of certain characters is replaced by one@comma{} two or three escape sequences representing the UTF-8 encoding of the character.

When the encodeURIComponent function is called with one argument uriComponent@comma{} the following steps are taken:

@enumerate
@item
Let componentString be @uref{#sec-9.8,ToString}(uriComponent).
@item
Let unescapedURIComponentSet be a String containing one instance of each character valid in uriUnescaped.
@item
Return the result of calling Encode(componentString@comma{} unescapedURIComponentSet)
@end enumerate


@node 1514 Constructor Properties of the Global Object
@chapter @uref{#sec-15.1.4,15.1.4} Constructor Properties of the Global Object

@node 15141 Object
@chapter @uref{#sec-15.1.4.1,15.1.4.1} Object ( . . . )
@uref{#sec-15.2.1,See 15.2.1} and @uref{#sec-15.2.2,15.2.2}.


@node 15142 Function
@chapter @uref{#sec-15.1.4.2,15.1.4.2} Function ( . . . )
@uref{#sec-15.3.1,See 15.3.1} and @uref{#sec-15.3.2,15.3.2}.


@node 15143 Array
@chapter @uref{#sec-15.1.4.3,15.1.4.3} Array ( . . . )
@uref{#sec-15.4.1,See 15.4.1} and @uref{#sec-15.4.2,15.4.2}.



@node 15144 String
@chapter @uref{#sec-15.1.4.4,15.1.4.4} String ( . . . )
@uref{#sec-15.5.1,See 15.5.1} and @uref{#sec-15.5.2,15.5.2}.


@node 15145 Boolean
@chapter @uref{#sec-15.1.4.5,15.1.4.5} Boolean ( . . . )
@uref{#sec-15.6.1,See 15.6.1} and @uref{#sec-15.6.2,15.6.2}.


@node 15146 Number
@chapter @uref{#sec-15.1.4.6,15.1.4.6} Number ( . . . )
@uref{#sec-15.7.1,See 15.7.1} and @uref{#sec-15.7.2,15.7.2}.


@node 15147 Date
@chapter @uref{#sec-15.1.4.7,15.1.4.7} Date ( . . . )
@uref{#sec-15.9.2,See 15.9.2}.


@node 15148 RegExp
@chapter @uref{#sec-15.1.4.8,15.1.4.8} RegExp ( . . . )
@uref{#sec-15.10.3,See 15.10.3} and @uref{#sec-15.10.4,15.10.4}.


@node 15149 Error
@chapter @uref{#sec-15.1.4.9,15.1.4.9} Error ( . . . )
@uref{#sec-15.11.1,See 15.11.1} and @uref{#sec-15.11.2,15.11.2}.


@node 151410 EvalError
@chapter @uref{#sec-15.1.4.10,15.1.4.10} EvalError ( . . . )
@uref{#sec-15.11.6.1,See 15.11.6.1}.


@node 151411 RangeError
@chapter @uref{#sec-15.1.4.11,15.1.4.11} RangeError ( . . . )
@uref{#sec-15.11.6.2,See 15.11.6.2}.


@node 151412 ReferenceError
@chapter @uref{#sec-15.1.4.12,15.1.4.12} ReferenceError ( . . . )
@uref{#sec-15.11.6.3,See 15.11.6.3}.


@node 151413 SyntaxError
@chapter @uref{#sec-15.1.4.13,15.1.4.13} SyntaxError ( . . . )
@uref{#sec-15.11.6.4,See 15.11.6.4}.


@node 151414 TypeError
@chapter @uref{#sec-15.1.4.14,15.1.4.14} TypeError ( . . . )
@uref{#sec-15.11.6.5,See 15.11.6.5}.


@node 151415 URIError
@chapter @uref{#sec-15.1.4.15,15.1.4.15} URIError ( . . . )
@uref{#sec-15.11.6.6,See 15.11.6.6}.


@node 1515 Other Properties of the Global Object
@chapter @uref{#sec-15.1.5,15.1.5} Other Properties of the Global Object

@node 15151 Math
@chapter @uref{#sec-15.1.5.1,15.1.5.1} Math
@uref{#sec-15.8,See 15.8}.



@node 15152 JSON
@chapter @uref{#sec-15.1.5.2,15.1.5.2} JSON
@uref{#sec-15.12,See 15.12}.


@node 152 Object Objects
@chapter @uref{#sec-15.2,15.2} Object Objects

@node 1521 The Object Constructor Called as a Function
@chapter @uref{#sec-15.2.1,15.2.1} The Object Constructor Called as a Function
When Object is called as a function rather than as a constructor@comma{} it performs a type conversion.


@node 15211 Object  [ value ]
@chapter @uref{#sec-15.2.1.1,15.2.1.1} Object ( [ value ] )
When the Object function is called with no arguments or with one argument value@comma{} the following steps are taken:

@enumerate
@item
If value is null@comma{} undefined or not supplied@comma{} create and return a new Object object exactly as if the standard built-in Object constructor had been called with the same arguments (@uref{#sec-15.2.2.1,15.2.2.1}).
@item
Return @uref{#sec-9.9,ToObject}(value).
@end enumerate


@node 1522 The Object Constructor
@chapter @uref{#sec-15.2.2,15.2.2} The Object Constructor
When Object is called as part of a @code{new} expression@comma{} it is a constructor that may create an object.


@node 15221 new Object  [ value ]
@chapter @uref{#sec-15.2.2.1,15.2.2.1} new Object ( [ value ] )
When the Object constructor is called with no arguments or with one argument value@comma{} the following steps are taken:

@enumerate
@item
If value is supplied@comma{} then
@enumerate
@item
If @uref{#def-type,Type}(value) is Object@comma{} then
@enumerate
@item
If the value is a native ECMAScript object@comma{} do not create a new object but simply return value.
@item
If the value is a host object@comma{} then actions are taken and a result is returned in an implementation-dependent manner that may depend on the host object.
@end enumerate

@item
If @uref{#def-type,Type}(value) is String@comma{} return @uref{#sec-9.9,ToObject}(value).
@item
If @uref{#def-type,Type}(value) is Boolean@comma{} return @uref{#sec-9.9,ToObject}(value).
@item
If @uref{#def-type,Type}(value) is Number@comma{} return @uref{#sec-9.9,ToObject}(value).
@end enumerate

@item
Assert: The argument value was not supplied or its type was Null or Undefined.
@item
Let obj be a newly created native ECMAScript object.
@item
Set the [[Prototype]] internal property of obj t to the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).
@item
Set the [[Class]] internal property of obj to "Object".
@item
Set the [[Extensible]] internal property of obj to true.
@item
Set the all the internal methods of obj as specified in @uref{#sec-8.12,8.12}.
@item
Return obj.
@end enumerate


@node 1523 Properties of the Object Constructor
@chapter @uref{#sec-15.2.3,15.2.3} Properties of the Object Constructor
The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} the Object constructor has the following properties:


@node 15231 Objectprototype
@chapter @uref{#sec-15.2.3.1,15.2.3.1} Object.prototype
The initial value of Object.prototype is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).




@node 15232 ObjectgetPrototypeOf  O
@chapter @uref{#sec-15.2.3.2,15.2.3.2} Object.getPrototypeOf ( O )
When the getPrototypeOf function is called with argument O@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Return the value of the [[Prototype]] internal property of O.
@end enumerate


@node 15233 ObjectgetOwnPropertyDescriptor  O P
@chapter @uref{#sec-15.2.3.3,15.2.3.3} Object.getOwnPropertyDescriptor ( O@comma{} P )
When the getOwnPropertyDescriptor function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Let name be @uref{#sec-9.8,ToString}(P).
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with argument name.
@item
Return the result of calling @uref{#sec-8.10.4,FromPropertyDescriptor}(desc) (@uref{#sec-8.10.4,8.10.4}).
@end enumerate


@node 15234 ObjectgetOwnPropertyNames  O
@chapter @uref{#sec-15.2.3.4,15.2.3.4} Object.getOwnPropertyNames ( O )
When the getOwnPropertyNames function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Let array be the result of creating a new object as if by the expression @code{new Array ()} where @code{Array} is the standard built-in constructor with that name.
@item
Let n be 0.
@item
For each named own property P of O
@enumerate
@item
Let name be the String value that is the name of P.
@item
Call the [[DefineOwnProperty]] internal method of array with arguments @uref{#sec-9.8,ToString}(n)@comma{} the PropertyDescriptor @{[[Value]]: name@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Increment n by 1.
@end enumerate

@item
Return array.
@end enumerate

NOTE If O is a String instance@comma{} the set of own properties processed in step 4 includes the implicit properties defined in @uref{#sec-15.5.5.2,15.5.5.2} that correspond to character positions within the object’s [[PrimitiveValue]] String.


@node 15235 Objectcreate  O [ Properties]
@chapter @uref{#sec-15.2.3.5,15.2.3.5} Object.create ( O [@comma{} Properties] )
The create function creates a new object with a specified prototype. When the create function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object or Null throw a TypeError exception.
@item
Let obj be the result of creating a new object as if by the expression @code{new Object()} where @code{Object} is the standard built-in constructor with that name
@item
Set the [[Prototype]] internal property of obj to O.
@item
If the argument Properties is present and not undefined@comma{} add own properties to obj as if by calling the standard built-in function @uref{#sec-15.2.3.7,Object.defineProperties} with arguments obj and Properties.
@item
Return obj.
@end enumerate


@node 15236 ObjectdefineProperty  O P Attributes
@chapter @uref{#sec-15.2.3.6,15.2.3.6} Object.defineProperty ( O@comma{} P@comma{} Attributes )
The defineProperty function is used to add an own property and/or update the attributes of an existing own property of an object. When the defineProperty function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Let name be @uref{#sec-9.8,ToString}(P).
@item
Let desc be the result of calling ToPropertyDescriptor with Attributes as the argument.
@item
Call the [[DefineOwnProperty]] internal method of O with arguments name@comma{} desc@comma{} and true.
@item
Return O.
@end enumerate


@node 15237 ObjectdefineProperties  O Properties
@chapter @uref{#sec-15.2.3.7,15.2.3.7} Object.defineProperties ( O@comma{} Properties )
The defineProperties function is used to add own properties and/or update the attributes of existing own properties of an object. When the defineProperties function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Let props be @uref{#sec-9.9,ToObject}(Properties).
@item
Let names be an internal list containing the names of each enumerable own property of props.
@item
Let descriptors be an empty internal @uref{#sec-8.8,List}.
@item
For each element P of names in list order@comma{}
@enumerate
@item
Let descObj be the result of calling the [[Get]] internal method of props with P as the argument.
@item
Let desc be the result of calling ToPropertyDescriptor with descObj as the argument.
@item
Append the pair (a two element @uref{#sec-8.8,List}) consisting of P and desc to the end of descriptors.
@end enumerate

@item
For each element pair from descriptors in list order@comma{}
@enumerate
@item
Let P be the first element of pair.
@item
Let desc be the second element of pair.
@item
Call the [[DefineOwnProperty]] internal method of O with arguments P@comma{} desc@comma{} and true.
@end enumerate

@item
Return O.
@end enumerate

If an implementation defines a specific order of enumeration for the for-in statement@comma{} that same enumeration order must be used to order the list elements in step 3 of this algorithm.


@node 15238 Objectseal  O
@chapter @uref{#sec-15.2.3.8,15.2.3.8} Object.seal ( O )
When the seal function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
For each named own property name P of O@comma{}
@enumerate
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P.
@item
If desc.[[Configurable]] is true@comma{} set desc.[[Configurable]] to false.
@item
Call the [[DefineOwnProperty]] internal method of O with P@comma{} desc@comma{} and true as arguments.
@end enumerate

@item
Set the [[Extensible]] internal property of O to false.
@item
Return O.
@end enumerate


@node 15239 Objectfreeze  O
@chapter @uref{#sec-15.2.3.9,15.2.3.9} Object.freeze ( O )
When the freeze function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
For each named own property name P of O@comma{}
@enumerate
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(desc) is true@comma{} then
@enumerate
@item
If desc.[[Writable]] is true@comma{} set desc.[[Writable]] to false.
@end enumerate

@item
If desc.[[Configurable]] is true@comma{} set desc.[[Configurable]] to false.
@item
Call the [[DefineOwnProperty]] internal method of O with P@comma{} desc@comma{} and true as arguments.
@end enumerate

@item
Set the [[Extensible]] internal property of O to false.
@item
Return O.
@end enumerate


@node 152310 ObjectpreventExtensions  O
@chapter @uref{#sec-15.2.3.10,15.2.3.10} Object.preventExtensions ( O )
When the preventExtensions function is called@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Set the [[Extensible]] internal property of O to false.
@item
Return O.
@end enumerate


@node 152311 ObjectisSealed  O
@chapter @uref{#sec-15.2.3.11,15.2.3.11} Object.isSealed ( O )
When the isSealed function is called with argument O@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
For each named own property name P of O@comma{}
@enumerate
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P.
@item
If desc.[[Configurable]] is true@comma{} then return false.
@end enumerate

@item
If the [[Extensible]] internal property of O is false@comma{} then return true.
@item
Otherwise@comma{} return false.
@end enumerate


@node 152312 ObjectisFrozen  O
@chapter @uref{#sec-15.2.3.12,15.2.3.12} Object.isFrozen ( O )
When the isFrozen function is called with argument O@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
For each named own property name P of O@comma{}
@enumerate
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P.
@item
If @uref{#def-IsDataDescriptor,IsDataDescriptor}(desc) is true then
@enumerate
@item
If desc.[[Writable]] is true@comma{} return false.
@end enumerate

@item
If desc.[[Configurable]] is true@comma{} then return false.
@end enumerate

@item
If the [[Extensible]] internal property of O is false@comma{} then return true.
@item
Otherwise@comma{} return false.
@end enumerate


@node 152313 ObjectisExtensible  O
@chapter @uref{#sec-15.2.3.13,15.2.3.13} Object.isExtensible ( O )
When the isExtensible function is called with argument O@comma{} the following steps are taken:

@enumerate
@item
If @uref{#def-type,Type}(O) is not Object throw a TypeError exception.
@item
Return the Boolean value of the [[Extensible]] internal property of O.
@end enumerate


@node 152314 Objectkeys  O
@chapter @uref{#sec-15.2.3.14,15.2.3.14} Object.keys ( O )
When the keys function is called with argument O@comma{} the following steps are taken:

@enumerate
@item
If the @uref{#def-type,Type}(O) is not Object@comma{} throw a TypeError exception.
@item
Let n be the number of own enumerable properties of O
@item
Let array be the result of creating a new Object as if by the expression @code{new Array(<var>n</var>)} where @code{Array} is the standard built-in constructor with that name.
@item
Let index be 0.
@item
For each own enumerable property of O whose name String is P
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of array with arguments @uref{#sec-9.8,ToString}(index)@comma{} the PropertyDescriptor @{[[Value]]: P@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Increment index by 1.
@end enumerate

@item
Return array.
@end enumerate

If an implementation defines a specific order of enumeration for the for-in statement@comma{} that same enumeration order must be used in step 5 of this algorithm.


@node 1524 Properties of the Object Prototype Object
@chapter @uref{#sec-15.2.4,15.2.4} Properties of the Object Prototype Object
The value of the [[Prototype]] internal property of the Object prototype object is null@comma{} the value of the [[Class]] internal property is "Object"@comma{} and the initial value of the [[Extensible]] internal property is true.


@node 15241 Objectprototypeconstructor
@chapter @uref{#sec-15.2.4.1,15.2.4.1} Object.prototype.constructor
The initial value of Object.prototype.constructor is the standard built-in Object constructor.


@node 15242 ObjectprototypetoString
@chapter @uref{#sec-15.2.4.2,15.2.4.2} Object.prototype.toString ( )
When the toString method is called@comma{} the following steps are taken:

@enumerate
@item
If the this value is undefined@comma{} return "[object Undefined]".
@item
If the this value is null@comma{} return "[object Null]".
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let class be the value of the [[Class]] internal property of O.
@item
Return the String value that is the result of concatenating the three Strings "[object "@comma{} class@comma{} and "]".
@end enumerate


@node 15243 ObjectprototypetoLocaleString
@chapter @uref{#sec-15.2.4.3,15.2.4.3} Object.prototype.toLocaleString ( )
When the toLocaleString method is called@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let toString be the result of calling the [[Get]] internal method of O passing "toString" as the argument.
@item
If @uref{#sec-9.11,IsCallable}(toString) is false@comma{} throw a TypeError exception.
@item
Return the result of calling the [[Call]] internal method of toString passing O as the this value and no arguments.
@end enumerate

NOTE 1 This function is provided to give all Objects a generic toLocaleString interface@comma{} even though not all may use it. Currently@comma{} @uref{#sec-15.4.4.3,Array}@comma{} @uref{#sec-15.7.4.3,Number}@comma{} and @uref{#sec-15.9.5.5,Date} provide their own locale-sensitive toLocaleString methods.

NOTE 2 The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.


@node 15244 ObjectprototypevalueOf
@chapter @uref{#sec-15.2.4.4,15.2.4.4} Object.prototype.valueOf ( )
When the valueOf method is called@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
If O is the result of calling the Object constructor with a host object (@uref{#sec-15.2.2.1,15.2.2.1})@comma{} then
@enumerate
@item
Return either O or another value such as the host object originally passed to the constructor. The specific result that is returned is implementation-defined.
@end enumerate

@item
Return O.
@end enumerate


@node 15245 ObjectprototypehasOwnProperty V
@chapter @uref{#sec-15.2.4.5,15.2.4.5} Object.prototype.hasOwnProperty (V)
When the hasOwnProperty method is called with argument V@comma{} the following steps are taken:

@enumerate
@item
Let P be @uref{#sec-9.8,ToString}(V).
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O passing P as the argument.
@item
If desc is undefined@comma{} return false.
@item
Return true.
@end enumerate

NOTE 1 Unlike [[HasProperty]] (@uref{#sec-8.12.6,8.12.6})@comma{} this method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in previous editions of this specification will continue to be thrown even if the this value is undefined or null.


@node 15246 ObjectprototypeisPrototypeOf V
@chapter @uref{#sec-15.2.4.6,15.2.4.6} Object.prototype.isPrototypeOf (V)
When the isPrototypeOf method is called with argument V@comma{} the following steps are taken:

@enumerate
@item
If V is not an object@comma{} return false.
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Repeat
@enumerate
@item
Let V be the value of the [[Prototype]] internal property of V.
@item
if V is null@comma{} return false
@item
If O and V refer to the same object@comma{} return true.
@end enumerate

@end enumerate

NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour specified by previous editions of this specification for the case where V is not an object and the this value is undefined or null.



@node 15247 ObjectprototypepropertyIsEnumerable V
@chapter @uref{#sec-15.2.4.7,15.2.4.7} Object.prototype.propertyIsEnumerable (V)
When the propertyIsEnumerable method is called with argument V@comma{} the following steps are taken:

@enumerate
@item
Let P be @uref{#sec-9.8,ToString}(V).
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let desc be the result of calling the [[GetOwnProperty]] internal method of O passing P as the argument.
@item
If desc is undefined@comma{} return false.
@item
Return the value of desc.[[Enumerable]].
@end enumerate

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in previous editions of this specification will continue to be thrown even if the this value is undefined or null.


@node 1525 Properties of Object Instances
@chapter @uref{#sec-15.2.5,15.2.5} Properties of Object Instances
Object instances have no special properties beyond those inherited from the Object prototype object.


@node 153 Function Objects
@chapter @uref{#sec-15.3,15.3} Function Objects

@node 1531 The Function Constructor Called as a Function
@chapter @uref{#sec-15.3.1,15.3.1} The Function Constructor Called as a Function
When Function is called as a function rather than as a constructor@comma{} it creates and initialises a new Function object. Thus the function call @code{Function(<var>...</var>)} is equivalent to the object creation expression @code{new Function(<var>...</var>)} with the same arguments.


@node 15311 Function p1 p2   pn body
@chapter @uref{#sec-15.3.1.1,15.3.1.1} Function (p1@comma{} p2@comma{} ... @comma{} pn@comma{} body)
When the Function function is called with some arguments p1@comma{} p2@comma{} ... @comma{} pn@comma{} body (where n might be 0@comma{} that is@comma{} there are no “p” arguments@comma{} and where body might also not be provided)@comma{} the following steps are taken:

@enumerate
@item
Create and return a new Function object as if the standard built-in constructor Function was used in a @code{new} expression with the same arguments (@uref{#sec-15.3.2.1,15.3.2.1}).
@end enumerate


@node 1532 The Function Constructor
@chapter @uref{#sec-15.3.2,15.3.2} The Function Constructor
When Function is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 15321 new Function p1 p2   pn body
@chapter @uref{#sec-15.3.2.1,15.3.2.1} new Function (p1@comma{} p2@comma{} ... @comma{} pn@comma{} body)
The last argument specifies the body (executable code) of a function; any preceding arguments specify formal parameters.

When the Function constructor is called with some arguments p1@comma{} p2@comma{} ... @comma{} pn@comma{} body (where n might be 0@comma{} that is@comma{} there are no “p” arguments@comma{} and where body might also not be provided)@comma{} the following steps are taken:

@enumerate
@item
Let argCount be the total number of arguments passed to this function invocation.
@item
Let P be the empty String.
@item
If argCount = 0@comma{} let body be the empty String.
@item
Else if argCount = 1@comma{} let body be that argument.
@item
Else@comma{} argCount > 1
@enumerate
@item
Let firstArg be the first argument.
@item
Let P be @uref{#sec-9.8,ToString}(firstArg).
@item
Let k be 2.
@item
Repeat@comma{} while k < argCount
@enumerate
@item
Let nextArg be the kth argument.
@item
Let P be the result of concatenating the previous value of P@comma{} the String "@comma{}" (a comma)@comma{} and @uref{#sec-9.8,ToString}(nextArg).
@item
Increase k by 1.
@end enumerate

@item
Let body be the kth argument.
@end enumerate

@item
Let body be @uref{#sec-9.8,ToString}(body).
@item
If P is not parsable as a FormalParameterList_opt_ then throw a SyntaxError exception.
@item
If body is not parsable as FunctionBody then throw a SyntaxError exception.
@item
If body is @uref{#sec-10.1.1,strict mode code (see 10.1.1)} then let strict be true@comma{} else let strict be false.
@item
If strict is true@comma{} throw any exceptions specified in @uref{#sec-13.1,13.1} that apply.
@item
Return a new Function object created as specified in @uref{#sec-13.2,13.2} passing P as the FormalParameterList and body as the FunctionBody. Pass in the @uref{#sec-10.2.3,Global Environment} as the Scope parameter and strict as the Strict flag.
@end enumerate

A @code{prototype} property is automatically created for every function@comma{} to provide for the possibility that the function will be used as a constructor.

NOTE It is permissible but not necessary to have one argument for each formal parameter to be specified. For example@comma{} all three of the following expressions produce the same result:
@verbatim
new Function("a", "b", "c", "return a+b+c")
@end verbatim

@verbatim
new Function("a, b, c", "return a+b+c")
@end verbatim

@verbatim
new Function("a,b", "c", "return a+b+c")
@end verbatim


@node 1533 Properties of the Function Constructor
@chapter @uref{#sec-15.3.3,15.3.3} Properties of the Function Constructor
The Function constructor is itself a Function object and its [[Class]] is "Function". The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object (@uref{#sec-15.3.4,15.3.4}).

The value of the [[Extensible]] internal property of the Function constructor is true.

The Function constructor has the following properties:


@node 15331 Functionprototype
@chapter @uref{#sec-15.3.3.1,15.3.3.1} Function.prototype
The initial value of Function.prototype is the standard built-in Function prototype object (@uref{#sec-15.3.4,15.3.4}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15332 Functionlength
@chapter @uref{#sec-15.3.3.2,15.3.3.2} Function.length
This is a data property with a value of 1. This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 1534 Properties of the Function Prototype Object
@chapter @uref{#sec-15.3.4,15.3.4} Properties of the Function Prototype Object
The Function prototype object is itself a Function object (its [[Class]] is "Function") that@comma{} when invoked@comma{} accepts any arguments and returns undefined.

The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}). The initial value of the [[Extensible]] internal property of the Function prototype object is true.

The Function prototype object does not have a @code{valueOf} property of its own; however@comma{} it inherits the @code{valueOf} property from the Object prototype Object.

The @code{length} property of the Function prototype object is 0.



@node 15341 Functionprototypeconstructor
@chapter @uref{#sec-15.3.4.1,15.3.4.1} Function.prototype.constructor
The initial value of Function.prototype.constructor is the built-in Function constructor.


@node 15342 FunctionprototypetoString
@chapter @uref{#sec-15.3.4.2,15.3.4.2} Function.prototype.toString ( )
An implementation-dependent representation of the function is returned. This representation has the syntax of a FunctionDeclaration. Note in particular that the use and placement of white space@comma{} line terminators@comma{} and semicolons within the representation String is implementation-dependent.

The toString function is not generic; it throws a TypeError exception if its this value is not a Function object. Therefore@comma{} it cannot be transferred to other kinds of objects for use as a method.


@node 15343 Functionprototypeapply thisArg argArray
@chapter @uref{#sec-15.3.4.3,15.3.4.3} Function.prototype.apply (thisArg@comma{} argArray)
When the apply method is called on an object func with arguments thisArg and argArray@comma{} the following steps are taken:

@enumerate
@item
If @uref{#sec-9.11,IsCallable}(func) is false@comma{} then throw a TypeError exception.
@item
If argArray is null or undefined@comma{} then
@enumerate
@item
Return the result of calling the [[Call]] internal method of func@comma{} providing thisArg as the this value and an empty list of arguments.
@end enumerate

@item
If @uref{#def-type,Type}(argArray) is not Object@comma{} then throw a TypeError exception.
@item
Let len be the result of calling the [[Get]] internal method of argArray with argument "length".
@item
Let n be @uref{#sec-9.6,ToUint32}(len).
@item
Let argList be an empty @uref{#sec-8.8,List}.
@item
Let index be 0.
@item
Repeat while index < n
@enumerate
@item
Let indexName be @uref{#sec-9.8,ToString}(index).
@item
Let nextArg be the result of calling the [[Get]] internal method of argArray with indexName as the argument.
@item
Append nextArg as the last element of argList.
@item
Set index to index + 1.
@end enumerate

@item
Return the result of calling the [[Call]] internal method of func@comma{} providing thisArg as the this value and argList as the list of arguments.
@end enumerate

The @code{length} property of the apply method is 2.

NOTE The thisArg value is passed without modification as the this value. This is a change from Edition 3@comma{} where a undefined or null thisArg is replaced with the global object and @uref{#sec-9.9,ToObject} is applied to all other values and that result is passed as the this value.


@node 15344 Functionprototypecall thisArg [  arg1 [  arg2  ] ]
@chapter @uref{#sec-15.3.4.4,15.3.4.4} Function.prototype.call (thisArg [ @comma{} arg1 [ @comma{} arg2@comma{} ... ] ] )
When the call method is called on an object func with argument thisArg and optional arguments arg1@comma{} arg2 etc@comma{} the following steps are taken:

@enumerate
@item
If @uref{#sec-9.11,IsCallable}(func) is false@comma{} then throw a TypeError exception.
@item
Let argList be an empty @uref{#sec-8.8,List}.
@item
If this method was called with more than one argument then in left to right order starting with arg1 append each argument as the last element of argList
@item
Return the result of calling the [[Call]] internal method of func@comma{} providing thisArg as the this value and argList as the list of arguments.
@end enumerate

The @code{length} property of the call method is 1.


NOTE The thisArg value is passed without modification as the this value. This is a change from Edition 3@comma{} where a undefined or null thisArg is replaced with the global object and @uref{#sec-9.9,ToObject} is applied to all other values and that result is passed as the this value.


@node 15345 Functionprototypebind thisArg [ arg1 [ arg2 ]]
@chapter @uref{#sec-15.3.4.5,15.3.4.5} Function.prototype.bind (thisArg [@comma{} arg1 [@comma{} arg2@comma{} ...]])
The bind method takes one or more arguments@comma{} thisArg and (optionally) arg1@comma{} arg2@comma{} etc@comma{} and returns a new function object by performing the following steps:

@enumerate
@item
Let Target be the this value.
@item
If @uref{#sec-9.11,IsCallable}(Target) is false@comma{} throw a TypeError exception.
@item
Let A be a new (possibly empty) internal list of all of the argument values provided after thisArg (arg1@comma{} arg2 etc)@comma{} in order.
@item
Let F be a new native ECMAScript object .
@item
Set all the internal methods@comma{} except for [[Get]]@comma{} of F as specified in @uref{#sec-8.12,8.12}.
@item
Set the [[Get]] internal property of F as specified in @uref{#sec-15.3.5.4,15.3.5.4}.
@item
Set the [[TargetFunction]] internal property of F to Target.
@item
Set the [[BoundThis]] internal property of F to the value of thisArg.
@item
Set the [[BoundArgs]] internal property of F to A.
@item
Set the [[Class]] internal property of F to "Function".
@item
Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in @uref{#sec-15.3.3.1,15.3.3.1}.
@item
Set the [[Call]] internal property of F as described in @uref{#sec-15.3.4.5.1,15.3.4.5.1}.
@item
Set the [[Construct]] internal property of F as described in @uref{#sec-15.3.4.5.2,15.3.4.5.2}.
@item
Set the [[HasInstance]] internal property of F as described in @uref{#sec-15.3.4.5.3,15.3.4.5.3}.
@item
If the [[Class]] internal property of Target is "Function"@comma{} then
@enumerate
@item
Let L be the @code{length} property of Target minus the length of A.
@item
Set the @code{length} own property of F to either 0 or L@comma{} whichever is larger.
@end enumerate

@item
Else set the @code{length} own property of F to 0.
@item
Set the attributes of the @code{length} own property of F to the values specified in @uref{#sec-15.3.5.1,15.3.5.1}.
@item
Set the [[Extensible]] internal property of F to true.
@item
Let thrower be the [[ThrowTypeError]] function Object (@uref{#sec-13.2.3,13.2.3}).
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "caller"@comma{} PropertyDescriptor @{[[Get]]: thrower@comma{} [[Set]]: thrower@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
Call the [[DefineOwnProperty]] internal method of F with arguments "arguments"@comma{} PropertyDescriptor @{[[Get]]: thrower@comma{} [[Set]]: thrower@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false@}@comma{} and false.
@item
Return F.
@end enumerate

The @code{length} property of the bind method is 1.

NOTE Function objects created using Function.prototype.bind do not have a @code{prototype} property or the [[Code]]@comma{} [[FormalParameters]]@comma{} and [[Scope]] internal properties.


@node 153451 [[Call]]
@chapter @uref{#sec-15.3.4.5.1,15.3.4.5.1} [[Call]]
When the [[Call]] internal method of a function object@comma{} F@comma{} which was created using the bind function is called with a this value and a list of arguments ExtraArgs@comma{} the following steps are taken:

@enumerate
@item
Let boundArgs be the value of F’s [[BoundArgs]] internal property.
@item
Let boundThis be the value of F’s [[BoundThis]] internal property.
@item
Let target be the value of F’s [[TargetFunction]] internal property.
@item
Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values as the list ExtraArgs in the same order.
@item
Return the result of calling the [[Call]] internal method of target providing boundThis as the this value and providing args as the arguments.
@end enumerate


@node 153452 [[Construct]]
@chapter @uref{#sec-15.3.4.5.2,15.3.4.5.2} [[Construct]]
When the [[Construct]] internal method of a function object@comma{} F that was created using the bind function is called with a list of arguments ExtraArgs@comma{} the following steps are taken:

@enumerate
@item

@item
If target has no [[Construct]] internal method@comma{} a TypeError exception is thrown.
@item
Let boundArgs be the value of F’s [[BoundArgs]] internal property.
@item
Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values as the list ExtraArgs in the same order.
@item
Return the result of calling the [[Construct]] internal method of target providing args as the arguments.
@end enumerate


@node 153453 [[HasInstance]] V
@chapter @uref{#sec-15.3.4.5.3,15.3.4.5.3} [[HasInstance]] (V)
When the [[HasInstance]] internal method of a function object F@comma{} that was created using the bind function is called with argument V@comma{} the following steps are taken:

@enumerate
@item
Let target be the value of F’s [[TargetFunction]] internal property.
@item
If target has no [[HasInstance]] internal method@comma{} a TypeError exception is thrown.
@item
Return the result of calling the [[HasInstance]] internal method of target providing V as the argument.
@end enumerate


@node 1535 Properties of Function Instances
@chapter @uref{#sec-15.3.5,15.3.5} Properties of Function Instances
In addition to the required internal properties@comma{} every function instance has a [[Call]] internal property and in most cases use a different version of the [[Get]] internal property. Depending on how they are created (@uref{#sec-8.6.2,see 8.6.2} @comma{}@uref{#sec-13.2,13.2}@comma{} @uref{#sec-15,15}@comma{} and @uref{#sec-15.3.4.5,15.3.4.5})@comma{} function instances may have a [[HasInstance]] internal property@comma{} a [[Scope]] internal property@comma{} a [[Construct]] internal property@comma{} a [[FormalParameters]] internal property@comma{} a [[Code]] internal property@comma{} a [[TargetFunction]] internal property@comma{} a [[BoundThis]] internal property@comma{} and a [[BoundArgs]] internal property.

The value of the [[Class]] internal property is "Function".

Function instances that correspond to strict mode functions (@uref{#sec-13.2,13.2}) and function instances created using the Function.prototype.bind method (@uref{#sec-15.3.4.5,15.3.4.5}) have properties named “@code{caller}” and “@code{arguments}” that throw a TypeError exception. An ECMAScript implementation must not associate any implementation specific behaviour with accesses of these properties from strict mode function code.


@node 15351 length
@chapter @uref{#sec-15.3.5.1,15.3.5.1} length
The value of the @code{length} property is an integer that indicates the “typical” number of arguments expected by the function. However@comma{} the language permits the function to be invoked with some other number of arguments. The behaviour of a function when invoked on a number of arguments other than the number specified by its @code{length} property depends on the function. This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15352 prototype
@chapter @uref{#sec-15.3.5.2,15.3.5.2} prototype
The value of the @code{prototype} property is used to initialise the [[Prototype]] internal property of a newly created object before the Function object is invoked as a constructor for that newly created object. This property has the attribute @{ [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.

NOTE Function objects created using Function.prototype.bind do not have a @code{prototype} property.


@node 15353 [[HasInstance]] V
@chapter @uref{#sec-15.3.5.3,15.3.5.3} [[HasInstance]] (V)
Assume F is a Function object.

When the [[HasInstance]] internal method of F is called with value V@comma{} the following steps are taken:

@enumerate
@item
If V is not an object@comma{} return false.
@item
Let O be the result of calling the [[Get]] internal method of F with property name "prototype".
@item
If @uref{#def-type,Type}(O) is not Object@comma{} throw a TypeError exception.
@item
Repeat
@enumerate
@item
Let V be the value of the [[Prototype]] internal property of V.
@item
If V is null@comma{} return false.
@item
If O and V refer to the same object@comma{} return true.
@end enumerate

@end enumerate

NOTE Function objects created using Function.prototype.bind have a different implementation of [[HasInstance]] defined in @uref{#sec-15.3.4.5.3,15.3.4.5.3}.


@node 15354 [[Get]] P
@chapter @uref{#sec-15.3.5.4,15.3.5.4} [[Get]] (P)
Function objects use a variation of the [[Get]] internal method used for other native ECMAScript objects (@uref{#sec-8.12.3,8.12.3}).

Assume F is a Function object. When the [[Get]] internal method of F is called with property name P@comma{} the following steps are taken:

@enumerate
@item
Let v be the result of calling the default [[Get]] internal method (@uref{#sec-8.12.3,8.12.3}) on F passing P as the property name argument.
@item
If P is "caller" and v is a strict mode Function object@comma{} throw a TypeError exception.
@item
Return v.
@end enumerate

NOTE Function objects created using Function.prototype.bind use the default [[Get]] internal method.


@node 154 Array Objects
@chapter @uref{#sec-15.4,15.4} Array Objects
Array objects give special treatment to a certain class of property names. A property name P (in the form of a String value) is an array index if and only if @uref{#sec-9.8,ToString}(@uref{#sec-9.6,ToUint32}(P)) is equal to P and @uref{#sec-9.6,ToUint32}(P) is not equal to 2^32−1. A property whose property name is an array index is also called an element. Every Array object has a @code{length} property whose value is always a nonnegative integer less than 2^32. The value of the @code{length} property is numerically greater than the name of every property whose name is an array index; whenever a property of an Array object is created or changed@comma{} other properties are adjusted as necessary to maintain this invariant. Specifically@comma{} whenever a property is added whose name is an array index@comma{} the @code{length} property is changed@comma{} if necessary@comma{} to be one more than the numeric value of that array index; and whenever the @code{length} property is changed@comma{} every property whose name is an array index whose value is not smaller than the new length is automatically deleted. This constraint applies only to own properties of an Array object and is unaffected by @code{length} or array index properties that may be inherited from its prototypes.

An object@comma{} O@comma{} is said to be sparse if the following algorithm returns true:

@enumerate
@item
Let len be the result of calling the [[Get]] internal method of O with argument "length".
@item
For each integer i in the range 0≤i<@uref{#sec-9.6,ToUint32}(len)
@enumerate
@item
Let elem be the result of calling the [[GetOwnProperty]] internal method of O with argument @uref{#sec-9.8,ToString}(i).
@item
If elem is undefined@comma{} return true.
@end enumerate

@item
Return false.
@end enumerate


@node 1541 The Array Constructor Called as a Function
@chapter @uref{#sec-15.4.1,15.4.1} The Array Constructor Called as a Function
When Array is called as a function rather than as a constructor@comma{} it creates and initialises a new Array object. Thus the function call @code{Array(<var>...</var>)} is equivalent to the object creation expression @code{new Array(<var>...</var>)} with the same arguments.


@node 15411 Array  [ item1 [  item2 [   ] ] ]
@chapter @uref{#sec-15.4.1.1,15.4.1.1} Array ( [ item1 [ @comma{} item2 [ @comma{} ... ] ] ] )
When the Array function is called the following steps are taken:

@enumerate
@item
Create and return a new Array object exactly as if the standard built-in constructor Array was used in a @code{new} expression with the same arguments (@uref{#sec-15.4.2,15.4.2}).
@end enumerate


@node 1542 The Array Constructor
@chapter @uref{#sec-15.4.2,15.4.2} The Array Constructor
When Array is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 15421 new Array  [ item0 [  item1 [   ] ] ]
@chapter @uref{#sec-15.4.2.1,15.4.2.1} new Array ( [ item0 [ @comma{} item1 [ @comma{} ... ] ] ] )
This description applies if and only if the Array constructor is given no arguments or at least two arguments.

The [[Prototype]] internal property of the newly constructed object is set to the original Array prototype object@comma{} the one that is the initial value of Array.prototype (@uref{#sec-15.4.3.1,15.4.3.1}).

The [[Class]] internal property of the newly constructed object is set to "Array".

The [[Extensible]] internal property of the newly constructed object is set to true.

The @code{length} property of the newly constructed object is set to the number of arguments.

The @code{0} property of the newly constructed object is set to item0 (if supplied); the @code{1} property of the newly constructed object is set to item1 (if supplied); and@comma{} in general@comma{} for as many arguments as there are@comma{} the k property of the newly constructed object is set to argument k@comma{} where the first argument is considered to be argument number 0. These properties all have the attributes @{[[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}.


@node 15422 new Array len
@chapter @uref{#sec-15.4.2.2,15.4.2.2} new Array (len)
The [[Prototype]] internal property of the newly constructed object is set to the original Array prototype object@comma{} the one that is the initial value of Array.prototype (@uref{#sec-15.4.3.1,15.4.3.1}). The [[Class]] internal property of the newly constructed object is set to "Array". The [[Extensible]] internal property of the newly constructed object is set to true.

If the argument len is a Number and @uref{#sec-9.6,ToUint32}(len) is equal to len@comma{} then the @code{length} property of the newly constructed object is set to @uref{#sec-9.6,ToUint32}(len). If the argument len is a Number and @uref{#sec-9.6,ToUint32}(len) is not equal to len@comma{} a RangeError exception is thrown.

If the argument len is not a Number@comma{} then the @code{length} property of the newly constructed object is set to 1 and the @code{0} property of the newly constructed object is set to len with attributes @{[[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}..


@node 1543 Properties of the Array Constructor
@chapter @uref{#sec-15.4.3,15.4.3} Properties of the Array Constructor
The value of the [[Prototype]] internal property of the Array constructor is @uref{#sec-15.3.4,the Function prototype object (15.3.4)}.

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} the Array constructor has the following properties:


@node 15431 Arrayprototype
@chapter @uref{#sec-15.4.3.1,15.4.3.1} Array.prototype
The initial value of Array.prototype is the Array prototype object (@uref{#sec-15.4.4,15.4.4}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15432 ArrayisArray  arg
@chapter @uref{#sec-15.4.3.2,15.4.3.2} Array.isArray ( arg )
The isArray function takes one argument arg@comma{} and returns the Boolean value true if the argument is an object whose class internal property is "Array"; otherwise it returns false. The following steps are taken:

@enumerate
@item

@item
If the value of the [[Class]] internal property of arg is "Array"@comma{} then return true.
@item
Return false.
@end enumerate


@node 1544 Properties of the Array Prototype Object
@chapter @uref{#sec-15.4.4,15.4.4} Properties of the Array Prototype Object
The value of the [[Prototype]] internal property of the Array prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).

The Array prototype object is itself an array; its [[Class]] is "Array"@comma{} and it has a @code{length} property (whose initial value is +0) and the special [[DefineOwnProperty]] internal method described in @uref{#sec-15.4.5.1,15.4.5.1}.

In following descriptions of functions that are properties of the Array prototype object@comma{} the phrase “this object” refers to the object that is the this value for the invocation of the function. It is permitted for the this to be an object for which the value of the [[Class]] internal property is not "Array".

NOTE The Array prototype object does not have a @code{valueOf} property of its own; however@comma{} it inherits the @code{valueOf} property from the standard built-in Object prototype Object.


@node 15441 Arrayprototypeconstructor
@chapter @uref{#sec-15.4.4.1,15.4.4.1} Array.prototype.constructor
The initial value of Array.prototype.constructor is the standard built-in Array constructor.


@node 15442 ArrayprototypetoString
@chapter @uref{#sec-15.4.4.2,15.4.4.2} Array.prototype.toString ( )
When the toString method is called@comma{} the following steps are taken:

@enumerate
@item
Let array be the result of calling @uref{#sec-9.9,ToObject} on the this value.
@item
Let func be the result of calling the [[Get]] internal method of array with argument "join".
@item
If @uref{#sec-9.11,IsCallable}(func) is false@comma{} then let func be the standard built-in method Object.prototype.toString (@uref{#sec-15.2.4.2,15.2.4.2}).
@item
Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.
@end enumerate

NOTE The toString function is intentionally generic; it does not require that its this value be an Array object.

Therefore it can be transferred to other kinds of objects for use as a method. Whether the toString function can be applied successfully to a host object is implementation-dependent.


@node 15443 ArrayprototypetoLocaleString
@chapter @uref{#sec-15.4.4.3,15.4.4.3} Array.prototype.toLocaleString ( )
The @uref{#def-array-element,elements} of the array are converted to Strings using their @code{toLocaleString} methods@comma{} and these Strings are then concatenated@comma{} separated by occurrences of a separator String that has been derived in an implementation-defined locale-specific way. The result of calling this function is intended to be analogous to the result of toString@comma{} except that the result of this function is intended to be locale-specific.

The result is calculated as follows:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let arrayLen be the result of calling the [[Get]] internal method of array with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(arrayLen).
@item
Let separator be the String value for the list-separator String appropriate for the host environment’s current locale (this is derived in an implementation-defined way).
@item
If len is zero@comma{} return the empty String.
@item
Let firstElement be the result of calling the [[Get]] internal method of array with argument "0".
@item
If firstElement is undefined or null@comma{} then
@enumerate
@item
Let R be the empty String.
@end enumerate

@item
Else
@enumerate
@item
Let elementObj be @uref{#sec-9.9,ToObject}(firstElement).
@item
Let func be the result of calling the [[Get]] internal method of elementObj with argument "toLocaleString".
@item
If @uref{#sec-9.11,IsCallable}(func) is false@comma{} throw a TypeError exception.
@item
Let R be the result of calling the [[Call]] internal method of func providing elementObj as the this value and an empty arguments list.
@end enumerate

@item
Let k be 1.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let S be a String value produced by concatenating R and separator.
@item
Let nextElement be the result of calling the [[Get]] internal method of array with argument @uref{#sec-9.8,ToString}(k).
@item
If nextElement is undefined or null@comma{} then
@enumerate
@item
Let R be the empty String.
@end enumerate

@item
Else
@enumerate
@item
Let elementObj be @uref{#sec-9.9,ToObject}(nextElement).
@item
Let func be the result of calling the [[Get]] internal method of elementObj with argument "toLocaleString".
@item
If @uref{#sec-9.11,IsCallable}(func) is false@comma{} throw a TypeError exception.
@item
Let R be the result of calling the [[Call]] internal method of func providing elementObj as the this value and an empty arguments list.
@end enumerate

@item
Let R be a String value produced by concatenating S and R.
@item
Increase k by 1.
@end enumerate

@item
Return R.
@end enumerate

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.

NOTE 2 The toLocaleString function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the toLocaleString function can be applied successfully to a host object is implementation-dependent.


@node 15444 Arrayprototypeconcat  [ item1 [  item2 [   ] ] ]
@chapter @uref{#sec-15.4.4.4,15.4.4.4} Array.prototype.concat ( [ item1 [ @comma{} item2 [ @comma{} ... ] ] ] )
When the concat method is called with zero or more arguments item1@comma{} item2@comma{} etc.@comma{} it returns an array containing the @uref{#def-array-element,array elements} of the object followed by the @uref{#def-array-element,array elements} of each argument in order.

The following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let n be 0.
@item
Let items be an internal @uref{#sec-8.8,List} whose first element is O and whose subsequent elements are@comma{} in left to right order@comma{} the arguments that were passed to this function invocation.
@item
Repeat@comma{} while items is not empty
@enumerate
@item
Remove the first element from items and let E be the value of the element.
@item
If the value of the [[Class]] internal property of E is "Array"@comma{} then
@enumerate
@item
Let k be 0.
@item
Let len be the result of calling the [[Get]] internal method of E with argument "length".
@item
Repeat@comma{} while k < len
@enumerate
@item
Let P be @uref{#sec-9.8,ToString}(k).
@item
Let exists be the result of calling the [[HasProperty]] internal method of E with P.
@item
If exists is true@comma{} then
@enumerate
@item
Let subElement be the result of calling the [[Get]] internal method of E with argument P.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(n)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: subElement@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Increase n by 1.
@item
Increase k by 1.
@end enumerate

@end enumerate

@item
Else@comma{} E is not an Array
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(n)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: E@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Increase n by 1.
@end enumerate

@end enumerate

@item
Return A.
@end enumerate

The @code{length} property of the concat method is 1.

NOTE The concat function is intentionally generic; it does not require that its this value be an Array object.

Therefore it can be transferred to other kinds of objects for use as a method. Whether the concat function can be applied successfully to a host object is implementation-dependent.


@node 15445 Arrayprototypejoin separator
@chapter @uref{#sec-15.4.4.5,15.4.4.5} Array.prototype.join (separator)
The @uref{#def-array-element,elements} of the array are converted to Strings@comma{} and these Strings are then concatenated@comma{} separated by occurrences of the separator. If no separator is provided@comma{} a single comma is used as the separator.

The join method takes one argument@comma{} separator@comma{} and performs the following steps:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
If separator is undefined@comma{} let separator be the single-character String "@comma{}".
@item
Let sep be @uref{#sec-9.8,ToString}(separator).
@item
If len is zero@comma{} return the empty String.
@item
Let element0 be the result of calling the [[Get]] internal method of O with argument "0".
@item
If element0 is undefined or null@comma{} let R be the empty String; otherwise@comma{} Let R be @uref{#sec-9.8,ToString}(element0).
@item
Let k be 1.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let S be the String value produced by concatenating R and sep.
@item
Let element be the result of calling the [[Get]] internal method of O with argument @uref{#sec-9.8,ToString}(k).
@item
If element is undefined or null@comma{} Let next be the empty String; otherwise@comma{} let next be @uref{#sec-9.8,ToString}(element).
@item
Let R be a String value produced by concatenating S and next.
@item
Increase k by 1.
@end enumerate

@item
Return R.
@end enumerate

The @code{length} property of the join method is 1.

NOTE The join function is intentionally generic; it does not require that its this value be an Array object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method. Whether the join function can be applied successfully to a host object is implementation-dependent.


@node 15446 Arrayprototypepop
@chapter @uref{#sec-15.4.4.6,15.4.4.6} Array.prototype.pop ( )
The last @uref{#def-array-element,element} of the array is removed from the array and returned.

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
If len is zero@comma{}
@enumerate
@item
Call the [[Put]] internal method of O with arguments "length"@comma{} 0@comma{} and true.
@item
Return undefined.
@end enumerate

@item
Else@comma{} len > 0
@enumerate
@item
Let indx be @uref{#sec-9.8,ToString}(len−1).
@item
Let element be the result of calling the [[Get]] internal method of O with argument indx.
@item
Call the [[Delete]] internal method of O with arguments indx and true.
@item
Call the [[Put]] internal method of O with arguments "length"@comma{} indx@comma{} and true.
@item
Return element.
@end enumerate

@end enumerate

NOTE The pop function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the pop function can be applied successfully to a host object is implementation-dependent.


@node 15447 Arrayprototypepush  [ item1 [  item2 [   ] ] ]
@chapter @uref{#sec-15.4.4.7,15.4.4.7} Array.prototype.push ( [ item1 [ @comma{} item2 [ @comma{} ... ] ] ] )
The arguments are appended to the end of the array@comma{} in the order in which they appear. The new length of the array is returned as the result of the call.

When the push method is called with zero or more arguments item1@comma{} item2@comma{} etc.@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let n be @uref{#sec-9.6,ToUint32}(lenVal).
@item
Let items be an internal @uref{#sec-8.8,List} whose elements are@comma{} in left to right order@comma{} the arguments that were passed to this function invocation.
@item
Repeat@comma{} while items is not empty
@enumerate
@item
Remove the first element from items and let E be the value of the element.
@item
Call the [[Put]] internal method of O with arguments @uref{#sec-9.8,ToString}(n)@comma{} E@comma{} and true.
@item
Increase n by 1.
@end enumerate

@item
Call the [[Put]] internal method of O with arguments "length"@comma{} n@comma{} and true.
@item
Return n.
@end enumerate

The @code{length} property of the push method is 1.

NOTE The push function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the push function can be applied successfully to a host object is implementation-dependent.


@node 15448 Arrayprototypereverse
@chapter @uref{#sec-15.4.4.8,15.4.4.8} Array.prototype.reverse ( )
The @uref{#def-array-element,elements} of the array are rearranged so as to reverse their order. The object is returned as the result of the call.

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
Let middle be @uref{#def-floor,floor}(len/2).
@item
Let lower be 0.
@item
Repeat@comma{} while lower ≠ middle
@enumerate
@item
Let upper be len−lower−1.
@item
Let upperP be @uref{#sec-9.8,ToString}(upper).
@item
Let lowerP be @uref{#sec-9.8,ToString}(lower).
@item
Let lowerValue be the result of calling the [[Get]] internal method of O with argument lowerP.
@item
Let upperValue be the result of calling the [[Get]] internal method of O with argument upperP .
@item
Let lowerExists be the result of calling the [[HasProperty]] internal method of O with argument lowerP.
@item
Let upperExists be the result of calling the [[HasProperty]] internal method of O with argument upperP.
@item
If lowerExists is true and upperExists is true@comma{} then
@enumerate
@item
Call the [[Put]] internal method of O with arguments lowerP@comma{} upperValue@comma{} and true .
@item
Call the [[Put]] internal method of O with arguments upperP@comma{} lowerValue@comma{} and true .
@end enumerate

@item
Else if lowerExists is false and upperExists is true@comma{} then
@enumerate
@item
Call the [[Put]] internal method of O with arguments lowerP@comma{} upperValue@comma{} and true .
@item
Call the [[Delete]] internal method of O@comma{} with arguments upperP and true.
@end enumerate

@item
Else if lowerExists is true and upperExists is false@comma{} then
@enumerate
@item
Call the [[Delete]] internal method of O@comma{} with arguments lowerP and true .
@item
Call the [[Put]] internal method of O with arguments upperP@comma{} lowerValue@comma{} and true .
@end enumerate

@item
Else@comma{} both lowerExists and upperExists are false
@enumerate
@item
No action is required.
@end enumerate

@item
Increase lower by 1.
@end enumerate

@item
Return O .
@end enumerate

NOTE The reverse function is intentionally generic; it does not require that its this value be an Array object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method. Whether the reverse function can be applied successfully to a host object is implementation-dependent.


@node 15449 Arrayprototypeshift
@chapter @uref{#sec-15.4.4.9,15.4.4.9} Array.prototype.shift ( )
The first @uref{#def-array-element,element} of the array is removed from the array and returned.

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
If len is zero@comma{} then
@enumerate
@item
Call the [[Put]] internal method of O with arguments "length"@comma{} 0@comma{} and true.
@item
Return undefined.
@end enumerate

@item
Let first be the result of calling the [[Get]] internal method of O with argument "0".
@item
Let k be 1.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let from be @uref{#sec-9.8,ToString}(k).
@item
Let to be @uref{#sec-9.8,ToString}(k−1).
@item
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument from.
@item
If fromPresent is true@comma{} then
@enumerate
@item
Let fromVal be the result of calling the [[Get]] internal method of O with argument from.
@item
Call the [[Put]] internal method of O with arguments to@comma{} fromVal@comma{} and true.
@end enumerate

@item
Else@comma{} fromPresent is false
@enumerate
@item
Call the [[Delete]] internal method of O with arguments to and true.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Call the [[Delete]] internal method of O with arguments @uref{#sec-9.8,ToString}(len−1) and true.
@item
Call the [[Put]] internal method of O with arguments "length"@comma{} (len−1) @comma{} and true.
@item
Return first.
@end enumerate

NOTE The shift function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the shift function can be applied successfully to a host object is implementation-dependent.


@node 154410 Arrayprototypeslice start end
@chapter @uref{#sec-15.4.4.10,15.4.4.10} Array.prototype.slice (start@comma{} end)
The slice method takes two arguments@comma{} start and end@comma{} and returns an array containing the @uref{#def-array-element,elements} of the array from element start up to@comma{} but not including@comma{} element end (or through the end of the array if end is undefined). If start is negative@comma{} it is treated as length+start where length is the length of the array. If end is negative@comma{} it is treated as length+end where length is the length of the array. The following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
Let relativeStart be @uref{#sec-9.4,ToInteger}(start).
@item
If relativeStart is negative@comma{} let k be max((len + relativeStart)@comma{}0); else let k be min(relativeStart@comma{} len).
@item
If end is undefined@comma{} let relativeEnd be len; else let relativeEnd be @uref{#sec-9.4,ToInteger}(end).
@item
If relativeEnd is negative@comma{} let final be max((len + relativeEnd)@comma{}0); else let final be min(relativeEnd@comma{} len).
@item
Let n be 0.
@item
Repeat@comma{} while k < final
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(n)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: kValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Increase k by 1.
@item
Increase n by 1.
@end enumerate

@item
Return A.
@end enumerate

The @code{length} property of the slice method is 2.

NOTE The slice function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the slice function can be applied successfully to a host object is implementation-dependent.


@node 154411 Arrayprototypesort comparefn
@chapter @uref{#sec-15.4.4.11,15.4.4.11} Array.prototype.sort (comparefn)
The @uref{#def-array-element,elements} of this array are sorted. The sort is not necessarily stable (that is@comma{} elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined@comma{} it should be a function that accepts two arguments x and y and returns a negative value if x < y@comma{} zero if x = y@comma{} or a positive value if x > y.

Let obj be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.

Let len be the result of applying Uint32 to the result of calling the [[Get]] internal method of obj with argument "length".

If comparefn is not undefined and is not a consistent comparison function for the @uref{#def-array-element,elements} of this array (see below)@comma{} the behaviour of sort is implementation-defined.

Let proto be the value of the [[Prototype]] internal property of obj. If proto is not null and there exists an integer j such that all of the conditions below are satisfied then the behaviour of sort is implementation-defined:

@itemize
@item
obj is @uref{#def-sparse,sparse} (@uref{#sec-15.4,15.4})
@item
0 ≤ j < len
@item
The result of calling the [[HasProperty]] internal method of proto with argument @uref{#sec-9.8,ToString}(j) is true.
@end itemize

The behaviour of sort is also implementation defined if obj is @uref{#def-sparse,sparse} and any of the following conditions are true:

@itemize
@item
The [[Extensible]] internal property of obj is false.
@item
Any array index property of obj whose name is a nonnegative integer less than len is a data property whose [[Configurable]] attribute is false.
@end itemize

The behaviour of sort is also implementation defined if any array index property of obj whose name is a nonnegative integer less than len is an accessor property or is a data property whose [[Writable]] attribute is false.

Otherwise@comma{} the following steps are taken.

@enumerate
@item
Perform an implementation-dependent sequence of calls to the [[Get]] @comma{} [[Put]]@comma{} and [[Delete]] internal methods of obj and to SortCompare (described below)@comma{} where the first argument for each call to [[Get]]@comma{} [[Put]]@comma{} or [[Delete]] is a nonnegative integer less than len and where the arguments for calls to SortCompare are results of previous calls to the [[Get]] internal method. The throw argument to the [[Put]] and [[Delete]] internal methods will be the value true. If obj is not @uref{#def-sparse,sparse} then [[Delete]] must not be called.
@item
Return obj.
@end enumerate



@itemize
@item
There must be some mathematical permutation π of the nonnegative integers less than len@comma{} such that for every nonnegative integer j less than len@comma{} if property old[j] existed@comma{} then new[π(j)] is exactly the same value as old[j]. But if property old[j] did not exist@comma{} then new[π(j)] does not exist.
@item
Then for all nonnegative integers j and k@comma{} each less than len@comma{} if SortCompare(j@comma{}k) < 0 (see SortCompare below)@comma{} then π(j) < π(k).
@end itemize

Here the notation old[j] is used to refer to the hypothetical result of calling the [[Get]] internal method of obj with argument j before this function is executed@comma{} and the notation new[j] to refer to the hypothetical result of calling the [[Get]] internal method of obj with argument j after this function has been executed.

A function comparefn is a consistent comparison function for a set of values S if all of the requirements below are met for all values a@comma{} b@comma{} and c (possibly the same value) in the set S: The notation a <_CF_ b means comparefn(a@comma{}b) < 0; a =_CF_ b means comparefn(a@comma{}b) = 0 (of either sign); and a >_CF_ b means comparefn(a@comma{}b) > 0.

@itemize
@item
Calling comparefn(a@comma{}b) always returns the same value v when given a specific pair of values a and b as its two arguments. Furthermore@comma{} @uref{#def-type,Type}(v) is Number@comma{} and v is not NaN. Note that this implies that exactly one of a <_CF_ b@comma{} a =_CF_ b@comma{} and a >_CF_ b will be true for a given pair of a and b.
@item
Calling comparefn(a@comma{}b) does not modify the this object.
@item
a =_CF_ a (reflexivity)
@item
If a =_CF_ b@comma{} then b =_CF_ a (symmetry)
@item
If a =_CF_ b and b =_CF_ c@comma{} then a =_CF_ c (transitivity of =_CF_)
@item
If a <_CF_ b and b <_CF_ c@comma{} then a <_CF_ c (transitivity of <_CF_)
@item
If a >_CF_ b and b >_CF_ c@comma{} then a >_CF_ c (transitivity of >_CF_)
@end itemize

NOTE The above conditions are necessary and sufficient to ensure that comparefn divides the set S into equivalence classes and that these equivalence classes are totally ordered.

When the SortCompare abstract operation is called with two arguments j and k@comma{} the following steps are taken:

@enumerate
@item
Let jString be @uref{#sec-9.8,ToString}(j).
@item
Let kString be @uref{#sec-9.8,ToString}(k).
@item
Let hasj be the result of calling the [[HasProperty]] internal method of obj with argument jString.
@item
Let hask be the result of calling the [[HasProperty]] internal method of obj with argument kString.
@item
If hasj and hask are both false@comma{} then return +0.
@item
If hasj is false@comma{} then return 1.
@item
If hask is false@comma{} then return −1.
@item
Let x be the result of calling the [[Get]] internal method of obj with argument jString.
@item
Let y be the result of calling the [[Get]] internal method of obj with argument kString.
@item
If x and y are both undefined@comma{} return +0.
@item
If x is undefined@comma{} return 1.
@item
If y is undefined@comma{} return −1.
@item
If the argument comparefn is not undefined@comma{} then
@enumerate
@item
If @uref{#sec-9.11,IsCallable}(comparefn) is false@comma{} throw a TypeError exception.
@item
Return the result of calling the [[Call]] internal method of comparefn passing undefined as the this value and with arguments x and y.
@end enumerate

@item
Let xString be @uref{#sec-9.8,ToString}(x).
@item
Let yString be @uref{#sec-9.8,ToString}(y).
@item
If xString < yString@comma{} return −1.
@item
If xString > yString@comma{} return 1.
@item
Return +0.
@end enumerate

NOTE 1 Because non-existent property values always compare greater than undefined property values@comma{} and undefined always compares greater than any other value@comma{} undefined property values always sort to the end of the result@comma{} followed by non-existent property values.

NOTE 2 The sort function is intentionally generic; it does not require that its this value be an Array object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method. Whether the sort function can be applied successfully to a host object is implementation-dependent.



@node 154412 Arrayprototypesplice start deleteCount [  item1 [  item2 [   ] ] ]
@chapter @uref{#sec-15.4.4.12,15.4.4.12} Array.prototype.splice (start@comma{} deleteCount [ @comma{} item1 [ @comma{} item2 [ @comma{} ... ] ] ] )
When the splice method is called with two or more arguments start@comma{} deleteCount and (optionally) item1@comma{} item2@comma{} etc.@comma{} the deleteCount @uref{#def-array-element,elements} of the array starting at array index start are replaced by the arguments item1@comma{} item2@comma{} etc. An Array object containing the deleted @uref{#def-array-element,elements} (if any) is returned. The following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
Let relativeStart be @uref{#sec-9.4,ToInteger}(start).
@item
If relativeStart is negative@comma{} let actualStart be max((len + relativeStart)@comma{}0); else let actualStart be min(relativeStart@comma{} len).
@item
Let actualDeleteCount be min(max(@uref{#sec-9.4,ToInteger}(deleteCount)@comma{}0)@comma{} len − actualStart).
@item
Let k be 0.
@item
Repeat@comma{} while k < actualDeleteCount
@enumerate
@item
Let from be @uref{#sec-9.8,ToString}(relativeStart+k).
@item
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument from.
@item
If fromPresent is true@comma{} then
@enumerate
@item
Let fromValue be the result of calling the [[Get]] internal method of O with argument from.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(k)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: fromValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Increment k by 1.
@end enumerate

@item
Let items be an internal @uref{#sec-8.8,List} whose elements are@comma{} in left to right order@comma{} the portion of the actual argument list starting with item1. The list will be empty if no such items are present.
@item
Let itemCount be the number of elements in items.
@item
If itemCount < actualDeleteCount@comma{} then
@enumerate
@item
Let k be actualStart.
@item
Repeat@comma{} while k < (len − actualDeleteCount)
@enumerate
@item
Let from be @uref{#sec-9.8,ToString}(k+actualDeleteCount).
@item
Let to be @uref{#sec-9.8,ToString}(k+itemCount).
@item
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument from.
@item
If fromPresent is true@comma{} then
@enumerate
@item
Let fromValue be the result of calling the [[Get]] internal method of O with argument from.
@item
Call the [[Put]] internal method of O with arguments to@comma{} fromValue@comma{} and true.
@end enumerate

@item
Else@comma{} fromPresent is false
@enumerate
@item
Call the [[Delete]] internal method of O with arguments to and true.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Let k be len.
@item
Repeat@comma{} while k > (len − actualDeleteCount + itemCount)
@enumerate
@item
Call the [[Delete]] internal method of O with arguments @uref{#sec-9.8,ToString}(k−1) and true.
@item
Decrease k by 1.
@end enumerate

@end enumerate

@item
Else if itemCount > actualDeleteCount@comma{} then
@enumerate
@item
Let k be (len − actualDeleteCount).
@item
Repeat@comma{} while k > actualStart
@enumerate
@item
Let from be @uref{#sec-9.8,ToString}(k + actualDeleteCount − 1).
@item
Let to be @uref{#sec-9.8,ToString}(k + itemCount − 1)
@item
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument from.
@item
If fromPresent is true@comma{} then
@enumerate
@item
Let fromValue be the result of calling the [[Get]] internal method of O with argument from.
@item
Call the [[Put]] internal method of O with arguments to@comma{} fromValue@comma{} and true.
@end enumerate

@item
Else@comma{} fromPresent is false
@enumerate
@item
Call the [[Delete]] internal method of O with argument to and true.
@end enumerate

@item
Decrease k by 1.
@end enumerate

@end enumerate

@item
Let k be actualStart.
@item
Repeat@comma{} while items is not empty
@enumerate
@item
Remove the first element from items and let E be the value of that element.
@item
Call the [[Put]] internal method of O with arguments @uref{#sec-9.8,ToString}(k)@comma{} E@comma{} and true.
@item
Increase k by 1.
@end enumerate

@item
Call the [[Put]] internal method of O with arguments "length"@comma{} (len − actualDeleteCount + itemCount)@comma{} and true.
@item
Return A.
@end enumerate

The @code{length} property of the splice method is 2.

NOTE The splice function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the splice function can be applied successfully to a host object is implementation-dependent.


@node 154413 Arrayprototypeunshift  [ item1 [  item2 [   ] ] ]
@chapter @uref{#sec-15.4.4.13,15.4.4.13} Array.prototype.unshift ( [ item1 [ @comma{} item2 [ @comma{} ... ] ] ] )
The arguments are prepended to the start of the array@comma{} such that their order within the array is the same as the order in which they appear in the argument list.

When the unshift method is called with zero or more arguments item1@comma{} item2@comma{} etc.@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenVal).
@item
Let argCount be the number of actual arguments.
@item
Let k be len.
@item
Repeat@comma{} while k > 0@comma{}
@enumerate
@item
Let from be @uref{#sec-9.8,ToString}(k−1).
@item
Let to be @uref{#sec-9.8,ToString}(k+argCount −1).
@item
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument from.
@item
If fromPresent is true@comma{} then
@enumerate
@item
Let fromValue be the result of calling the [[Get]] internal method of O with argument from.
@item
Call the [[Put]] internal method of O with arguments to@comma{} fromValue@comma{} and true.
@end enumerate

@item
Else@comma{} fromPresent is false
@enumerate
@item
Call the [[Delete]] internal method of O with arguments to@comma{} and true.
@end enumerate

@item
Decrease k by 1.
@end enumerate

@item
Let j be 0.
@item
Let items be an internal @uref{#sec-8.8,List} whose elements are@comma{} in left to right order@comma{} the arguments that were passed to this function invocation.
@item
Repeat@comma{} while items is not empty
@enumerate
@item
Remove the first element from items and let E be the value of that element.
@item
Call the [[Put]] internal method of O with arguments @uref{#sec-9.8,ToString}(j)@comma{} E@comma{} and true.
@item
Increase j by 1.
@end enumerate

@item
Call the [[Put]] internal method of O with arguments "length"@comma{} len+argCount@comma{} and true.
@item
Return len+argCount.
@end enumerate

The @code{length} property of the unshift method is 1.

NOTE The unshift function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the unshift function can be applied successfully to a host object is implementation-dependent.



@node 154414 ArrayprototypeindexOf  searchElement [  fromIndex ]
@chapter @uref{#sec-15.4.4.14,15.4.4.14} Array.prototype.indexOf ( searchElement [ @comma{} fromIndex ] )
indexOf compares searchElement to the elements of the array@comma{} in ascending order@comma{} using the internal @uref{#sec-11.9.6,Strict Equality Comparison Algorithm (11.9.6)}@comma{} and if found at one or more positions@comma{} returns the index of the first such position; otherwise@comma{} −1 is returned.

The optional second argument fromIndex defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array@comma{} −1 is returned@comma{} i.e. the array will not be searched. If it is negative@comma{} it is used as the offset from the end of the array to compute fromIndex. If the computed index is less than 0@comma{} the whole array will be searched.

When the indexOf method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If len is 0@comma{} return −1.
@item
If argument fromIndex was passed let n be @uref{#sec-9.4,ToInteger}(fromIndex); else let n be 0.
@item
If n ≥ len@comma{} return −1.
@item
If n ≥ 0@comma{} then
@enumerate
@item
Let k be n.
@end enumerate

@item
Else@comma{} n<0
@enumerate
@item
Let k be len − @uref{#def-abs,abs}(n).
@item
If k is less than 0@comma{} then let k be 0.
@end enumerate

@item
Repeat@comma{} while k<len
@enumerate
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument @uref{#sec-9.8,ToString}(k).
@item
If kPresent is true@comma{} then
@enumerate
@item
Let elementK be the result of calling the [[Get]] internal method of O with the argument @uref{#sec-9.8,ToString}(k).
@item
Let same be the result of applying the Strict Equality Comparison Algorithm to searchElement and elementK.
@item
If same is true@comma{} return k.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return −1.
@end enumerate

The @code{length} property of the indexOf method is 1.

NOTE The indexOf function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the indexOf function can be applied successfully to a host object is implementation-dependent.


@node 154415 ArrayprototypelastIndexOf  searchElement [  fromIndex ]
@chapter @uref{#sec-15.4.4.15,15.4.4.15} Array.prototype.lastIndexOf ( searchElement [ @comma{} fromIndex ] )
lastIndexOf compares searchElement to the elements of the array in descending order using the internal @uref{#sec-11.9.6,Strict Equality Comparison Algorithm (11.9.6)}@comma{} and if found at one or more positions@comma{} returns the index of the last such position; otherwise@comma{} −1 is returned.

The optional second argument fromIndex defaults to the array’s length (i.e. the whole array is searched). If it is greater than or equal to the length of the array@comma{} the whole array will be searched. If it is negative@comma{} it is used as the offset from the end of the array to compute fromIndex. If the computed index is less than 0@comma{} −1 is returned.

When the lastIndexOf method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If len is 0@comma{} return −1.
@item
If argument fromIndex was passed let n be @uref{#sec-9.4,ToInteger}(fromIndex); else let n be len.
@item
If n ≥ 0@comma{} then let k be min(n@comma{} len − 1).
@item
Else@comma{} n < 0
@enumerate
@item
Let k be len − @uref{#def-abs,abs}(n).
@end enumerate

@item
Repeat@comma{} while k≥0
@enumerate
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument @uref{#sec-9.8,ToString}(k).
@item
If kPresent is true@comma{} then
@enumerate
@item
Let elementK be the result of calling the [[Get]] internal method of O with the argument @uref{#sec-9.8,ToString}(k).
@item
Let same be the result of applying the Strict Equality Comparision Algorithm to searchElement and elementK.
@item
If same is true@comma{} return k.
@end enumerate

@item
Decrease k by 1.
@end enumerate

@item
Return −1.
@end enumerate

The @code{length} property of the lastIndexOf method is 1.

NOTE The lastIndexOf function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the lastIndexOf function can be applied successfully to a host object is implementation-dependent.


@node 154416 Arrayprototypeevery  callbackfn [  thisArg ]
@chapter @uref{#sec-15.4.4.16,15.4.4.16} Array.prototype.every ( callbackfn [ @comma{} thisArg ] )
callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. every calls callbackfn once for each @uref{#def-array-element,element} present in the array@comma{} in ascending order@comma{} until it finds one where callbackfn returns false. If such an element is found@comma{} every immediately returns false. Otherwise@comma{} if callbackfn returned true for all elements@comma{} every will return true. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.

If a thisArg parameter is provided@comma{} it will be used as the this value for each invocation of callbackfn. If it is not provided@comma{} undefined is used instead.

callbackfn is called with three arguments: the value of the element@comma{} the index of the element@comma{} and the object being traversed.

every does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.

The range of elements processed by every is set before the first call to callbackfn. Elements which are appended to the array after the call to every begins will not be visited by callbackfn. If existing elements of the array are changed@comma{} their value as passed to callbackfn will be the value at the time every visits them; elements that are deleted after the call to every begins and before being visited are not visited. every acts like the “for all” quantifier in mathematics. In particular@comma{} for an empty array@comma{} it returns true.

When the every method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If thisArg was supplied@comma{} let T be thisArg; else let T be undefined.
@item
Let k be 0.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Let testResult be the result of calling the [[Call]] internal method of callbackfn with T as the this value and argument list containing kValue@comma{} k@comma{} and O.
@item
If @uref{#sec-9.2,ToBoolean}(testResult) is false@comma{} return false.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return true.
@end enumerate

The @code{length} property of the every method is 1.

NOTE The every function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the every function can be applied successfully to a host object is implementation-dependent.


@node 154417 Arrayprototypesome  callbackfn [  thisArg ]
@chapter @uref{#sec-15.4.4.17,15.4.4.17} Array.prototype.some ( callbackfn [ @comma{} thisArg ] )
callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. some calls callbackfn once for each @uref{#def-array-element,element} present in the array@comma{} in ascending order@comma{} until it finds one where callbackfn returns true. If such an element is found@comma{} some immediately returns true. Otherwise@comma{} some returns false. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.

If a thisArg parameter is provided@comma{} it will be used as the this value for each invocation of callbackfn. If it is not provided@comma{} undefined is used instead.

callbackfn is called with three arguments: the value of the element@comma{} the index of the element@comma{} and the object being traversed.

some does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.

The range of elements processed by some is set before the first call to callbackfn. Elements that are appended to the array after the call to some begins will not be visited by callbackfn. If existing elements of the array are changed@comma{} their value as passed to callbackfn will be the value at the time that some visits them; elements that are deleted after the call to some begins and before being visited are not visited. some acts like the “exists” quantifier in mathematics. In particular@comma{} for an empty array@comma{} it returns false.

When the some method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If thisArg was supplied@comma{} let T be thisArg; else let T be undefined.
@item
Let k be 0.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Let testResult be the result of calling the [[Call]] internal method of callbackfn with T as the this value and argument list containing kValue@comma{} k@comma{} and O.
@item
If @uref{#sec-9.2,ToBoolean}(testResult) is true@comma{} return true.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return false.
@end enumerate

The @code{length} property of the some method is 1.

NOTE The some function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the some function can be applied successfully to a host object is implementation-dependent.



@node 154418 ArrayprototypeforEach  callbackfn [  thisArg ]
@chapter @uref{#sec-15.4.4.18,15.4.4.18} Array.prototype.forEach ( callbackfn [ @comma{} thisArg ] )
callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each @uref{#def-array-element,element} present in the array@comma{} in ascending order. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.

If a thisArg parameter is provided@comma{} it will be used as the this value for each invocation of callbackfn. If it is not provided@comma{} undefined is used instead.

callbackfn is called with three arguments: the value of the element@comma{} the index of the element@comma{} and the object being traversed.

forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.

The range of elements processed by forEach is set before the first call to callbackfn. Elements which are appended to the array after the call to forEach begins will not be visited by callbackfn. If existing elements of the array are changed@comma{} their value as passed to callback will be the value at the time forEach visits them; elements that are deleted after the call to forEach begins and before being visited are not visited.

When the forEach method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If thisArg was supplied@comma{} let T be thisArg; else let T be undefined.
@item
Let k be 0.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Call the [[Call]] internal method of callbackfn with T as the this value and argument list containing kValue@comma{} k@comma{} and O.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return undefined.
@end enumerate

The @code{length} property of the forEach method is 1.

NOTE The forEach function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the forEach function can be applied successfully to a host object is implementation-dependent.


@node 154419 Arrayprototypemap  callbackfn [  thisArg ]
@chapter @uref{#sec-15.4.4.19,15.4.4.19} Array.prototype.map ( callbackfn [ @comma{} thisArg ] )
callbackfn should be a function that accepts three arguments. map calls callbackfn once for each @uref{#def-array-element,element} in the array@comma{} in ascending order@comma{} and constructs a new Array from the results. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.

If a thisArg parameter is provided@comma{} it will be used as the this value for each invocation of callbackfn. If it is not provided@comma{} undefined is used instead.

callbackfn is called with three arguments: the value of the element@comma{} the index of the element@comma{} and the object being traversed.

map does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.



When the map method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If thisArg was supplied@comma{} let T be thisArg; else let T be undefined.
@item
Let A be a new array created as if by the expression @code{new Array(<var>len</var>)} where @code{Array} is the standard built-in constructor with that name and len is the value of len.
@item
Let k be 0.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Let mappedValue be the result of calling the [[Call]] internal method of callbackfn with T as the this value and argument list containing kValue@comma{} k@comma{} and O.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments Pk@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: mappedValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return A.
@end enumerate

The @code{length} property of the map method is 1.

NOTE The map function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the map function can be applied successfully to a host object is implementation-dependent.


@node 154420 Arrayprototypefilter  callbackfn [  thisArg ]
@chapter @uref{#sec-15.4.4.20,15.4.4.20} Array.prototype.filter ( callbackfn [ @comma{} thisArg ] )
callbackfn should be a function that accepts three arguments and returns a value that is coercible to the Boolean value true or false. filter calls callbackfn once for each @uref{#def-array-element,element} in the array@comma{} in ascending order@comma{} and constructs a new array of all the values for which callbackfn returns true. callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array.

If a thisArg parameter is provided@comma{} it will be used as the this value for each invocation of callbackfn. If it is not provided@comma{} undefined is used instead.

callbackfn is called with three arguments: the value of the element@comma{} the index of the element@comma{} and the object being traversed.

filter does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.

The range of elements processed by filter is set before the first call to callbackfn. Elements which are appended to the array after the call to filter begins will not be visited by callbackfn. If existing elements of the array are changed their value as passed to callbackfn will be the value at the time filter visits them; elements that are deleted after the call to filter begins and before being visited are not visited.

When the filter method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If thisArg was supplied@comma{} let T be thisArg; else let T be undefined.
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let k be 0.
@item
Let to be 0.
@item
Repeat@comma{} while k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Let selected be the result of calling the [[Call]] internal method of callbackfn with T as the this value and argument list containing kValue@comma{} k@comma{} and O.
@item
If @uref{#sec-9.2,ToBoolean}(selected) is true@comma{} then
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(to)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: kValue@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Increase to by 1.
@end enumerate

@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return A.
@end enumerate

The @code{length} property of the filter method is 1.

NOTE The filter function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the filter function can be applied successfully to a host object is implementation-dependent.


@node 154421 Arrayprototypereduce  callbackfn [  initialValue ]
@chapter @uref{#sec-15.4.4.21,15.4.4.21} Array.prototype.reduce ( callbackfn [ @comma{} initialValue ] )
callbackfn should be a function that takes four arguments. reduce calls the callback@comma{} as a function@comma{} once for each @uref{#def-array-element,element} present in the array@comma{} in ascending order.

callbackfn is called with four arguments: the previousValue (or value from the previous call to callbackfn)@comma{} the currentValue (value of the current element)@comma{} the currentIndex@comma{} and the object being traversed. The first time that callback is called@comma{} the previousValue and currentValue can be one of two values. If an initialValue was provided in the call to reduce@comma{} then previousValue will be equal to initialValue and currentValue will be equal to the first value in the array. If no initialValue was provided@comma{} then previousValue will be equal to the first value in the array and currentValue will be equal to the second. It is a TypeError if the array contains no elements and initialValue is not provided.

reduce does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.

The range of elements processed by reduce is set before the first call to callbackfn. Elements that are appended to the array after the call to reduce begins will not be visited by callbackfn. If existing elements of the array are changed@comma{} their value as passed to callbackfn will be the value at the time reduce visits them; elements that are deleted after the call to reduce begins and before being visited are not visited.

When the reduce method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue ).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If len is 0 and initialValue is not present@comma{} throw a TypeError exception.
@item
Let k be 0.
@item
If initialValue is present@comma{} then
@enumerate
@item
Set accumulator to initialValue.
@end enumerate

@item
Else@comma{} initialValue is not present
@enumerate
@item
Let kPresent be false.
@item
Repeat@comma{} while kPresent is false and k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let accumulator be the result of calling the [[Get]] internal method of O with argument Pk.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
If kPresent is false@comma{} throw a TypeError exception.
@end enumerate

@item
Repeat@comma{} while k < len
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Let accumulator be the result of calling the [[Call]] internal method of callbackfn with undefined as the this value and argument list containing accumulator@comma{} kValue@comma{} k@comma{} and O.
@end enumerate

@item
Increase k by 1.
@end enumerate

@item
Return accumulator.
@end enumerate

The @code{length} property of the reduce method is 1.

NOTE The reduce function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the reduce function can be applied successfully to a host object is implementation-dependent.


@node 154422 ArrayprototypereduceRight  callbackfn [  initialValue ]
@chapter @uref{#sec-15.4.4.22,15.4.4.22} Array.prototype.reduceRight ( callbackfn [ @comma{} initialValue ] )
callbackfn should be a function that takes four arguments. reduceRight calls the callback@comma{} as a function@comma{} once for each @uref{#def-array-element,element} present in the array@comma{} in descending order.

callbackfn is called with four arguments: the previousValue (or value from the previous call to callbackfn)@comma{} the currentValue (value of the current element)@comma{} the currentIndex@comma{} and the object being traversed. The first time the function is called@comma{} the previousValue and currentValue can be one of two values. If an initialValue was provided in the call to reduceRight@comma{} then previousValue will be equal to initialValue and currentValue will be equal to the last value in the array. If no initialValue was provided@comma{} then previousValue will be equal to the last value in the array and currentValue will be equal to the second-to-last value. It is a TypeError if the array contains no elements and initialValue is not provided.

reduceRight does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn.

The range of elements processed by reduceRight is set before the first call to callbackfn. Elements that are appended to the array after the call to reduceRight begins will not be visited by callbackfn. If existing elements of the array are changed by callbackfn@comma{} their value as passed to callbackfn will be the value at the time reduceRight visits them; elements that are deleted after the call to reduceRight begins and before being visited are not visited.

When the reduceRight method is called with one or two arguments@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject} passing the this value as the argument.
@item
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length".
@item
Let len be @uref{#sec-9.6,ToUint32}(lenValue ).
@item
If @uref{#sec-9.11,IsCallable}(callbackfn) is false@comma{} throw a TypeError exception.
@item
If len is 0 and initialValue is not present@comma{} throw a TypeError exception.
@item
Let k be len−1.
@item
If initialValue is present@comma{} then
@enumerate
@item
Set accumulator to initialValue.
@end enumerate

@item
Else@comma{} initialValue is not present
@enumerate
@item
Let kPresent be false.
@item
Repeat@comma{} while kPresent is false and k ≥ 0
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let accumulator be the result of calling the [[Get]] internal method of O with argument Pk.
@end enumerate

@item
Decrease k by 1.
@end enumerate

@item
If kPresent is false@comma{} throw a TypeError exception.
@end enumerate

@item
Repeat@comma{} while k ≥ 0
@enumerate
@item
Let Pk be @uref{#sec-9.8,ToString}(k).
@item
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk.
@item
If kPresent is true@comma{} then
@enumerate
@item
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk.
@item
Let accumulator be the result of calling the [[Call]] internal method of callbackfn with undefined as the this value and argument list containing accumulator@comma{} kValue@comma{} k@comma{} and O.
@end enumerate

@item
Decrease k by 1.
@end enumerate

@item
Return accumulator.
@end enumerate

The @code{length} property of the reduceRight method is 1.

NOTE The reduceRight function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the reduceRight function can be applied successfully to a host object is implementation-dependent.


@node 1545 Properties of Array Instances
@chapter @uref{#sec-15.4.5,15.4.5} Properties of Array Instances
Array instances inherit properties from the Array prototype object and their [[Class]] internal property value is "Array". Array instances also have the following properties.


@node 15451 [[DefineOwnProperty]]  P Desc Throw
@chapter @uref{#sec-15.4.5.1,15.4.5.1} [[DefineOwnProperty]] ( P@comma{} Desc@comma{} Throw )
Array objects use a variation of the [[DefineOwnProperty]] internal method used for other native ECMAScript objects (@uref{#sec-8.12.9,8.12.9}).

Assume A is an Array object@comma{} Desc is a @uref{#sec-8.10,Property Descriptor}@comma{} and Throw is a Boolean flag.

In the following algorithm@comma{} the term “Reject” means “If Throw is true@comma{} then throw a TypeError exception@comma{} otherwise return false.”

When the [[DefineOwnProperty]] internal method of A is called with property P@comma{} @uref{#sec-8.10,Property Descriptor} Desc@comma{} and Boolean flag Throw@comma{} the following steps are taken:

@enumerate
@item
Let oldLenDesc be the result of calling the [[GetOwnProperty]] internal method of A passing "length" as the argument. The result will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.
@item
Let oldLen be oldLenDesc.[[Value]].
@item
If P is "length"@comma{} then
@enumerate
@item
If the [[Value]] field of Desc is absent@comma{} then
@enumerate
@item
Return the result of calling the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing "length"@comma{} Desc@comma{} and Throw as arguments.
@end enumerate

@item
Let newLenDesc be a copy of Desc.
@item
Let newLen be @uref{#sec-9.6,ToUint32}(Desc.[[Value]]).
@item
If newLen is not equal to @uref{#sec-9.3,ToNumber}( Desc.[[Value]])@comma{} throw a RangeError exception.
@item
Set newLenDesc.[[Value] to newLen.
@item
If newLen ≥ oldLen@comma{} then
@enumerate
@item
Return the result of calling the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing "length"@comma{} newLenDesc@comma{} and Throw as arguments.
@end enumerate

@item
@uref{#def-reject-for-array,Reject} if oldLenDesc.[[Writable]] is false.
@item
If newLenDesc.[[Writable]] is absent or has the value true@comma{} let newWritable be true.
@item

@enumerate
@item
Need to defer setting the [[Writable]] attribute to false in case any @uref{#def-array-element,elements} cannot be deleted.
@item
Let newWritable be false.
@item
Set newLenDesc.[[Writable]] to true.
@end enumerate

@item
Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing "length"@comma{} newLenDesc@comma{} and Throw as arguments.
@item
If succeeded is false@comma{} return false.
@item
While newLen < oldLen repeat@comma{}
@enumerate
@item
Set oldLen to oldLen − 1.
@item
Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing @uref{#sec-9.8,ToString}(oldLen) and false as arguments.
@item
If deleteSucceeded is false@comma{} then
@enumerate
@item
Set newLenDesc.[[Value] to oldLen+1.
@item
If newWritable is false@comma{} set newLenDesc.[[Writable] to false.
@item
Call the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing "length"@comma{} newLenDesc@comma{} and false as arguments.
@item
@uref{#def-reject-for-array,Reject}.
@end enumerate

@end enumerate

@item
If newWritable is false@comma{} then
@enumerate
@item
Call the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing "length"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Writable]]: false@}@comma{} and false as arguments. This call will always return true.
@end enumerate

@item
Return true.
@end enumerate

@item
Else if P is an array index (@uref{#sec-15.4,15.4})@comma{} then
@enumerate
@item
Let index be @uref{#sec-9.6,ToUint32}(P).
@item
@uref{#def-reject-for-array,Reject} if index ≥ oldLen and oldLenDesc.[[Writable]] is false.
@item
Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing P@comma{} Desc@comma{} and false as arguments.
@item
@uref{#def-reject-for-array,Reject} if succeeded is false.
@item
If index ≥ oldLen
@enumerate
@item
Set oldLenDesc.[[Value]] to index + 1.
@item
Call the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing "length"@comma{} oldLenDesc@comma{} and false as arguments. This call will always return true.
@end enumerate

@item
Return true.
@end enumerate

@item
Return the result of calling the default [[DefineOwnProperty]] internal method (@uref{#sec-8.12.9,8.12.9}) on A passing P@comma{} Desc@comma{} and Throw as arguments.
@end enumerate


@node 15452 length
@chapter @uref{#sec-15.4.5.2,15.4.5.2} length
The @code{length} property of this Array object is a data property whose value is always numerically greater than the name of every deletable property whose name is an array index.

The @code{length} property initially has the attributes @{ [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.

NOTE Attempting to set the length property of an Array object to a value that is numerically less than or equal to the largest numeric property name of an existing array indexed non-deletable property of the array will result in the length being set to a numeric value that is one greater than that largest numeric property name. @uref{#sec-15.4.5.1,See 15.4.5.1}.


@node 155 String Objects
@chapter @uref{#sec-15.5,15.5} String Objects

@node 1551 The String Constructor Called as a Function
@chapter @uref{#sec-15.5.1,15.5.1} The String Constructor Called as a Function
When String is called as a function rather than as a constructor@comma{} it performs a type conversion.


@node 15511 String  [ value ]
@chapter @uref{#sec-15.5.1.1,15.5.1.1} String ( [ value ] )
Returns a String value (not a String object) computed by @uref{#sec-9.8,ToString}(value). If value is not supplied@comma{} the empty String "" is returned.



@node 1552 The String Constructor
@chapter @uref{#sec-15.5.2,15.5.2} The String Constructor
When String is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 15521 new String  [ value ]
@chapter @uref{#sec-15.5.2.1,15.5.2.1} new String ( [ value ] )
The [[Prototype]] internal property of the newly constructed object is set to the standard built-in String prototype object that is the initial value of String.prototype (@uref{#sec-15.5.3.1,15.5.3.1}).

The [[Class]] internal property of the newly constructed object is set to "String".

The [[Extensible]] internal property of the newly constructed object is set to true.

The [[PrimitiveValue]] internal property of the newly constructed object is set to @uref{#sec-9.8,ToString}(value)@comma{} or to the empty String if value is not supplied.


@node 1553 Properties of the String Constructor
@chapter @uref{#sec-15.5.3,15.5.3} Properties of the String Constructor
The value of the [[Prototype]] internal property of the String constructor is the standard built-in Function prototype object (@uref{#sec-15.3.4,15.3.4}).

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} the String constructor has the following properties:


@node 15531 Stringprototype
@chapter @uref{#sec-15.5.3.1,15.5.3.1} String.prototype
The initial value of String.prototype is the standard built-in String prototype object (@uref{#sec-15.5.4,15.5.4}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15532 StringfromCharCode  [ char0 [  char1 [   ] ] ]
@chapter @uref{#sec-15.5.3.2,15.5.3.2} String.fromCharCode ( [ char0 [ @comma{} char1 [ @comma{} ... ] ] ] )
Returns a String value containing as many characters as the number of arguments. Each argument specifies one character of the resulting String@comma{} with the first argument specifying the first character@comma{} and so on@comma{} from left to right. An argument is converted to a character by applying the operation @uref{#sec-9.7,ToUint16} (@uref{#sec-9.7,9.7}) and regarding the resulting 16-bit integer as the code unit value of a character. If no arguments are supplied@comma{} the result is the empty String.

The @code{length} property of the fromCharCode function is 1.


@node 1554 Properties of the String Prototype Object
@chapter @uref{#sec-15.5.4,15.5.4} Properties of the String Prototype Object
The String prototype object is itself a String object (its [[Class]] is "String") whose value is an empty String.

The value of the [[Prototype]] internal property of the String prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).


@node 15541 Stringprototypeconstructor
@chapter @uref{#sec-15.5.4.1,15.5.4.1} String.prototype.constructor
The initial value of String.prototype.constructor is the built-in String constructor.


@node 15542 StringprototypetoString
@chapter @uref{#sec-15.5.4.2,15.5.4.2} String.prototype.toString ( )
Returns this String value. (Note that@comma{} for a String object@comma{} the @code{toString} method happens to return the same thing as the @code{valueOf} method.)




@node 15543 StringprototypevalueOf
@chapter @uref{#sec-15.5.4.3,15.5.4.3} String.prototype.valueOf ( )
Returns this String value.

The valueOf function is not generic; it throws a TypeError exception if its this value is not a String or String object. Therefore@comma{} it cannot be transferred to other kinds of objects for use as a method.


@node 15544 StringprototypecharAt pos
@chapter @uref{#sec-15.5.4.4,15.5.4.4} String.prototype.charAt (pos)
Returns a String containing the character at position pos in the String resulting from converting this object to a String. If there is no character at that position@comma{} the result is the empty String. The result is a String value@comma{} not a String object.

If pos is a value of Number type that is an integer@comma{} then the result of @code{x.charAt(<var>pos</var>)} is equal to the result of @code{x.substring(<var>pos</var>@comma{} <wbr /><var>pos</var>+1)}.

When the charAt method is called with one argument pos@comma{} the following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let position be @uref{#sec-9.4,ToInteger}(pos).
@item
Let size be the number of characters in S.
@item
If position < 0 or position ≥ size@comma{} return the empty String.
@item
Return a String of length 1@comma{} containing one character from S@comma{} namely the character at position position@comma{} where the first (leftmost) character in S is considered to be at position 0@comma{} the next one at position 1@comma{} and so on.
@end enumerate

NOTE The charAt function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 15545 StringprototypecharCodeAt pos
@chapter @uref{#sec-15.5.4.5,15.5.4.5} String.prototype.charCodeAt (pos)
Returns a Number (a nonnegative integer less than 2^16) representing the code unit value of the character at position pos in the String resulting from converting this object to a String. If there is no character at that position@comma{} the result is NaN.

When the charCodeAt method is called with one argument pos@comma{} the following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let position be @uref{#sec-9.4,ToInteger}(pos).
@item
Let size be the number of characters in S.
@item
If position < 0 or position ≥ size@comma{} return NaN.
@item
Return a value of Number type@comma{} whose value is the code unit value of the character at position position in the String S@comma{} where the first (leftmost) character in S is considered to be at position 0@comma{} the next one at position 1@comma{} and so on.
@end enumerate

NOTE The charCodeAt function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.


@node 15546 Stringprototypeconcat  [ string1 [  string2 [   ] ] ]
@chapter @uref{#sec-15.5.4.6,15.5.4.6} String.prototype.concat ( [ string1 [ @comma{} string2 [ @comma{} ... ] ] ] )
When the concat method is called with zero or more arguments string1@comma{} string2@comma{} etc.@comma{} it returns a String consisting of the characters of this object (converted to a String) followed by the characters of each of string1@comma{} string2@comma{} etc. (where each argument is converted to a String). The result is a String value@comma{} not a String object. The following steps are taken:

@enumerate
@item

@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let args be an internal list that is a copy of the argument list passed to this function.
@item
Let R be S.
@item
Repeat@comma{} while args is not empty
@enumerate
@item
Remove the first element from args and let next be the value of that element.
@item
Let R be the String value consisting of the characters in the previous value of R followed by the characters of @uref{#sec-9.8,ToString}(next).
@end enumerate

@item
Return R.
@end enumerate

The @code{length} property of the concat method is 1.

NOTE The concat function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.


@node 15547 StringprototypeindexOf searchString position
@chapter @uref{#sec-15.5.4.7,15.5.4.7} String.prototype.indexOf (searchString@comma{} position)
If searchString appears as a substring of the result of converting this object to a String@comma{} at one or more positions that are greater than or equal to position@comma{} then the index of the smallest such position is returned; otherwise@comma{} −1 is returned. If position is undefined@comma{} 0 is assumed@comma{} so as to search all of the String.

The indexOf method takes two arguments@comma{} searchString and position@comma{} and performs the following steps:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let searchStr be @uref{#sec-9.8,ToString}(searchString).
@item
Let pos be @uref{#sec-9.4,ToInteger}(position). (If position is undefined@comma{} this step produces the value 0).
@item
Let len be the number of characters in S.
@item
Let start be min(max(pos@comma{} 0)@comma{} len).
@item
Let searchLen be the number of characters in searchStr.
@item
Return the smallest possible integer k not smaller than start such that k+searchLen is not greater than len@comma{} and for all nonnegative integers j less than searchLen@comma{} the character at position k+j of S is the same as the character at position j of searchStr); but if there is no such integer k@comma{} then return the value −1.
@end enumerate

The @code{length} property of the indexOf method is 1.

NOTE The indexOf function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 15548 StringprototypelastIndexOf searchString position
@chapter @uref{#sec-15.5.4.8,15.5.4.8} String.prototype.lastIndexOf (searchString@comma{} position)
If searchString appears as a substring of the result of converting this object to a String at one or more positions that are smaller than or equal to position@comma{} then the index of the greatest such position is returned; otherwise@comma{} −1 is returned. If position is undefined@comma{} the length of the String value is assumed@comma{} so as to search all of the String.

The lastIndexOf method takes two arguments@comma{} searchString and position@comma{} and performs the following steps:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let searchStr be @uref{#sec-9.8,ToString}(searchString).
@item
Let numPos be @uref{#sec-9.3,ToNumber}(position). (If position is undefined@comma{} this step produces the value NaN).
@item
If numPos is NaN@comma{} let pos be +∞; otherwise@comma{} let pos be @uref{#sec-9.4,ToInteger}(numPos).
@item
Let len be the number of characters in S.
@item
Let start min(max(pos@comma{} 0)@comma{} len).
@item
Let searchLen be the number of characters in searchStr.
@item

@end enumerate

The @code{length} property of the lastIndexOf method is 1.

NOTE The lastIndexOf function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 15549 StringprototypelocaleCompare that
@chapter @uref{#sec-15.5.4.9,15.5.4.9} String.prototype.localeCompare (that)
When the localeCompare method is called with one argument that@comma{} it returns a Number other than NaN that represents the result of a locale-sensitive String comparison of the this value (converted to a String) with that (converted to a String). The two Strings are S and that. The two Strings are compared in an implementation-defined fashion. The result is intended to order String values in the sort order specified by the system default locale@comma{} and will be negative@comma{} zero@comma{} or positive@comma{} depending on whether S comes before that in the sort order@comma{} the Strings are equal@comma{} or S comes after that in the sort order@comma{} respectively.

Before perform the comparisons the following steps are performed to prepare the Strings:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let That be @uref{#sec-9.8,ToString}(that).
@end enumerate

The localeCompare method@comma{} if considered as a function of two arguments this and that@comma{} is a consistent comparison function (as defined in @uref{#sec-15.4.4.11,15.4.4.11}) on the set of all Strings. Furthermore@comma{} localeCompare returns 0 or −0 when comparing two Strings that are considered canonically equivalent by the Unicode standard.

The actual return values are implementation-defined to permit implementers to encode additional information in the value@comma{} but the function is required to define a total ordering on all Strings and to return 0 when comparing Strings that are considered canonically equivalent by the Unicode standard.

If no language-sensitive comparison at all is available from the host environment@comma{} this function may perform a bitwise comparison.

NOTE 1 The localeCompare method itself is not directly suitable as an argument to Array.prototype.sort because the latter requires a function of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive comparison functionality is available to the ECMAScript environment from the host environment@comma{} and to compare according to the rules of the host environment’s current locale. It is strongly recommended that this function treat Strings that are canonically equivalent according to the Unicode standard as identical (in other words@comma{} compare the Strings as if they had both been converted to Normalised Form C or D first). It is also recommended that this function not honour Unicode compatibility equivalences or decompositions.

NOTE 3 The second parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.

NOTE 4 The localeCompare function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155410 Stringprototypematch regexp
@chapter @uref{#sec-15.5.4.10,15.5.4.10} String.prototype.match (regexp)
When the match method is called with argument regexp@comma{} the following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
If @uref{#def-type,Type}(regexp) is Object and the value of the [[Class]] internal property of regexp is "RegExp"@comma{} then let rx be regexp;
@item
Else@comma{} let rx be a new RegExp object created as if by the expression @code{new RegExp(<var>regexp</var>)} where @code{RegExp} is the standard built-in constructor with that name.
@item
Let global be the result of calling the [[Get]] internal method of rx with argument "global".
@item
Let exec be the standard built-in function RegExp.prototype.exec (@uref{#sec-15.10.6.2,see 15.10.6.2})
@item
If global is not true@comma{} then
@enumerate
@item
Return the result of calling the [[Call]] internal method of exec with rx as the this value and argument list containing S.
@end enumerate

@item
Else@comma{} global is true
@enumerate
@item
Call the [[Put]] internal method of rx with arguments "lastIndex" and 0.
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let previousLastIndex be 0.
@item
Let n be 0.
@item
Let lastMatch be true.
@item
Repeat@comma{} while lastMatch is true
@enumerate
@item
Let result be the result of calling the [[Call]] internal method of exec with rx as the this value and argument list containing S.
@item
If result is null@comma{} then set lastMatch to false.
@item
Else@comma{} result is not null
@enumerate
@item
Let thisIndex be the result of calling the [[Get]] internal method of rx with argument "lastIndex".
@item
If thisIndex = previousLastIndex then
@enumerate
@item
Call the [[Put]] internal method of rx with arguments "lastIndex" and thisIndex+1.
@item
Set previousLastIndex to thisIndex+1.
@end enumerate

@item
Else@comma{} set previousLastIndex to thisIndex.
@item
Let matchStr be the result of calling the [[Get]] internal method of result with argument "0".
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(n)@comma{} the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: matchStr@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[configurable]]: true@}@comma{} and false.
@item
Increment n.
@end enumerate

@end enumerate

@item
If n = 0@comma{} then return null.
@item
Return A.
@end enumerate

@end enumerate

NOTE The match function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155411 Stringprototypereplace searchValue replaceValue
@chapter @uref{#sec-15.5.4.11,15.5.4.11} String.prototype.replace (searchValue@comma{} replaceValue)
First set string according to the following steps:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let string be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@end enumerate

If searchValue is a regular expression (an object whose [[Class]] internal property is "RegExp")@comma{} do the following: If searchValue.global is false@comma{} then search string for the first match of the regular expression searchValue. If searchValue.global is true@comma{} then search string for all matches of the regular expression searchValue. Do the search in the same manner as in String.prototype.match@comma{} including the update of searchValue@code{.lastIndex}. Let m be the number of left capturing parentheses in searchValue (using @uref{#def-NcapturingParens,NcapturingParens} as specified in @uref{#sec-15.10.2.1,15.10.2.1}).

If searchValue is not a regular expression@comma{} let searchString be @uref{#sec-9.8,ToString}(searchValue) and search string for the first occurrence of searchString. Let m be 0.

If replaceValue is a function@comma{} then for each matched substring@comma{} call the function with the following m + 3 arguments. Argument 1 is the substring that matched. If searchValue is a regular expression@comma{} the next m arguments are all of the captures in the MatchResult (@uref{#sec-15.10.2.1,see 15.10.2.1}). Argument m + 2 is the offset within string where the match occurred@comma{} and argument m + 3 is string. The result is a String value derived from the original

Otherwise@comma{} let newstring denote the result of converting replaceValue to a String. The result is a String value derived from the original input String by replacing each matched substring with a String derived from newstring by replacing characters in newstring by replacement text as specified in Table 22. These @code{$} replacements are done left-to-right@comma{} and@comma{} once such a replacement is performed@comma{} the new replacement text is not subject to further replacements. For example@comma{} @code{"$1@comma{}$2".replace(/(\$(\d))/g@comma{} "$$1-$1$2")} returns @code{"$1-$11@comma{}$1-$22"}. A @code{$} in newstring that does not match any of the forms below is left as is.

Table 22 — Replacement Text Symbol Substitutions
Characters
Replacement text
@code{$$}
@code{$}
@code{$&}
The matched substring.
@code{$`}
The portion of string that precedes the matched substring.
@code{$?}
The portion of string that follows the matched substring.
@code{$<var>n</var>}
The nth capture@comma{} where n is a single digit in the range 1 to 9 and @code{$}n is not followed by a decimal digit. If n≤m and the nth capture is undefined@comma{} use the empty String instead. If n>m@comma{} the result is implementation-defined.
@code{$<var>nn</var>}
The nnth capture@comma{} where nn is a two-digit decimal number in the range 01 to 99. If nn≤m and the nnth capture is undefined@comma{} use the empty String instead. If nn>m@comma{} the result is implementation-defined.
NOTE The replace function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155412 Stringprototypesearch regexp
@chapter @uref{#sec-15.5.4.12,15.5.4.12} String.prototype.search (regexp)
When the search method is called with argument regexp@comma{} the following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let string be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
If @uref{#def-type,Type}(regexp) is Object and the value of the [[Class]] internal property of regexp is "RegExp"@comma{} then let rx be regexp;
@item
Else@comma{} let rx be a new RegExp object created as if by the expression @code{new RegExp(<var>regexp</var>)} where @code{RegExp} is the standard built-in constructor with that name.
@item
Search the value string from its beginning for an occurrence of the regular expression pattern rx. Let result be a Number indicating the offset within string where the pattern matched@comma{} or −1 if there was no match. The @code{lastIndex} and @code{global} properties of regexp are ignored when performing the search. The @code{lastIndex} property of regexp is left unchanged.
@item
Return result.
@end enumerate

NOTE The search function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155413 Stringprototypeslice start end
@chapter @uref{#sec-15.5.4.13,15.5.4.13} String.prototype.slice (start@comma{} end)
The slice method takes two arguments@comma{} start and end@comma{} and returns a substring of the result of converting this object to a String@comma{} starting from character position start and running to@comma{} but not including@comma{} character position end (or through the end of the String if end is undefined). If start is negative@comma{} it is treated as sourceLength+start where sourceLength is the length of the String. If end is negative@comma{} it is treated as sourceLength+end where sourceLength is the length of the String. The result is a String value@comma{} not a String object. The following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let len be the number of characters in S.
@item
Let intStart be @uref{#sec-9.4,ToInteger}(start).
@item
If end is undefined@comma{} let intEnd be len; else let intEnd be @uref{#sec-9.4,ToInteger}(end).
@item
If intStart is negative@comma{} let from be max(len + intStart@comma{}0); else let from be min(intStart@comma{} len).
@item
If intEnd is negative@comma{} let to be max(len + intEnd@comma{}0); else let to be min(intEnd@comma{} len).
@item
Let span be max(to − from@comma{}0).
@item
Return a String containing span consecutive characters from S beginning with the character at position from.
@end enumerate

The @code{length} property of the slice method is 2.

NOTE The slice function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.


@node 155414 Stringprototypesplit separator limit
@chapter @uref{#sec-15.5.4.14,15.5.4.14} String.prototype.split (separator@comma{} limit)
Returns an Array object into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of separator; these occurrences are not part of any substring in the returned array@comma{} but serve to divide up the String value. The value of separator may be a String of any length or it may be a RegExp object (i.e.@comma{} an object whose [[Class]] internal property is "RegExp"; @uref{#sec-15.10,see 15.10}).

The value of separator may be an empty String@comma{} an empty regular expression@comma{} or a regular expression that can match an empty String. In this case@comma{} separator does not match the empty substring at the beginning or end of the input String@comma{} nor does it match the empty substring at the end of the previous separator match. (For example@comma{} if separator is the empty String@comma{} the String is split up into individual characters; the length of the result array equals the length of the String@comma{} and each substring contains one character.) If separator is a regular expression@comma{} only the first match at a given position of the this String is considered@comma{} even if backtracking could yield a non-empty-substring match at that position. (For example@comma{} @code{"ab".split(/a*?/)} evaluates to the array @code{["a"@comma{}"b"]}@comma{} while @code{"ab".split(/a*/)} evaluates to the array @code{[""@comma{}"b"]}.)

If the this object is (or converts to) the empty String@comma{} the result depends on whether separator can match the empty String. If it can@comma{} the result array contains no @uref{#def-array-element,elements}. Otherwise@comma{} the result array contains one element@comma{} which is the empty String.

If separator is a regular expression that contains capturing parentheses@comma{} then each time separator is matched the results (including any undefined results) of the capturing parentheses are spliced into the output array. For example@comma{}
@verbatim
"A<B>bold</B>and<CODE>coded</CODE>".split(/<(\/)?([^<>]+)>/)
@end verbatim

evaluates to the array
@verbatim
["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]
@end verbatim

If separator is undefined@comma{} then the result array contains just one String@comma{} which is the this value (converted to a String). If limit is not undefined@comma{} then the output array is truncated so that it contains no more than limit elements.

When the split method is called@comma{} the following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let lengthA be 0.
@item
If limit is undefined@comma{} let lim = 2^32−1; else let lim = @uref{#sec-9.6,ToUint32}(limit).
@item
Let s be the number of characters in S.
@item
Let p = 0.
@item
If separator is a RegExp object (its [[Class]] is "RegExp")@comma{} let R = separator; otherwise let R = @uref{#sec-9.8,ToString}(separator).
@item
If lim = 0@comma{} return A.
@item
If separator is undefined@comma{} then
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of A with arguments "0"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: S@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return A.
@end enumerate

@item
If s = 0@comma{} then
@enumerate
@item
Call SplitMatch(R@comma{} S@comma{} 0) and let z be its MatchResult result.
@item
If z is not failure@comma{} return A.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments "0"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: S@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return A.
@end enumerate

@item
Let q = p.
@item
Repeat@comma{} while q ≠ s
@enumerate
@item
Call SplitMatch(R@comma{} S@comma{} q) and let z be its MatchResult result.
@item
If z is failure@comma{} then let q = q+1.
@item
Else@comma{} z is not failure
@enumerate
@item
z must be a State. Let e be z’s endIndex and let cap be z’s captures array.
@item
If e = p@comma{} then let q = q+1.
@item
Else@comma{} e ≠ p
@enumerate
@item
Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive) through q (exclusive).
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(lengthA)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: T@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Increment lengthA by 1.
@item
If lengthA = lim@comma{} return A.
@item
Let p = e.
@item
Let i = 0.
@item
Repeat@comma{} while i is not equal to the number of elements in cap.
@enumerate
@item
Let i = i+1.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(lengthA)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: cap[i]@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Increment lengthA by 1.
@item
If A@code{.length} = lim@comma{} return A.
@end enumerate

@item
Let q = p.
@end enumerate

@end enumerate

@end enumerate

@item
Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive) through s (exclusive).
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(lengthA)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: T@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return A.
@end enumerate

The abstract operation SplitMatch takes three parameters@comma{} a String S@comma{} an integer q@comma{} and a String or RegExp R@comma{} and performs the following in order to return a MatchResult (@uref{#sec-15.10.2.1,see 15.10.2.1}):

@enumerate
@item
If r is a RegExp object (its [[Class]] is "RegExp")@comma{} then
@enumerate
@item
Call the [[Match]] internal method of r giving it the arguments s and q@comma{} and return the MatchResult result.
@end enumerate

@item
@uref{#def-type,Type}(r) must be String. Let r be the number of characters in r.
@item
Let s be the number of characters in s.
@item
If q+r > s then return the MatchResult failure.
@item
If there exists an integer i between 0 (inclusive) and r (exclusive) such that the character at position q+i of s is different from the character at position i of r@comma{} then return failure.
@item
Let cap be an empty array of captures (@uref{#sec-15.10.2.1,see 15.10.2.1}).
@item
Return the State (q+r@comma{} cap). (@uref{#sec-15.10.2.1,see 15.10.2.1})
@end enumerate

The @code{length} property of the split method is 2.

NOTE 1 The split method ignores the value of separator@code{.global} for separators that are RegExp objects.


NOTE 2 The split function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155415 Stringprototypesubstring start end
@chapter @uref{#sec-15.5.4.15,15.5.4.15} String.prototype.substring (start@comma{} end)
The substring method takes two arguments@comma{} start and end@comma{} and returns a substring of the result of converting this object to a String@comma{} starting from character position start and running to@comma{} but not including@comma{} character position end of the String (or through the end of the String is end is undefined). The result is a String value@comma{} not a String object.

If either argument is NaN or negative@comma{} it is replaced with zero; if either argument is larger than the length of the String@comma{} it is replaced with the length of the String.

If start is larger than end@comma{} they are swapped.

The following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let len be the number of characters in S.
@item
Let intStart be @uref{#sec-9.4,ToInteger}(start).
@item
If end is undefined@comma{} let intEnd be len; else let intEnd be @uref{#sec-9.4,ToInteger}(end).
@item
Let finalStart be min(max(intStart@comma{} 0)@comma{} len).
@item
Let finalEnd be min(max(intEnd@comma{} 0)@comma{} len).
@item
Let from be min(finalStart@comma{} finalEnd).
@item
Let to be max(finalStart@comma{} finalEnd).
@item
Return a String whose length is to − from@comma{} containing characters from S@comma{} namely the characters with indices from through to−1@comma{} in ascending order.
@end enumerate

The @code{length} property of the substring method is 2.

NOTE The substring function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155416 StringprototypetoLowerCase
@chapter @uref{#sec-15.5.4.16,15.5.4.16} String.prototype.toLowerCase ( )
The following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let L be a String where each character of L is either the Unicode lowercase equivalent of the corresponding character of S or the actual corresponding character of S if no Unicode lowercase equivalent exists.
@item
Return L.
@end enumerate

For the purposes of this operation@comma{} the 16-bit code units of the Strings are treated as code points in the Unicode Basic Multilingual Plane. Surrogate code points are directly transferred from S to L without any mapping.

The result must be derived according to the case mappings in the Unicode character database (this explicitly includes not only the UnicodeData.txt file@comma{} but also the SpecialCasings.txt file that accompanies it in Unicode 2.1.8 and later).

NOTE 1 The case mapping of some characters may produce multiple characters. In this case the result String may not be the same length as the source String. Because both toUpperCase and toLowerCase have context-sensitive behaviour@comma{} the functions are not symmetrical. In other words@comma{} @code{s.toUpperCase().toLowerCase()} is not necessarily equal to @code{s.toLowerCase()}.

NOTE 2 The toLowerCase function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.



@node 155417 StringprototypetoLocaleLowerCase
@chapter @uref{#sec-15.5.4.17,15.5.4.17} String.prototype.toLocaleLowerCase ( )
This function works exactly the same as toLowerCase except that its result is intended to yield the correct result for the host environment’s current locale@comma{} rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.

NOTE 2 The toLocaleLowerCase function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155418 StringprototypetoUpperCase
@chapter @uref{#sec-15.5.4.18,15.5.4.18} String.prototype.toUpperCase ( )
This function behaves in exactly the same way as String.prototype.toLowerCase@comma{} except that characters are mapped to their @emph{uppercase} equivalents as specified in the Unicode Character Database.

NOTE The toUpperCase function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155419 StringprototypetoLocaleUpperCase
@chapter @uref{#sec-15.5.4.19,15.5.4.19} String.prototype.toLocaleUpperCase ( )
This function works exactly the same as toUpperCase except that its result is intended to yield the correct result for the host environment’s current locale@comma{} rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.

NOTE 2 The toLocaleUpperCase function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 155420 Stringprototypetrim
@chapter @uref{#sec-15.5.4.20,15.5.4.20} String.prototype.trim ( )
The following steps are taken:

@enumerate
@item
Call @uref{#sec-9.10,CheckObjectCoercible} passing the this value as its argument.
@item
Let S be the result of calling @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Let T be a String value that is a copy of S with both leading and trailing white space removed. The definition of white space is the union of WhiteSpace and LineTerminator.
@item
Return T.
@end enumerate

NOTE The trim function is intentionally generic; it does not require that its this value be a String object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method.


@node 1555 Properties of String Instances
@chapter @uref{#sec-15.5.5,15.5.5} Properties of String Instances
String instances inherit properties from the String prototype object and their [[Class]] internal property value is "String". String instances also have a [[PrimitiveValue]] internal property@comma{} a @code{length} property@comma{} and a set of enumerable properties with array index names.

The [[PrimitiveValue]] internal property is the String value represented by this String object. The array index named properties correspond to the individual characters of the String value. A special [[GetOwnProperty]] internal method is used to specify the number@comma{} values@comma{} and attributes of the array index named properties.



@node 15551 length
@chapter @uref{#sec-15.5.5.1,15.5.5.1} length
The number of characters in the String value represented by this String object.

Once a String object is created@comma{} this property is unchanging. It has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15552 [[GetOwnProperty]]  P
@chapter @uref{#sec-15.5.5.2,15.5.5.2} [[GetOwnProperty]] ( P )
String objects use a variation of the [[GetOwnProperty]] internal method used for other native ECMAScript objects (@uref{#sec-8.12.1,8.12.1}). This special internal method is used to add access for named properties corresponding to individual characters of String objects.

Assume S is a String object and P is a String.

When the [[GetOwnProperty]] internal method of S is called with property name P@comma{} the following steps are taken:

@enumerate
@item
Let desc be the result of calling the default [[GetOwnProperty]] internal method (@uref{#sec-8.12.1,8.12.1}) on S with argument P.
@item
If desc is not undefined return desc.
@item
If @uref{#sec-9.8,ToString}(@uref{#def-abs,abs}(@uref{#sec-9.4,ToInteger}(P))) is not the same value as P@comma{} return undefined.
@item
Let str be the String value of the [[PrimitiveValue]] internal property of S.
@item
Let index be @uref{#sec-9.4,ToInteger}(P).
@item
Let len be the number of characters in str.
@item
If len ≤ index@comma{} return undefined.
@item
Let resultStr be a String of length 1@comma{} containing one character from str@comma{} specifically the character at position index@comma{} where the first (leftmost) character in str is considered to be at position 0@comma{} the next one at position 1@comma{} and so on.
@item
Return a @uref{#sec-8.10,Property Descriptor} @{ [[Value]]: resultStr@comma{} [[Enumerable]]: true@comma{} [[Writable]]: false@comma{} [[Configurable]]: false @}
@end enumerate


@node 156 Boolean Objects
@chapter @uref{#sec-15.6,15.6} Boolean Objects

@node 1561 The Boolean Constructor Called as a Function
@chapter @uref{#sec-15.6.1,15.6.1} The Boolean Constructor Called as a Function
When Boolean is called as a function rather than as a constructor@comma{} it performs a type conversion.


@node 15611 Boolean value
@chapter @uref{#sec-15.6.1.1,15.6.1.1} Boolean (value)
Returns a Boolean value (not a Boolean object) computed by @uref{#sec-9.2,ToBoolean}(value).


@node 1562 The Boolean Constructor
@chapter @uref{#sec-15.6.2,15.6.2} The Boolean Constructor
When Boolean is called as part of a @code{new} expression it is a constructor: it initialises the newly created object.


@node 15621 new Boolean value
@chapter @uref{#sec-15.6.2.1,15.6.2.1} new Boolean (value)
The [[Prototype]] internal property of the newly constructed object is set to the original Boolean prototype object@comma{} the one that is the initial value of Boolean.prototype (@uref{#sec-15.6.3.1,15.6.3.1}).

The [[Class]] internal property of the newly constructed Boolean object is set to "Boolean".

The [[PrimitiveValue]] internal property of the newly constructed Boolean object is set to @uref{#sec-9.2,ToBoolean}(value).

The [[Extensible]] internal property of the newly constructed object is set to true.



@node 1563 Properties of the Boolean Constructor
@chapter @uref{#sec-15.6.3,15.6.3} Properties of the Boolean Constructor
The value of the [[Prototype]] internal property of the Boolean constructor is @uref{#sec-15.3.4,the Function prototype object (15.3.4)}.

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} the Boolean constructor has the following property:


@node 15631 Booleanprototype
@chapter @uref{#sec-15.6.3.1,15.6.3.1} Boolean.prototype
The initial value of Boolean.prototype is the Boolean prototype object (@uref{#sec-15.6.4,15.6.4}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 1564 Properties of the Boolean Prototype Object
@chapter @uref{#sec-15.6.4,15.6.4} Properties of the Boolean Prototype Object
The Boolean prototype object is itself a Boolean object (its [[Class]] is "Boolean") whose value is false.

The value of the [[Prototype]] internal property of the Boolean prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).


@node 15641 Booleanprototypeconstructor
@chapter @uref{#sec-15.6.4.1,15.6.4.1} Boolean.prototype.constructor
The initial value of Boolean.prototype.constructor is the built-in Boolean constructor.


@node 15642 BooleanprototypetoString
@chapter @uref{#sec-15.6.4.2,15.6.4.2} Boolean.prototype.toString ( )
The following steps are taken:

@enumerate
@item
Let B be the this value.
@item
If @uref{#def-type,Type}(B) is Boolean@comma{} then let b be B.
@item
Else if @uref{#def-type,Type}(B) is Object and the value of the [[Class]] internal property of B is "Boolean"@comma{} then let b be the value of the [[PrimitiveValue]] internal property of B.
@item
Else throw a TypeError exception.
@item
If b is true@comma{} then return "true"; else return "false".
@end enumerate


@node 15643 BooleanprototypevalueOf
@chapter @uref{#sec-15.6.4.3,15.6.4.3} Boolean.prototype.valueOf ( )
The following steps are taken:

@enumerate
@item
Let B be the this value.
@item
If @uref{#def-type,Type}(B) is Boolean@comma{} then let b be B.
@item
Else if @uref{#def-type,Type}(B) is Object and the value of the [[Class]] internal property of B is "Boolean"@comma{} then let b be the value of the [[PrimitiveValue]] internal property of B.
@item
Else throw a TypeError exception.
@item
Return b.
@end enumerate


@node 1565 Properties of Boolean Instances
@chapter @uref{#sec-15.6.5,15.6.5} Properties of Boolean Instances
Boolean instances inherit properties from the Boolean prototype object and their [[Class]] internal property value is "Boolean". Boolean instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is the Boolean value represented by this Boolean object.



@node 157 Number Objects
@chapter @uref{#sec-15.7,15.7} Number Objects

@node 1571 The Number Constructor Called as a Function
@chapter @uref{#sec-15.7.1,15.7.1} The Number Constructor Called as a Function
When Number is called as a function rather than as a constructor@comma{} it performs a type conversion.


@node 15711 Number  [ value ]
@chapter @uref{#sec-15.7.1.1,15.7.1.1} Number ( [ value ] )
Returns a Number value (not a Number object) computed by @uref{#sec-9.3,ToNumber}(value) if value was supplied@comma{} else returns +0.


@node 1572 The Number Constructor
@chapter @uref{#sec-15.7.2,15.7.2} The Number Constructor
When Number is called as part of a @code{new} expression it is a constructor: it initialises the newly created object.


@node 15721 new Number  [ value ]
@chapter @uref{#sec-15.7.2.1,15.7.2.1} new Number ( [ value ] )
The [[Prototype]] internal property of the newly constructed object is set to the original Number prototype object@comma{} the one that is the initial value of Number.prototype (@uref{#sec-15.7.3.1,15.7.3.1}).

The [[Class]] internal property of the newly constructed object is set to "Number".

The [[PrimitiveValue]] internal property of the newly constructed object is set to @uref{#sec-9.3,ToNumber}(value) if value was supplied@comma{} else to +0.

The [[Extensible]] internal property of the newly constructed object is set to true.


@node 1573 Properties of the Number Constructor
@chapter @uref{#sec-15.7.3,15.7.3} Properties of the Number Constructor
The value of the [[Prototype]] internal property of the Number constructor is @uref{#sec-15.3.4,the Function prototype object (15.3.4)}.

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} the Number constructor has the following properties:


@node 15731 Numberprototype
@chapter @uref{#sec-15.7.3.1,15.7.3.1} Number.prototype
The initial value of Number.prototype is the Number prototype object (@uref{#sec-15.7.4,15.7.4}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15732 NumberMAX_VALUE
@chapter @uref{#sec-15.7.3.2,15.7.3.2} Number.MAX_VALUE
The value of Number.MAX_VALUE is the largest positive finite value of the Number type@comma{} which is approximately 1.7976931348623157 × 10^308.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15733 NumberMIN_VALUE
@chapter @uref{#sec-15.7.3.3,15.7.3.3} Number.MIN_VALUE
The value of Number.MIN_VALUE is the smallest positive value of the Number type@comma{} which is approximately 5 × 10^−324.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.



@node 15734 NumberNaN
@chapter @uref{#sec-15.7.3.4,15.7.3.4} Number.NaN
The value of Number.NaN is NaN.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15735 NumberNEGATIVE_INFINITY
@chapter @uref{#sec-15.7.3.5,15.7.3.5} Number.NEGATIVE_INFINITY
The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15736 NumberPOSITIVE_INFINITY
@chapter @uref{#sec-15.7.3.6,15.7.3.6} Number.POSITIVE_INFINITY
The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 1574 Properties of the Number Prototype Object
@chapter @uref{#sec-15.7.4,15.7.4} Properties of the Number Prototype Object
The Number prototype object is itself a Number object (its [[Class]] is "Number") whose value is +0.

The value of the [[Prototype]] internal property of the Number prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).

Unless explicitly stated otherwise@comma{} the methods of the Number prototype object defined below are not generic and the this value passed to them must be either a Number value or an Object for which the value of the [[Class]] internal property is "Number".

In the following descriptions of functions that are properties of the Number prototype object@comma{} the phrase “this Number object” refers to either the object that is the this value for the invocation of the function or@comma{} if @uref{#def-type,Type}(this value) is Number@comma{} an object that is created as if by the expression @code{new Number(<var><span class="this">this</span> value</var>)} where @code{Number} is the standard built-in constructor with that name. Also@comma{} the phrase “this Number value” refers to either the Number value represented by this Number object@comma{} that is@comma{} the value of the [[PrimitiveValue]] internal property of this Number object or the this value if its type is Number. A TypeError exception is thrown if the this value is neither an object for which the value of the [[Class]] internal property is "Number" or a value whose type is Number.


@node 15741 Numberprototypeconstructor
@chapter @uref{#sec-15.7.4.1,15.7.4.1} Number.prototype.constructor
The initial value of Number.prototype.constructor is the built-in Number constructor.


@node 15742 NumberprototypetoString  [ radix ]
@chapter @uref{#sec-15.7.4.2,15.7.4.2} Number.prototype.toString ( [ radix ] )
The optional radix should be an integer value in the inclusive range 2 to 36. If radix not present or is undefined the Number 10 is used as the value of radix. If @uref{#sec-9.4,ToInteger}(radix) is the Number 10 then @uref{#def-this-Number-value,this Number value} is given as an argument to the @uref{#sec-9.8,ToString} abstract operation; the resulting String value is returned.

If @uref{#sec-9.4,ToInteger}(radix) is not an integer between 2 and 36 inclusive throw a RangeError exception. If @uref{#sec-9.4,ToInteger}(radix) is an integer from 2 to 36@comma{} but not 10@comma{} the result is a String representation of @uref{#def-this-Number-value,this Number value} using the specified radix. Letters @code{a}-@code{z} are used for digits with values 10 through 35. The precise algorithm is implementation-dependent if the radix is not 10@comma{} however the algorithm should be a generalization of that specified in @uref{#sec-9.8.1,9.8.1}.

The toString function is not generic; it throws a TypeError exception if its this value is not a Number or a Number object. Therefore@comma{} it cannot be transferred to other kinds of objects for use as a method.



@node 15743 NumberprototypetoLocaleString
@chapter @uref{#sec-15.7.4.3,15.7.4.3} Number.prototype.toLocaleString()
Produces a String value that represents @uref{#def-this-Number-value,this Number value} formatted according to the conventions of the host environment’s current locale. This function is implementation-dependent@comma{} and it is permissible@comma{} but not encouraged@comma{} for it to return the same thing as toString.

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.


@node 15744 NumberprototypevalueOf
@chapter @uref{#sec-15.7.4.4,15.7.4.4} Number.prototype.valueOf ( )
Returns @uref{#def-this-Number-value,this Number value}.

The valueOf function is not generic; it throws a TypeError exception if its this value is not a Number or a Number object. Therefore@comma{} it cannot be transferred to other kinds of objects for use as a method.


@node 15745 NumberprototypetoFixed fractionDigits
@chapter @uref{#sec-15.7.4.5,15.7.4.5} Number.prototype.toFixed (fractionDigits)
Return a String containing @uref{#def-this-Number-value,this Number value} represented in decimal fixed-point notation with fractionDigits digits after the decimal point. If fractionDigits is undefined@comma{} 0 is assumed. Specifically@comma{} perform the following steps:

@enumerate
@item
Let f be @uref{#sec-9.4,ToInteger}(fractionDigits). (If fractionDigits is undefined@comma{} this step produces the value 0).
@item
If f < 0 or f > 20@comma{} throw a RangeError exception.
@item
Let x be @uref{#def-this-Number-value,this Number value}.
@item
If x is NaN@comma{} return the String "NaN".
@item
Let s be the empty String.
@item
If x < 0@comma{} then
@enumerate
@item
Let s be "-".
@item
Let x = −x.
@end enumerate

@item
If x ≥ 10^21@comma{} then
@enumerate
@item
Let m = @uref{#sec-9.8,ToString}(x).
@end enumerate

@item
Else@comma{} x < 10^21
@enumerate
@item
Let n be an integer for which the exact mathematical value of n ÷ 10^f − x is as close to zero as possible. If there are two such n@comma{} pick the larger n.
@item
If n = 0@comma{} let m be the String "0". Otherwise@comma{} let m be the String consisting of the digits of the decimal representation of n (in order@comma{} with no leading zeroes).
@item
If f ≠ 0@comma{} then
@enumerate
@item
Let k be the number of characters in m.
@item
If k ≤ f@comma{} then
@enumerate
@item
Let z be the String consisting of f+1−k occurrences of the character ‘@code{0}’.
@item
Let m be the concatenation of Strings z and m.
@item
Let k = f + 1.
@end enumerate

@item
Let a be the first k-f characters of m@comma{} and let b be the remaining f characters of m.
@item
Let m be the concatenation of the three Strings a@comma{} "."@comma{} and b.
@end enumerate

@end enumerate

@item
Return the concatenation of the Strings s and m.
@end enumerate

The @code{length} property of the toFixed method is 1.

If the toFixed method is called with more than one argument@comma{} then the behaviour is undefined (@uref{#sec-15,see clause 15}).

An implementation is permitted to extend the behaviour of toFixed for values of fractionDigits less than 0 or greater than 20. In this case toFixed would not necessarily throw RangeError for such values.

NOTE The output of toFixed may be more precise than toString for some values because toString only prints enough significant digits to distinguish the number from adjacent number values. For example@comma{}


@node 15746 NumberprototypetoExponential fractionDigits
@chapter @uref{#sec-15.7.4.6,15.7.4.6} Number.prototype.toExponential (fractionDigits)
Return a String containing @uref{#def-this-Number-value,this Number value} represented in decmal exponential notation with one digit before the significand’s decimal point and fractionDigits digits after the significand’s decimal point. If fractionDigits is undefined@comma{} include as many significand digits as necessary to uniquely specify the Number (just like in @uref{#sec-9.8,ToString} except that in this case the Number is always output in exponential notation). Specifically@comma{} perform the following steps:

@enumerate
@item
Let x be @uref{#def-this-Number-value,this Number value}.
@item
Let f be @uref{#sec-9.4,ToInteger}(fractionDigits).
@item
If x is NaN@comma{} return the String "NaN".
@item
Let s be the empty String.
@item
If x < 0@comma{} then
@enumerate
@item
Let s be "-".
@item
Let x = −x.
@end enumerate

@item
If x = +∞@comma{} then
@enumerate
@item
Return the concatenation of the Strings s and "Infinity".
@end enumerate

@item
If fractionDigits is not undefined and (f < 0 or f > 20)@comma{} throw a RangeError exception.
@item
If x = 0@comma{} then
@enumerate
@item
Let f = 0.
@item
Let m be the String consisting of f+1 occurrences of the character ‘@code{0}’.
@item
Let e = 0.
@end enumerate

@item
Else@comma{} x ≠ 0
@enumerate
@item
If fractionDigits is not undefined@comma{} then
@enumerate
@item
Let e and n be integers such that 10^f ≤ n < 10^f+1 and for which the exact mathematical value of n × 10^e−f − x is as close to zero as possible. If there are two such sets of e and n@comma{} pick the e and n for which n × 10^e−f is larger.
@end enumerate

@item
Else@comma{} fractionDigits is undefined
@enumerate
@item
Let e@comma{} n@comma{} and f be integers such that f ≥ 0@comma{} 10^f ≤ n < 10^f+1@comma{} the number value for n × 10^e−f is x@comma{} and f is as small as possible. Note that the decimal representation of n has f+1 digits@comma{} n is not divisible by 10@comma{} and the least significant digit of n is not necessarily uniquely determined by these criteria.
@end enumerate

@item
Let m be the String consisting of the digits of the decimal representation of n (in order@comma{} with no leading zeroes).
@end enumerate

@item
If f ≠ 0@comma{} then
@enumerate
@item
Let a be the first character of m@comma{} and let b be the remaining f characters of m.
@item
Let m be the concatenation of the three Strings a@comma{} "."@comma{} and b.
@end enumerate

@item
If e = 0@comma{} then
@enumerate
@item
Let c = "+".
@item
Let d = "0".
@end enumerate

@item
Else
@enumerate
@item
If e > 0@comma{} then let c = "+".
@item
Else@comma{} e ≤ 0
@enumerate
@item
Let c = "-".
@item
Let e = −e.
@end enumerate

@item
Let d be the String consisting of the digits of the decimal representation of e (in order@comma{} with no leading zeroes).
@end enumerate

@item
Let m be the concatenation of the four Strings m@comma{} "e"@comma{} c@comma{} and d.
@item
Return the concatenation of the Strings s and m.
@end enumerate

The @code{length} property of the toExponential method is 1.

If the toExponential method is called with more than one argument@comma{} then the behaviour is undefined (@uref{#sec-15,see clause 15}).



NOTE For implementations that provide more accurate conversions than required by the rules above@comma{} it is recommended that the following alternative version of step 9.b.i be used as a guideline:

@quotation
i. Let e@comma{} n@comma{} and f be integers such that f ≥ 0@comma{} 10^f ≤ n < 10^f+1@comma{} the number value for n × 10^e−f is x@comma{} and f is as small as possible. If there are multiple possibilities for n@comma{} choose the value of n for which n × 10^e−f is closest in value to x. If there are two such possible values of n@comma{} choose the one that is even.

@end quotation

@node 15747 NumberprototypetoPrecision precision
@chapter @uref{#sec-15.7.4.7,15.7.4.7} Number.prototype.toPrecision (precision)
Return a String containing @uref{#def-this-Number-value,this Number value} represented either in decimal exponential notation with one digit before the significand’s decimal point and precision−1 digits after the significand’s decimal point or in decimal fixed notation with precision significant digits. If precision is undefined@comma{} call @uref{#sec-9.8,ToString} (@uref{#sec-9.8.1,9.8.1}) instead. Specifically@comma{} perform the following steps:

@enumerate
@item
Let x be @uref{#def-this-Number-value,this Number value}.
@item
If precision is undefined@comma{} return @uref{#sec-9.8,ToString}(x).
@item
Let p be @uref{#sec-9.4,ToInteger}(precision).
@item
If x is NaN@comma{} return the String "NaN".
@item
Let s be the empty String.
@item
If x < 0@comma{} then
@enumerate
@item
Let s be "-".
@item
Let x = −x.
@end enumerate

@item
If x = +∞@comma{} then
@enumerate
@item
Return the concatenation of the Strings s and "Infinity".
@end enumerate

@item
If p < 1 or p > 21@comma{} throw a RangeError exception.
@item
If x = 0@comma{} then
@enumerate
@item
Let m be the String consisting of p occurrences of the character ‘@code{0}’.
@item
Let e = 0.
@end enumerate

@item
Else x ≠ 0@comma{}
@enumerate
@item
Let e and n be integers such that 10^p−1 ≤ n < 10^p and for which the exact mathematical value of n × 10^e−p+1 − x is as close to zero as possible. If there are two such sets of e and n@comma{} pick the e and n for which n × 10^e−p+1 is larger.
@item
Let m be the String consisting of the digits of the decimal representation of n (in order@comma{} with no leading zeroes).
@item
If e < −6 or e ≥ p@comma{} then
@enumerate
@item
Let a be the first character of m@comma{} and let b be the remaining p−1 characters of m.
@item
Let m be the concatenation of the three Strings a@comma{} "."@comma{} and b.
@item
If e = 0@comma{} then
@enumerate
@item
Let c = "+" and d = "0".
@end enumerate

@item
Else e ≠ 0@comma{}
@enumerate
@item
If e > 0@comma{} then
@enumerate
@item
Let c = "+".
@end enumerate

@item
Else e < 0@comma{}
@enumerate
@item
Let c = "-".
@item
Let e = −e.
@end enumerate

@item
Let d be the String consisting of the digits of the decimal representation of e (in order@comma{} with no leading zeroes).
@end enumerate

@item
Let m be the concatenation of the five Strings s@comma{} m@comma{} "e"@comma{} c@comma{} and d.
@end enumerate

@end enumerate

@item
If e = p−1@comma{} then return the concatenation of the Strings s and m.
@item
If e ≥ 0@comma{} then
@enumerate
@item
Let m be the concatenation of the first e+1 characters of m@comma{} the character ‘@code{.}’@comma{} and the remaining p−(e+1) characters of m.
@end enumerate

@item
Else e < 0@comma{}
@enumerate
@item
Let m be the concatenation of the String "0."@comma{} −(e+1) occurrences of the character ‘@code{0}’@comma{} and the String m.
@end enumerate

@item
Return the concatenation of the Strings s and m.
@end enumerate

The @code{length} property of the toPrecision method is 1.

If the toPrecision method is called with more than one argument@comma{} then the behaviour is undefined (@uref{#sec-15,see clause 15}).

An implementation is permitted to extend the behaviour of toPrecision for values of precision less than 1 or greater than 21. In this case toPrecision would not necessarily throw RangeError for such values.


@node 1575 Properties of Number Instances
@chapter @uref{#sec-15.7.5,15.7.5} Properties of Number Instances
Number instances inherit properties from the Number prototype object and their [[Class]] internal property value is "Number". Number instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is the Number value represented by this Number object.


@node 158 The Math Object
@chapter @uref{#sec-15.8,15.8} The Math Object
The Math object is a single object that has some named properties@comma{} some of which are functions.

The value of the [[Prototype]] internal property of the Math object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}). The value of the [[Class]] internal property of the Math object is "Math".

The Math object does not have a [[Construct]] internal property; it is not possible to use the Math object as a constructor with the @code{new} operator.

The Math object does not have a [[Call]] internal property; it is not possible to invoke the Math object as a function.

NOTE In this specification@comma{} the phrase “the Number value for x” has a technical meaning defined in @uref{#sec-8.5,8.5}.


@node 1581 Value Properties of the Math Object
@chapter @uref{#sec-15.8.1,15.8.1} Value Properties of the Math Object

@node 15811 E
@chapter @uref{#sec-15.8.1.1,15.8.1.1} E
The Number value for @emph{e}@comma{} the base of the natural logarithms@comma{} which is approximately 2.7182818284590452354.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15812 LN10
@chapter @uref{#sec-15.8.1.2,15.8.1.2} LN10
The Number value for the natural logarithm of 10@comma{} which is approximately 2.302585092994046.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15813 LN2
@chapter @uref{#sec-15.8.1.3,15.8.1.3} LN2
The Number value for the natural logarithm of 2@comma{} which is approximately 0.6931471805599453.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15814 LOG2E
@chapter @uref{#sec-15.8.1.4,15.8.1.4} LOG2E
The Number value for the base-2 logarithm of @emph{e}@comma{} the base of the natural logarithms; this value is approximately 1.4426950408889634.



NOTE The value of Math.LOG2E is approximately the reciprocal of the value of Math.LN2.


@node 15815 LOG10E
@chapter @uref{#sec-15.8.1.5,15.8.1.5} LOG10E
The Number value for the base-10 logarithm of @emph{e}@comma{} the base of the natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.

NOTE The value of Math.LOG10E is approximately the reciprocal of the value of Math.LN10.


@node 15816 PI
@chapter @uref{#sec-15.8.1.6,15.8.1.6} PI
The Number value for π@comma{} the ratio of the circumference of a circle to its diameter@comma{} which is approximately 3.1415926535897932.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15817 SQRT1_2
@chapter @uref{#sec-15.8.1.7,15.8.1.7} SQRT1_2
The Number value for the square root of ½@comma{} which is approximately 0.7071067811865476.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.

NOTE The value of Math.SQRT1_2 is approximately the reciprocal of the value of Math.SQRT2.


@node 15818 SQRT2
@chapter @uref{#sec-15.8.1.8,15.8.1.8} SQRT2
The Number value for the square root of 2@comma{} which is approximately 1.4142135623730951.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 1582 Function Properties of the Math Object
@chapter @uref{#sec-15.8.2,15.8.2} Function Properties of the Math Object
Each of the following Math object functions applies the @uref{#sec-9.3,ToNumber} abstract operator to each of its arguments (in left-to-right order if there is more than one) and then performs a computation on the resulting Number value(s).

In the function descriptions below@comma{} the symbols NaN@comma{} −0@comma{} +0@comma{} −∞ and +∞ refer to the Number values described in @uref{#sec-8.5,8.5}.

NOTE The behaviour of the functions acos@comma{} asin@comma{} atan@comma{} atan2@comma{} cos@comma{} exp@comma{} log@comma{} pow@comma{} sin@comma{} sqrt@comma{} and tan is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest. For other argument values@comma{} these functions are intended to compute approximations to the results of familiar mathematical functions@comma{} but some latitude is allowed in the choice of approximation algorithms. The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform. Although the choice of algorithms is left to the implementation@comma{} it is recommended (but not specified by this standard) that implementations use the approximation algorithms for IEEE 754 arithmetic contained in @strong{fdlibm}@comma{} the freely distributable mathematical library from Sun Microsystems (@uref{http://www.netlib.org/fdlibm,http://www.netlib.org/fdlibm}).


@node 15821 abs x
@chapter @uref{#sec-15.8.2.1,15.8.2.1} abs (x)
Returns the absolute value of x; the result has the same magnitude as x but has positive sign.

@itemize
@item

@item
If x is −0@comma{} the result is +0.
@item
If x is −∞@comma{} the result is +∞.
@end itemize


@node 15822 acos x
@chapter @uref{#sec-15.8.2.2,15.8.2.2} acos (x)
Returns an implementation-dependent approximation to the arc cosine of x. The result is expressed in radians and ranges from +0 to +π.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is greater than 1@comma{} the result is NaN.
@item
If x is less than −1@comma{} the result is NaN.
@item
If x is exactly 1@comma{} the result is +0.
@end itemize


@node 15823 asin x
@chapter @uref{#sec-15.8.2.3,15.8.2.3} asin (x)
Returns an implementation-dependent approximation to the arc sine of x. The result is expressed in radians and ranges from −π/2 to +π/2.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is greater than 1@comma{} the result is NaN.
@item
If x is less than −1@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@end itemize


@node 15824 atan x
@chapter @uref{#sec-15.8.2.4,15.8.2.4} atan (x)
Returns an implementation-dependent approximation to the arc tangent of x. The result is expressed in radians and ranges from −π/2 to +π/2.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞@comma{} the result is an implementation-dependent approximation to +π/2.
@item
If x is −∞@comma{} the result is an implementation-dependent approximation to −π/2.
@end itemize


@node 15825 atan2 y x
@chapter @uref{#sec-15.8.2.5,15.8.2.5} atan2 (y@comma{} x)
Returns an implementation-dependent approximation to the arc tangent of the quotient y/x of the arguments y and x@comma{} where the signs of y and x are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named y be first and the argument named x be second. The result is expressed in radians and ranges from −π to +π.

@itemize
@item
If either x or y is NaN@comma{} the result is NaN.
@item
If y>0 and x is +0@comma{} the result is an implementation-dependent approximation to +π/2.
@item
If y>0 and x is −0@comma{} the result is an implementation-dependent approximation to +π/2.
@item
If y is +0 and x>0@comma{} the result is +0.
@item
If y is +0 and x is +0@comma{} the result is +0.
@item
If y is +0 and x is −0@comma{} the result is an implementation-dependent approximation to +π.
@item
If y is +0 and x<0@comma{} the result is an implementation-dependent approximation to +π.
@item
If y is −0 and x>0@comma{} the result is −0.
@item
If y is −0 and x is +0@comma{} the result is −0.
@item
If y is −0 and x is −0@comma{} the result is an implementation-dependent approximation to −π.
@item
If y is −0 and x<0@comma{} the result is an implementation-dependent approximation to −π.
@item
If y<0 and x is +0@comma{} the result is an implementation-dependent approximation to −π/2.
@item
If y<0 and x is −0@comma{} the result is an implementation-dependent approximation to −π/2.
@item

@item
If y>0 and y is finite and x is −∞@comma{} the result if an implementation-dependent approximation to +π.
@item
If y<0 and y is finite and x is +∞@comma{} the result is −0.
@item
If y<0 and y is finite and x is −∞@comma{} the result is an implementation-dependent approximation to −π.
@item
If y is +∞ and x is finite@comma{} the result is an implementation-dependent approximation to +π/2.
@item
If y is −∞ and x is finite@comma{} the result is an implementation-dependent approximation to −π/2.
@item
If y is +∞ and x is +∞@comma{} the result is an implementation-dependent approximation to +π/4.
@item
If y is +∞ and x is −∞@comma{} the result is an implementation-dependent approximation to +3π/4.
@item
If y is −∞ and x is +∞@comma{} the result is an implementation-dependent approximation to −π/4.
@item
If y is −∞ and x is −∞@comma{} the result is an implementation-dependent approximation to −3π/4.
@end itemize


@node 15826 ceil x
@chapter @uref{#sec-15.8.2.6,15.8.2.6} ceil (x)
Returns the smallest (closest to −∞) Number value that is not less than x and is equal to a mathematical integer. If x is already an integer@comma{} the result is x.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞@comma{} the result is +∞.
@item
If x is −∞@comma{} the result is −∞.
@item
If x is less than 0 but greater than −1@comma{} the result is −0.
@end itemize

The value of @code{Math.ceil(x)} is the same as the value of @code{-Math.floor(-x)}.


@node 15827 cosx
@chapter @uref{#sec-15.8.2.7,15.8.2.7} cos(x)
Returns an implementation-dependent approximation to the cosine of x. The argument is expressed in radians.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is 1.
@item
If x is −0@comma{} the result is 1.
@item
If x is +∞@comma{} the result is NaN.
@item
If x is −∞@comma{} the result is NaN.
@end itemize


@node 15828 expx
@chapter @uref{#sec-15.8.2.8,15.8.2.8} exp(x)
Returns an implementation-dependent approximation to the exponential function of x (@emph{e} raised to the power of x@comma{} where @emph{e} is the base of the natural logarithms).

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is 1.
@item
If x is −0@comma{} the result is 1.
@item
If x is +∞@comma{} the result is +∞.
@item
If x is −∞@comma{} the result is +0.
@end itemize


@node 15829 floor x
@chapter @uref{#sec-15.8.2.9,15.8.2.9} floor (x)
Returns the greatest (closest to +∞) Number value that is not greater than x and is equal to a mathematical integer. If x is already an integer@comma{} the result is x.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞@comma{} the result is +∞.
@item
If x is −∞@comma{} the result is −∞.
@item

@end itemize

NOTE The value of @code{Math.floor(x)} is the same as the value of @code{-Math.ceil(-x)}.


@node 158210 log x
@chapter @uref{#sec-15.8.2.10,15.8.2.10} log (x)
Returns an implementation-dependent approximation to the natural logarithm of x.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is less than 0@comma{} the result is NaN.
@item
If x is +0 or −0@comma{} the result is −∞.
@item
If x is 1@comma{} the result is +0.
@item
If x is +∞@comma{} the result is +∞.
@end itemize


@node 158211 max  [ value1 [  value2 [   ] ] ]
@chapter @uref{#sec-15.8.2.11,15.8.2.11} max ( [ value1 [ @comma{} value2 [ @comma{} ... ] ] ] )
Given zero or more arguments@comma{} calls @uref{#sec-9.3,ToNumber} on each of the arguments and returns the largest of the resulting values.

@itemize
@item
If no arguments are given@comma{} the result is −∞.
@item
If any value is NaN@comma{} the result is NaN.
@item
The comparison of values to determine the largest value is done as in @uref{#sec-11.8.5,11.8.5} except that +0 is considered to be larger than −0.
@end itemize

The @code{length} property of the max method is 2.


@node 158212 min  [ value1 [  value2 [   ] ] ]
@chapter @uref{#sec-15.8.2.12,15.8.2.12} min ( [ value1 [ @comma{} value2 [ @comma{} ... ] ] ] )
Given zero or more arguments@comma{} calls @uref{#sec-9.3,ToNumber} on each of the arguments and returns the smallest of the resulting values.

@itemize
@item
If no arguments are given@comma{} the result is +∞.
@item
If any value is NaN@comma{} the result is NaN.
@item
The comparison of values to determine the smallest value is done as in @uref{#sec-11.8.5,11.8.5} except that +0 is considered to be larger than −0.
@end itemize

The @code{length} property of the min method is 2.


@node 158213 pow x y
@chapter @uref{#sec-15.8.2.13,15.8.2.13} pow (x@comma{} y)
Returns an implementation-dependent approximation to the result of raising x to the power y.

@itemize
@item
If y is NaN@comma{} the result is NaN.
@item
If y is +0@comma{} the result is 1@comma{} even if x is NaN.
@item
If y is −0@comma{} the result is 1@comma{} even if x is NaN.
@item
If x is NaN and y is nonzero@comma{} the result is NaN.
@item
If @uref{#def-abs,abs}(x)>1 and y is +∞@comma{} the result is +∞.
@item
If @uref{#def-abs,abs}(x)>1 and y is −∞@comma{} the result is +0.
@item
If @uref{#def-abs,abs}(x)==1 and y is +∞@comma{} the result is NaN.
@item
If @uref{#def-abs,abs}(x)==1 and y is −∞@comma{} the result is NaN.
@item
If @uref{#def-abs,abs}(x)<1 and y is +∞@comma{} the result is +0.
@item
If @uref{#def-abs,abs}(x)<1 and y is −∞@comma{} the result is +∞.
@item
If x is +∞ and y>0@comma{} the result is +∞.
@item
If x is +∞ and y<0@comma{} the result is +0.
@item
If x is −∞ and y>0 and y is an odd integer@comma{} the result is −∞.
@item
If x is −∞ and y>0 and y is not an odd integer@comma{} the result is +∞.
@item
If x is −∞ and y<0 and y is an odd integer@comma{} the result is −0.
@item

@item
If x is +0 and y>0@comma{} the result is +0.
@item
If x is +0 and y<0@comma{} the result is +∞.
@item
If x is −0 and y>0 and y is an odd integer@comma{} the result is −0.
@item
If x is −0 and y>0 and y is not an odd integer@comma{} the result is +0.
@item
If x is −0 and y<0 and y is an odd integer@comma{} the result is −∞.
@item
If x is −0 and y<0 and y is not an odd integer@comma{} the result is +∞.
@item
If x<0 and x is finite and y is finite and y is not an integer@comma{} the result is NaN.
@end itemize


@node 158214 random
@chapter @uref{#sec-15.8.2.14,15.8.2.14} random ( )
Returns a Number value with positive sign@comma{} greater than or equal to 0 but less than 1@comma{} chosen randomly or pseudo randomly with approximately uniform distribution over that range@comma{} using an implementation-dependent algorithm or strategy. This function takes no arguments.


@node 158215 round x
@chapter @uref{#sec-15.8.2.15,15.8.2.15} round (x)
Returns the Number value that is closest to x and is equal to a mathematical integer. If two integer Number values are equally close to x@comma{} then the result is the Number value that is closer to +∞. If x is already an integer@comma{} the result is x.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞@comma{} the result is +∞.
@item
If x is −∞@comma{} the result is −∞.
@item
If x is greater than 0 but less than 0.5@comma{} the result is +0.
@item
If x is less than 0 but greater than or equal to −0.5@comma{} the result is −0.
@end itemize

NOTE 1 @code{Math.round(3.5)} returns 4@comma{} but @code{Math.round(-3.5)} returns −3.

NOTE 2 The value of @code{Math.round(x)} is the same as the value of @code{Math.floor(x+0.5)}@comma{} except when x is −0 or is less than 0 but greater than or equal to −0.5; for these cases @code{Math.round(x)} returns −0@comma{} but @code{Math.floor(x+0.5)} returns +0.


@node 158216 sin x
@chapter @uref{#sec-15.8.2.16,15.8.2.16} sin (x)
Returns an implementation-dependent approximation to the sine of x. The argument is expressed in radians.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞ or −∞@comma{} the result is NaN.
@end itemize


@node 158217 sqrt x
@chapter @uref{#sec-15.8.2.17,15.8.2.17} sqrt (x)
Returns an implementation-dependent approximation to the square root of x.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is less than 0@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞@comma{} the result is +∞.
@end itemize



@node 158218 tan x
@chapter @uref{#sec-15.8.2.18,15.8.2.18} tan (x)
Returns an implementation-dependent approximation to the tangent of x. The argument is expressed in radians.

@itemize
@item
If x is NaN@comma{} the result is NaN.
@item
If x is +0@comma{} the result is +0.
@item
If x is −0@comma{} the result is −0.
@item
If x is +∞ or −∞@comma{} the result is NaN.
@end itemize


@node 159 Date Objects
@chapter @uref{#sec-15.9,15.9} Date Objects

@node 1591 Overview of Date Objects and Definitions of Abstract Operators
@chapter @uref{#sec-15.9.1,15.9.1} Overview of Date Objects and Definitions of Abstract Operators
The following functions are abstract operations that operate on time values (defined in @uref{#sec-15.9.1.1,15.9.1.1}). Note that@comma{} in every case@comma{} if any argument to one of these functions is NaN@comma{} the result will be NaN.


@node 15911 Time Values and Time Range
@chapter @uref{#sec-15.9.1.1,15.9.1.1} Time Values and Time Range
A Date object contains a Number indicating a particular instant in time to within a millisecond. Such a Number is called a time value. A time value may also be NaN@comma{} indicating that the Date object does not represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01@ January@comma{} 1970 UTC. In time values leap seconds are ignored. It is assumed that there are exactly 86@comma{}400@comma{}000 milliseconds per day. ECMAScript Number values can represent all integers from −9@comma{}007@comma{}199@comma{}254@comma{}740@comma{}991 to 9@comma{}007@comma{}199@comma{}254@comma{}740@comma{}991; this range suffices to measure times to millisecond precision for any instant that is within approximately 285@comma{}616 years@comma{} either forward or backward@comma{} from 01@ January@comma{} 1970 UTC.

The actual range of times supported by ECMAScript Date objects is slightly smaller: exactly −100@comma{}000@comma{}000 days to 100@comma{}000@comma{}000 days measured relative to midnight at the beginning of 01@ January@comma{} 1970 UTC. This gives a range of 8@comma{}640@comma{}000@comma{}000@comma{}000@comma{}000 milliseconds to either side of 01@ January@comma{} 1970 UTC.

The exact moment of midnight at the beginning of 01@ January@comma{} 1970 UTC is represented by the value +0.


@node 15912 Day Number and Time within Day
@chapter @uref{#sec-15.9.1.2,15.9.1.2} Day Number and Time within Day
A given time value t belongs to day number

Day(t) = @uref{#def-floor,floor}(t / msPerDay)
where the number of milliseconds per day is

msPerDay = 86400000
The remainder is called the time within the day:

TimeWithinDay(t) = t @uref{#def-modulo,modulo} msPerDay

@node 15913 Year Number
@chapter @uref{#sec-15.9.1.3,15.9.1.3} Year Number
ECMAScript uses an extrapolated Gregorian system to map a day number to a year number and to determine the month and date within that year. In this system@comma{} leap years are precisely those which are (divisible by 4) and ((not divisible by 100) or (divisible by 400)). The number of days in year number y is therefore defined by

DaysInYear(y)
=@ 365
if (y @uref{#def-modulo,modulo} 4) ≠ 0
/span
=@ 366
if (y @uref{#def-modulo,modulo} 4) = 0 and (y @uref{#def-modulo,modulo} 100) ≠ 0
=@ 365
if (y @uref{#def-modulo,modulo} 100) = 0 and (y @uref{#def-modulo,modulo} 400) ≠ 0
=@ 366
if (y @uref{#def-modulo,modulo} 400) = 0

All non-leap years have 365 days with the usual number of days per month and leap years have an extra day in February. The day number of the first day of year y is given by:

DayFromYear(y) = 365 × (y−1970) + @uref{#def-floor,floor}((y−1969)/4) − @uref{#def-floor,floor}((y−1901)/100) + @uref{#def-floor,floor}((y−1601)/400)
The time value of the start of a year is:

TimeFromYear(y) = msPerDay × DayFromYear(y)
A time value determines a year by:

YearFromTime(t) = the largest integer y (closest to positive infinity) such that TimeFromYear(y) ≤ t
The leap-year function is 1 for a time within a leap year and otherwise is zero:

InLeapYear(t)
=@ 0
if DaysInYear(YearFromTime(t)) = 365
=@ 1
if DaysInYear(YearFromTime(t)) = 366

@node 15914 Month Number
@chapter @uref{#sec-15.9.1.4,15.9.1.4} Month Number
Months are identified by an integer in the range 0 to 11@comma{} inclusive. The mapping MonthFromTime(t) from a time value t to a month number is defined by:

MonthFromTime(t)
=@ 0
if
0
≤ DayWithinYear(t) < 31
=@ 1
if
31
≤ DayWithinYear(t) < 59+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 2
if
59+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 90+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 3
if
90+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 120+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 4
if
120+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 151+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 5
if
151+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 181+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 6
if
181+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 212+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 7
if
212+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 243+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 8
if
243+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 273+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 9
if
273+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 304+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 10
if
304+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 334+@uref{#sec-15.9.1.3,InLeapYear}(t)
=@ 11
if
334+@uref{#sec-15.9.1.3,InLeapYear}(t)
≤ DayWithinYear(t) < 365+@uref{#sec-15.9.1.3,InLeapYear}(t)
where

DayWithinYear(t) = @uref{#sec-15.9.1.2,Day}(t)−@uref{#sec-15.9.1.3,DayFromYear}(@uref{#sec-15.9.1.3,YearFromTime}(t))
A month value of 0 specifies January; 1 specifies February; 2 specifies March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies July; 7 specifies August; 8 specifies September; 9 specifies October; 10 specifies November; and 11 specifies December. Note that MonthFromTime(0) = 0@comma{} corresponding to Thursday@comma{} 01@ January@comma{} 1970.


@node 15915 Date Number
@chapter @uref{#sec-15.9.1.5,15.9.1.5} Date Number
A date number is identified by an integer in the range 1 through 31@comma{} inclusive. The mapping DateFromTime(t) from a time value t to a month number is defined by:

DateFromTime(t)
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)+1
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=0
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−30
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=1
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−58−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=2
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−89−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=3
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−119−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=4
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−150−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=5
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−180−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=6
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−211−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=7
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−242−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=8
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−272−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=9
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−303−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=10
=@ @uref{#sec-15.9.1.4,DayWithinYear}(t)−333−@uref{#sec-15.9.1.3,InLeapYear}(t)
if @uref{#sec-15.9.1.4,MonthFromTime}(t)=11


@node 15916 Week Day
@chapter @uref{#sec-15.9.1.6,15.9.1.6} Week Day
The weekday for a particular time value t is defined as

WeekDay(t) = (@uref{#sec-15.9.1.2,Day}(t) + 4) @uref{#def-modulo,modulo} 7
A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4@comma{} corresponding to Thursday@comma{} 01@ January@comma{} 1970.


@node 15917 Local Time Zone Adjustment
@chapter @uref{#sec-15.9.1.7,15.9.1.7} Local Time Zone Adjustment
An implementation of ECMAScript is expected to determine the local time zone adjustment. The local time zone adjustment is a value LocalTZA measured in milliseconds which when added to UTC represents the local @emph{standard} time. Daylight saving time is @emph{not} reflected by LocalTZA. The value LocalTZA does not vary with time but depends only on the geographic location.


@node 15918 Daylight Saving Time Adjustment
@chapter @uref{#sec-15.9.1.8,15.9.1.8} Daylight Saving Time Adjustment
An implementation of ECMAScript is expected to determine the daylight saving time algorithm. The algorithm to determine the daylight saving time adjustment DaylightSavingTA(t)@comma{} measured in milliseconds@comma{} must depend only on four things:

(1) the time since the beginning of the year

t − @uref{#sec-15.9.1.3,TimeFromYear}(@uref{#sec-15.9.1.3,YearFromTime}(t))
(2) whether t is in a leap year

@uref{#sec-15.9.1.3,InLeapYear}(t)
(3) the week day of the beginning of the year

@uref{#sec-15.9.1.6,WeekDay}(@uref{#sec-15.9.1.3,TimeFromYear}(@uref{#sec-15.9.1.3,YearFromTime}(t))
and (4) the geographic location.

The implementation of ECMAScript should not try to determine whether the exact time was subject to daylight saving time@comma{} but just whether daylight saving time would have been in effect if the current daylight saving time algorithm had been used at the time. This avoids complications such as taking into account the years that the locale observed daylight saving time year round.

If the host environment provides functionality for determining daylight saving time@comma{} the implementation of ECMAScript is free to map the year in question to an equivalent year (same leap-year-ness and same starting week day for the year) for which the host environment provides daylight saving time information. The only restriction is that all equivalent years should produce the same result.


@node 15919 Local Time
@chapter @uref{#sec-15.9.1.9,15.9.1.9} Local Time
Conversion from UTC to local time is defined by

LocalTime(t) = t + @uref{#sec-15.9.1.7,LocalTZA} + @uref{#sec-15.9.1.8,DaylightSavingTA}(t)
Conversion from local time to UTC is defined by

UTC(t) = t − @uref{#sec-15.9.1.7,LocalTZA} − @uref{#sec-15.9.1.8,DaylightSavingTA}(t − @uref{#sec-15.9.1.7,LocalTZA})
Note that UTC(LocalTime(t)) is not necessarily always equal to t.


@node 159110 Hours Minutes Second and Milliseconds
@chapter @uref{#sec-15.9.1.10,15.9.1.10} Hours@comma{} Minutes@comma{} Second@comma{} and Milliseconds
The following functions are useful in decomposing time values:

HourFromTime(t) = @uref{#def-floor,floor}(t / msPerHour) @uref{#def-modulo,modulo} HoursPerDay

MinFromTime(t) = @uref{#def-floor,floor}(t / msPerMinute) @uref{#def-modulo,modulo} MinutesPerHour
SecFromTime(t) = @uref{#def-floor,floor}(t / msPerSecond) @uref{#def-modulo,modulo} SecondsPerMinute
msFromTime(t) = t @uref{#def-modulo,modulo} msPerSecond
where

HoursPerDay = 24
MinutesPerHour = 60
SecondsPerMinute = 60
msPerSecond = 1000
msPerMinute = 60000 = msPerSecond × SecondsPerMinute
msPerHour = 3600000 = msPerMinute × MinutesPerHour

@node 159111 MakeTime hour min sec ms
@chapter @uref{#sec-15.9.1.11,15.9.1.11} MakeTime (hour@comma{} min@comma{} sec@comma{} ms)
The operator MakeTime calculates a number of milliseconds from its four arguments@comma{} which must be ECMAScript Number values. This operator functions as follows:

@enumerate
@item
If hour is not finite or min is not finite or sec is not finite or ms is not finite@comma{} return NaN.
@item
Let h be @uref{#sec-9.4,ToInteger}(hour).
@item
Let m be @uref{#sec-9.4,ToInteger}(min).
@item
Let s be @uref{#sec-9.4,ToInteger}(sec).
@item
Let milli be @uref{#sec-9.4,ToInteger}(ms).
@item
Let t be h @code{*} msPerHour @code{+} m @code{*} msPerMinute @code{+} s @code{*} msPerSecond @code{+} milli@comma{} performing the arithmetic according to IEEE 754 rules (that is@comma{} as if using the ECMAScript operators @code{*} and @code{+}).
@item
Return t.
@end enumerate


@node 159112 MakeDay year month date
@chapter @uref{#sec-15.9.1.12,15.9.1.12} MakeDay (year@comma{} month@comma{} date)
The operator MakeDay calculates a number of days from its three arguments@comma{} which must be ECMAScript Number values. This operator functions as follows:

@enumerate
@item
If year is not finite or month is not finite or date is not finite@comma{} return NaN.
@item
Let y be @uref{#sec-9.4,ToInteger}(year).
@item
Let m be @uref{#sec-9.4,ToInteger}(month).
@item
Let dt be @uref{#sec-9.4,ToInteger}(date).
@item
Let ym be y + @uref{#def-floor,floor}(m /12).
@item
Let mn be m @uref{#def-modulo,modulo} 12.
@item
Find a value t such that @uref{#sec-15.9.1.3,YearFromTime}(t) @strong{==} ym and @uref{#sec-15.9.1.4,MonthFromTime}(t) @strong{==} mn and @uref{#sec-15.9.1.5,DateFromTime}(t) @strong{==} 1; but if this is not possible (because some argument is out of range)@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.2,Day}(t) + dt − 1.
@end enumerate


@node 159113 MakeDate day time
@chapter @uref{#sec-15.9.1.13,15.9.1.13} MakeDate (day@comma{} time)
The operator MakeDate calculates a number of milliseconds from its two arguments@comma{} which must be ECMAScript Number values. This operator functions as follows:

@enumerate
@item
If day is not finite or time is not finite@comma{} return NaN.
@item
Return day × msPerDay + time.
@end enumerate


@node 159114 TimeClip time
@chapter @uref{#sec-15.9.1.14,15.9.1.14} TimeClip (time)
The operator TimeClip calculates a number of milliseconds from its argument@comma{} which must be an ECMAScript Number value. This operator functions as follows:

@enumerate
@item
If time is not finite@comma{} return NaN.
@item
If @uref{#def-abs,abs}(time) > 8.64 × 10^15@comma{} return NaN.
@item
Return an implementation-dependent choice of either @uref{#sec-9.4,ToInteger}(time) or @uref{#sec-9.4,ToInteger}(time) + (+0). (Adding a positive zero converts −0 to +0.)
@end enumerate

NOTE The point of step 3 is that an implementation is permitted a choice of internal representations of time values@comma{} for example as a 64-bit signed integer or as a 64-bit floating-point value. Depending on the implementation@comma{} this internal representation may or may not distinguish −0 and +0.


@node 159115 Date Time String Format
@chapter @uref{#sec-15.9.1.15,15.9.1.15} Date Time String Format
ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 Extended Format. The format is as follows: @code{YYYY-MM-DDTHH:mm:ss.sss<var>Z</var>}

Where the fields are as follows:

@code{YYYY}
is the decimal digits of the year in the Gregorian calendar.
@code{-}
“@code{:}” (hyphen) appears literally twice in the string.
@code{MM}
is the month of the year from 01 (January) to 12 (December).
@code{DD}
is the day of the month from 01 to 31.
@code{T}
“@code{T}” appears literally in the string@comma{} to indicate the beginning of the time element.
@code{HH}
is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.
@code{:}
“@code{:}” (colon) appears literally twice in the string.
@code{mm}
is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.
@code{ss}
is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.
@code{.}
“@code{.}” (dot) appears literally in the string.
@code{sss}
is the number of complete milliseconds since the start of the second as three decimal digits.
Both the "." and the milliseconds field may be omitted.
@code{<var>Z</var>}
is the time zone offset specified as “@code{Z}” (for UTC) or either “@code{+}” or “@code{-}” followed by a time expression @code{HH:mm}
This format includes date-only forms:
@verbatim
YYYY
YYYY-MM
YYYY-MM-DD
@end verbatim

It also includes “date-time” forms that consist of one of the above date-only forms immediately followed by one of the following time forms with an optional time zone offset appended:
@verbatim
THH:mm
THH:mm:ss
THH:mm:ss.sss
@end verbatim

All numbers must be base 10. If the @code{MM} or @code{DD} fields are absent “@code{01}” is used as the value. If the @code{mm} or @code{ss} fields are absent “@code{00}” is used as the value and the value of an absent @code{sss} file is “@code{000}”. The value of an absent time zone offset is “@code{Z}”.

Illegal values (out-of-bounds as well as syntax errors) in a format string means that the format string is not a valid instance of this format.

NOTE 1 As every day both starts and ends with midnight@comma{} the two notations 00:00 and 24:00 are available to distinguish the two midnights that can be associated with one date. This means that the following two notations refer to exactly the same point in time: 1995-02-04T24:00 and 1995-02-05T00:00

NOTE 2 There exists no international standard that specifies abbreviations for civil time zones like CET@comma{} EST@comma{} etc. and sometimes the same abbreviation is even used for two very different time zones. For this reason@comma{} ISO 8601 and this format specifies numeric representations of date and time.



@node 1591151 Extended years
@chapter @uref{#sec-15.9.1.15.1,15.9.1.15.1} Extended years
ECMAScript requires the ability to specify 6 digit years (extended years); approximately 285@comma{}616 years@comma{} either forward or backward@comma{} from 01@ January@comma{} 1970 UTC. To represent years before 0 or after 9999@comma{} ISO 8601 permits the expansion of the year representation@comma{} but only by prior agreement between the sender and the receiver. In the simplified ECMAScript format such an expanded year representation shall have 2 extra year digits and is always prefixed with a @code{+} or @code{−} sign. The year 0 is considered positive and hence prefixed with a @code{+} sign.


@node 1592 The Date Constructor Called as a Function
@chapter @uref{#sec-15.9.2,15.9.2} The Date Constructor Called as a Function
When Date is called as a function rather than as a constructor@comma{} it returns a String representing the current time (UTC).

NOTE The function call @code{Date(<var>...</var>)} is not equivalent to the object creation expression @code{new Date(<var>...</var>)} with the same arguments.


@node 15921 Date  [ year [ month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ] ] ]
@chapter @uref{#sec-15.9.2.1,15.9.2.1} Date ( [ year [@comma{} month [@comma{} date [@comma{} hours [@comma{} minutes [@comma{} seconds [@comma{} ms ] ] ] ] ] ] ] )
All of the arguments are optional; any arguments supplied are accepted but are completely ignored. A String is created and returned as if by the expression @code{(new Date()).toString()} where @code{Date} is the standard built-in constructor with that name and @code{toString} is the standard built-in method Date.prototype.toString.


@node 1593 The Date Constructor
@chapter @uref{#sec-15.9.3,15.9.3} The Date Constructor
When Date is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 15931 new Date year month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ]
@chapter @uref{#sec-15.9.3.1,15.9.3.1} new Date (year@comma{} month [@comma{} date [@comma{} hours [@comma{} minutes [@comma{} seconds [@comma{} ms ] ] ] ] ] )
When Date is called with two to seven arguments@comma{} it computes the date from year@comma{} month@comma{} and (optionally) date@comma{} hours@comma{} minutes@comma{} seconds and ms.

The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object@comma{} the one that is the initial value of Date.prototype (@uref{#sec-15.9.4.1,15.9.4.1}).

The [[Class]] internal property of the newly constructed object is set to "Date".

The [[Extensible]] internal property of the newly constructed object is set to true.

The [[PrimitiveValue]] internal property of the newly constructed object is set as follows:

@enumerate
@item
Let y be @uref{#sec-9.3,ToNumber}(year).
@item
Let m be @uref{#sec-9.3,ToNumber}(month).
@item
If date is supplied then let dt be @uref{#sec-9.3,ToNumber}(date); else let dt be 1.
@item
If hours is supplied then let h be @uref{#sec-9.3,ToNumber}(hours); else let h be 0.
@item
If minutes is supplied then let min be @uref{#sec-9.3,ToNumber}(minutes); else let min be 0.
@item
If seconds is supplied then let s be @uref{#sec-9.3,ToNumber}(seconds); else let s be 0.
@item
If ms is supplied then let milli be @uref{#sec-9.3,ToNumber}(ms); else let milli be 0.
@item
If y is not NaN and 0 ≤ @uref{#sec-9.4,ToInteger}(y) ≤ 99@comma{} then let yr be 1900 + @uref{#sec-9.4,ToInteger}(y); otherwise@comma{} let yr be y.
@item
Let finalDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(yr@comma{} m@comma{} dt)@comma{} @uref{#sec-15.9.1.11,MakeTime}(h@comma{} min@comma{} s@comma{} milli)).
@item
Set the [[PrimitiveValue]] internal property of the newly constructed object to @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(finalDate)).
@end enumerate


@node 15932 new Date value
@chapter @uref{#sec-15.9.3.2,15.9.3.2} new Date (value)
The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object@comma{} the one that is the initial value of Date.prototype (@uref{#sec-15.9.4.1,15.9.4.1}).



The [[Extensible]] internal property of the newly constructed object is set to true.

The [[PrimitiveValue]] internal property of the newly constructed object is set as follows:

@enumerate
@item
Let v be @uref{#sec-9.1,ToPrimitive}(value).
@item
If @uref{#def-type,Type}(v) is String@comma{} then
@enumerate
@item
Parse v as a date@comma{} in exactly the same manner as for the parse method (@uref{#sec-15.9.4.2,15.9.4.2}); let v be the time value for this date.
@end enumerate

@item
Else@comma{} let v be @uref{#sec-9.3,ToNumber}(v).
@item
Set the [[PrimitiveValue]] internal property of the newly constructed object to @uref{#sec-15.9.1.14,TimeClip}(v) and return.
@end enumerate


@node 15933 new Date
@chapter @uref{#sec-15.9.3.3,15.9.3.3} new Date ( )
The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object@comma{} the one that is the initial value of Date.prototype (@uref{#sec-15.9.4.1,15.9.4.1}).

The [[Class]] internal property of the newly constructed object is set to "Date".

The [[Extensible]] internal property of the newly constructed object is set to true.

The [[PrimitiveValue]] internal property of the newly constructed object is set to the time value (UTC) identifying the current time.


@node 1594 Properties of the Date Constructor
@chapter @uref{#sec-15.9.4,15.9.4} Properties of the Date Constructor
The value of the [[Prototype]] internal property of the Date constructor is @uref{#sec-15.3.4,the Function prototype object (15.3.4)}.

Besides the internal properties and the @code{length} property (whose value is 7)@comma{} the Date constructor has the following properties:


@node 15941 Dateprototype
@chapter @uref{#sec-15.9.4.1,15.9.4.1} Date.prototype
The initial value of Date.prototype is the built-in Date prototype object (@uref{#sec-15.9.5,15.9.5}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15942 Dateparse string
@chapter @uref{#sec-15.9.4.2,15.9.4.2} Date.parse (string)
The parse function applies the @uref{#sec-9.8,ToString} operator to its argument and interprets the resulting String as a date and time; it returns a Number@comma{} the UTC time value corresponding to the date and time. The String may be interpreted as a local time@comma{} a UTC time@comma{} or a time in some other time zone@comma{} depending on the contents of the String. The function first attempts to parse the format of the String according to the rules called out in Date Time String Format (@uref{#sec-15.9.1.15,15.9.1.15}). If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. Unrecognizable Strings or dates containing illegal element values in the format String shall cause Date.parse to return NaN.

If x is any Date object whose milliseconds amount is zero within a particular implementation of ECMAScript@comma{} then all of the following expressions should produce the same numeric value in that implementation@comma{} if all the properties referenced have their initial values:
@verbatim
x.valueOf()
Date.parse(x.toString())
Date.parse(x.toUTCString())
Date.parse(x.toISOString())
@end verbatim

However@comma{} the expression
@verbatim
Date.parse(x.toLocaleString())
@end verbatim




@node 15943 DateUTC year month [ date [ hours [ minutes [ seconds [ ms ] ] ] ] ]
@chapter @uref{#sec-15.9.4.3,15.9.4.3} Date.UTC (year@comma{} month [@comma{} date [@comma{} hours [@comma{} minutes [@comma{} seconds [@comma{} ms ] ] ] ] ] )
When the UTC function is called with fewer than two arguments@comma{} the behaviour is implementation-dependent. When the UTC function is called with two to seven arguments@comma{} it computes the date from year@comma{} month and (optionally) date@comma{} hours@comma{} minutes@comma{} seconds and ms. The following steps are taken:

@enumerate
@item
Let y be @uref{#sec-9.3,ToNumber}(year).
@item
Let m be @uref{#sec-9.3,ToNumber}(month).
@item
If date is supplied then let dt be @uref{#sec-9.3,ToNumber}(date); else let dt be 1.
@item
If hours is supplied then let h be @uref{#sec-9.3,ToNumber}(hours); else let h be 0.
@item
If minutes is supplied then let min be @uref{#sec-9.3,ToNumber}(minutes); else let min be 0.
@item
If seconds is supplied then let s be @uref{#sec-9.3,ToNumber}(seconds); else let s be 0.
@item
If ms is supplied then let milli be @uref{#sec-9.3,ToNumber}(ms); else let milli be 0.
@item
If y is not NaN and 0 ≤ @uref{#sec-9.4,ToInteger}(y) ≤ 99@comma{} then let yr be 1900+@uref{#sec-9.4,ToInteger}(y); otherwise@comma{} let yr be y.
@item
Return @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(yr@comma{} m@comma{} dt)@comma{} @uref{#sec-15.9.1.11,MakeTime}(h@comma{} min@comma{} s@comma{} milli))).
@end enumerate

The @code{length} property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it returns a time value as a Number@comma{} rather than creating a Date object@comma{} and it interprets the arguments in UTC rather than as local time.


@node 15944 Datenow
@chapter @uref{#sec-15.9.4.4,15.9.4.4} Date.now ( )
The now function return a Number value that is the time value designating the UTC date and time of the occurrence of the call to now.


@node 1595 Properties of the Date Prototype Object
@chapter @uref{#sec-15.9.5,15.9.5} Properties of the Date Prototype Object
The Date prototype object is itself a Date object (its [[Class]] is "Date") whose [[PrimitiveValue]] is NaN.

The value of the [[Prototype]] internal property of the Date prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).

In following descriptions of functions that are properties of the Date prototype object@comma{} the phrase “this Date object” refers to the object that is the this value for the invocation of the function. Unless explicitly noted otherwise@comma{} none of these functions are generic; a TypeError exception is thrown if the this value is not an object for which the value of the [[Class]] internal property is "Date". Also@comma{} the phrase “this time value” refers to the Number value for the time represented by this Date object@comma{} that is@comma{} the value of the [[PrimitiveValue]] internal property of this Date object.


@node 15951 Dateprototypeconstructor
@chapter @uref{#sec-15.9.5.1,15.9.5.1} Date.prototype.constructor
The initial value of Date.prototype.constructor is the built-in Date constructor.


@node 15952 DateprototypetoString
@chapter @uref{#sec-15.9.5.2,15.9.5.2} Date.prototype.toString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the Date in the current time zone in a convenient@comma{} human-readable form.

NOTE For any Date value d whose milliseconds amount is zero@comma{} the result of @code{Date.parse(<var>d</var>.toString())} is equal to @code{<var>d</var>.valueOf()}. @uref{#sec-15.9.4.2,See 15.9.4.2}.



@node 15953 DateprototypetoDateString
@chapter @uref{#sec-15.9.5.3,15.9.5.3} Date.prototype.toDateString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the “date” portion of the Date in the current time zone in a convenient@comma{} human-readable form.


@node 15954 DateprototypetoTimeString
@chapter @uref{#sec-15.9.5.4,15.9.5.4} Date.prototype.toTimeString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the “time” portion of the Date in the current time zone in a convenient@comma{} human-readable form.


@node 15955 DateprototypetoLocaleString
@chapter @uref{#sec-15.9.5.5,15.9.5.5} Date.prototype.toLocaleString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the Date in the current time zone in a convenient@comma{} human-readable form that corresponds to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.


@node 15956 DateprototypetoLocaleDateString
@chapter @uref{#sec-15.9.5.6,15.9.5.6} Date.prototype.toLocaleDateString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the “date” portion of the Date in the current time zone in a convenient@comma{} human-readable form that corresponds to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.


@node 15957 DateprototypetoLocaleTimeString
@chapter @uref{#sec-15.9.5.7,15.9.5.7} Date.prototype.toLocaleTimeString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the “time” portion of the Date in the current time zone in a convenient@comma{} human-readable form that corresponds to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended that implementations do not use this parameter position for anything else.


@node 15958 DateprototypevalueOf
@chapter @uref{#sec-15.9.5.8,15.9.5.8} Date.prototype.valueOf ( )
The valueOf function returns a Number@comma{} which is @uref{#def-this-time-value,this time value}.


@node 15959 DateprototypegetTime
@chapter @uref{#sec-15.9.5.9,15.9.5.9} Date.prototype.getTime ( )
@enumerate
@item
Return @uref{#def-this-time-value,this time value}.
@end enumerate


@node 159510 DateprototypegetFullYear
@chapter @uref{#sec-15.9.5.10,15.9.5.10} Date.prototype.getFullYear ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.3,YearFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159511 DateprototypegetUTCFullYear
@chapter @uref{#sec-15.9.5.11,15.9.5.11} Date.prototype.getUTCFullYear ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item

@end enumerate


@node 159512 DateprototypegetMonth
@chapter @uref{#sec-15.9.5.12,15.9.5.12} Date.prototype.getMonth ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.4,MonthFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159513 DateprototypegetUTCMonth
@chapter @uref{#sec-15.9.5.13,15.9.5.13} Date.prototype.getUTCMonth ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.4,MonthFromTime}(t).
@end enumerate


@node 159514 DateprototypegetDate
@chapter @uref{#sec-15.9.5.14,15.9.5.14} Date.prototype.getDate ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.5,DateFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159515 DateprototypegetUTCDate
@chapter @uref{#sec-15.9.5.15,15.9.5.15} Date.prototype.getUTCDate ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.5,DateFromTime}(t).
@end enumerate


@node 159516 DateprototypegetDay
@chapter @uref{#sec-15.9.5.16,15.9.5.16} Date.prototype.getDay ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.6,WeekDay}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159517 DateprototypegetUTCDay
@chapter @uref{#sec-15.9.5.17,15.9.5.17} Date.prototype.getUTCDay ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.6,WeekDay}(t).
@end enumerate


@node 159518 DateprototypegetHours
@chapter @uref{#sec-15.9.5.18,15.9.5.18} Date.prototype.getHours ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,HourFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159519 DateprototypegetUTCHours
@chapter @uref{#sec-15.9.5.19,15.9.5.19} Date.prototype.getUTCHours ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,HourFromTime}(t).
@end enumerate


@node 159520 DateprototypegetMinutes
@chapter @uref{#sec-15.9.5.20,15.9.5.20} Date.prototype.getMinutes ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,MinFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159521 DateprototypegetUTCMinutes
@chapter @uref{#sec-15.9.5.21,15.9.5.21} Date.prototype.getUTCMinutes ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,MinFromTime}(t).
@end enumerate


@node 159522 DateprototypegetSeconds
@chapter @uref{#sec-15.9.5.22,15.9.5.22} Date.prototype.getSeconds ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,SecFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159523 DateprototypegetUTCSeconds
@chapter @uref{#sec-15.9.5.23,15.9.5.23} Date.prototype.getUTCSeconds ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,SecFromTime}(t).
@end enumerate


@node 159524 DateprototypegetMilliseconds
@chapter @uref{#sec-15.9.5.24,15.9.5.24} Date.prototype.getMilliseconds ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,msFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)).
@end enumerate


@node 159525 DateprototypegetUTCMilliseconds
@chapter @uref{#sec-15.9.5.25,15.9.5.25} Date.prototype.getUTCMilliseconds ( )
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.10,msFromTime}(t).
@end enumerate


@node 159526 DateprototypegetTimezoneOffset
@chapter @uref{#sec-15.9.5.26,15.9.5.26} Date.prototype.getTimezoneOffset ( )
Returns the difference between local time and UTC time in minutes.

@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return (t − @uref{#sec-15.9.1.9,LocalTime}(t)) / msPerMinute.
@end enumerate


@node 159527 DateprototypesetTime time
@chapter @uref{#sec-15.9.5.27,15.9.5.27} Date.prototype.setTime (time)
@enumerate
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-9.3,ToNumber}(time)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate


@node 159528 DateprototypesetMilliseconds ms
@chapter @uref{#sec-15.9.5.28,15.9.5.28} Date.prototype.setMilliseconds (ms)
@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}).
@item
Let time be @uref{#sec-15.9.1.11,MakeTime}(@uref{#sec-15.9.1.10,HourFromTime}(t)@comma{} @uref{#sec-15.9.1.10,MinFromTime}(t)@comma{} @uref{#sec-15.9.1.10,SecFromTime}(t)@comma{} @uref{#sec-9.3,ToNumber}(ms)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(@uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} time))).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate


@node 159529 DateprototypesetUTCMilliseconds ms
@chapter @uref{#sec-15.9.5.29,15.9.5.29} Date.prototype.setUTCMilliseconds (ms)
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
Let time be @uref{#sec-15.9.1.11,MakeTime}(@uref{#sec-15.9.1.10,HourFromTime}(t)@comma{} @uref{#sec-15.9.1.10,MinFromTime}(t)@comma{} @uref{#sec-15.9.1.10,SecFromTime}(t)@comma{} @uref{#sec-9.3,ToNumber}(ms)).
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} time)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item

@end enumerate


@node 159530 DateprototypesetSeconds sec [ ms ]
@chapter @uref{#sec-15.9.5.30,15.9.5.30} Date.prototype.setSeconds (sec [@comma{} ms ] )
If ms is not specified@comma{} this behaves as if ms were specified with the value @code{getMilliseconds()}.

@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}).
@item
Let s be @uref{#sec-9.3,ToNumber}(sec).
@item
If ms is not specified@comma{} then let milli be @uref{#sec-15.9.1.10,msFromTime}(t); otherwise@comma{} let milli be @uref{#sec-9.3,ToNumber}(ms).
@item
Let date be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} @uref{#sec-15.9.1.11,MakeTime}(@uref{#sec-15.9.1.10,HourFromTime}(t)@comma{} @uref{#sec-15.9.1.10,MinFromTime}(t)@comma{} s@comma{} milli)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(date)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate

The @code{length} property of the setSeconds method is 2.


@node 159531 DateprototypesetUTCSeconds sec [ ms ]
@chapter @uref{#sec-15.9.5.31,15.9.5.31} Date.prototype.setUTCSeconds (sec [@comma{} ms ] )
If ms is not specified@comma{} this behaves as if ms were specified with the value @code{getUTCMilliseconds()}.

@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
Let s be @uref{#sec-9.3,ToNumber}(sec).
@item
If ms is not specified@comma{} then let milli be @uref{#sec-15.9.1.10,msFromTime}(t); otherwise@comma{} let milli be @uref{#sec-9.3,ToNumber}(ms).
@item
Let date be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} @uref{#sec-15.9.1.11,MakeTime}(@uref{#sec-15.9.1.10,HourFromTime}(t)@comma{} @uref{#sec-15.9.1.10,MinFromTime}(t)@comma{} s@comma{} milli)).
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(date).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate

The @code{length} property of the setUTCSeconds method is 2.


@node 159532 DateprototypesetMinutes min [ sec [ ms ] ]
@chapter @uref{#sec-15.9.5.32,15.9.5.32} Date.prototype.setMinutes (min [@comma{} sec [@comma{} ms ] ] )
If sec is not specified@comma{} this behaves as if sec were specified with the value @code{getSeconds()}.

If ms is not specified@comma{} this behaves as if ms were specified with the value @code{getMilliseconds()}.

@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}).
@item
Let m be @uref{#sec-9.3,ToNumber}(min).
@item
If sec is not specified@comma{} then let s be @uref{#sec-15.9.1.10,SecFromTime}(t); otherwise@comma{} let s be @uref{#sec-9.3,ToNumber}(sec).
@item
If ms is not specified@comma{} then let milli be @uref{#sec-15.9.1.10,msFromTime}(t); otherwise@comma{} let milli be @uref{#sec-9.3,ToNumber}(ms).
@item
Let date be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} @uref{#sec-15.9.1.11,MakeTime}(@uref{#sec-15.9.1.10,HourFromTime}(t)@comma{} m@comma{} s@comma{} milli)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(date)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate

The @code{length} property of the setMinutes method is 3.


@node 159533 DateprototypesetUTCMinutes min [ sec [ ms ] ]
@chapter @uref{#sec-15.9.5.33,15.9.5.33} Date.prototype.setUTCMinutes (min [@comma{} sec [@comma{} ms ] ] )
If sec is not specified@comma{} this behaves as if sec were specified with the value @code{getUTCSeconds()}.

If ms is not specified@comma{} this function behaves as if ms were specified with the value returned by @code{getUTCMilliseconds()}.

@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
Let m be @uref{#sec-9.3,ToNumber}(min).
@item
If sec is not specified@comma{} then let s be @uref{#sec-15.9.1.10,SecFromTime}(t); otherwise@comma{} let s be @uref{#sec-9.3,ToNumber}(sec).
@item
If ms is not specified@comma{} then let milli be @uref{#sec-15.9.1.10,msFromTime}(t); otherwise@comma{} let milli be @uref{#sec-9.3,ToNumber}(ms).
@item

@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(date).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate

The @code{length} property of the setUTCMinutes method is 3.


@node 159534 DateprototypesetHours hour [ min [ sec [ ms ] ] ]
@chapter @uref{#sec-15.9.5.34,15.9.5.34} Date.prototype.setHours (hour [@comma{} min [@comma{} sec [@comma{} ms ] ] ] )
If min is not specified@comma{} this behaves as if min were specified with the value @code{getMinutes()}.

If sec is not specified@comma{} this behaves as if sec were specified with the value @code{getSeconds()}.

If ms is not specified@comma{} this behaves as if ms were specified with the value @code{getMilliseconds()}.

@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}).
@item
Let h be @uref{#sec-9.3,ToNumber}(hour).
@item
If min is not specified@comma{} then let m be @uref{#sec-15.9.1.10,MinFromTime}(t); otherwise@comma{} let m be @uref{#sec-9.3,ToNumber}(min).
@item
If If sec is not specified@comma{} then let s be @uref{#sec-15.9.1.10,SecFromTime}(t); otherwise@comma{} let s be @uref{#sec-9.3,ToNumber}(sec).
@item
If ms is not specified@comma{} then let milli be @uref{#sec-15.9.1.10,msFromTime}(t); otherwise@comma{} let milli be @uref{#sec-9.3,ToNumber}(ms).
@item
Let date be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} @uref{#sec-15.9.1.11,MakeTime}(h@comma{} m@comma{} s@comma{} milli)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(date)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate

The @code{length} property of the setHours method is 4.


@node 159535 DateprototypesetUTCHours hour [ min [ sec [ ms ] ] ]
@chapter @uref{#sec-15.9.5.35,15.9.5.35} Date.prototype.setUTCHours (hour [@comma{} min [@comma{} sec [@comma{} ms ] ] ] )
If min is not specified@comma{} this behaves as if min were specified with the value @code{getUTCMinutes()}.

If sec is not specified@comma{} this behaves as if sec were specified with the value @code{getUTCSeconds()}.

If ms is not specified@comma{} this behaves as if ms were specified with the value @code{getUTCMilliseconds()}.

@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
Let h be @uref{#sec-9.3,ToNumber}(hour).
@item
If min is not specified@comma{} then let m be @uref{#sec-15.9.1.10,MinFromTime}(t); otherwise@comma{} let m be @uref{#sec-9.3,ToNumber}(min).
@item
If sec is not specified@comma{} then let s be @uref{#sec-15.9.1.10,SecFromTime}(t); otherwise@comma{} let s be @uref{#sec-9.3,ToNumber}(sec).
@item
If ms is not specified@comma{} then let milli be @uref{#sec-15.9.1.10,msFromTime}(t); otherwise@comma{} let milli be @uref{#sec-9.3,ToNumber}(ms).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.2,Day}(t)@comma{} @uref{#sec-15.9.1.11,MakeTime}(h@comma{} m@comma{} s@comma{} milli)).
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(newDate).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate

The @code{length} property of the setUTCHours method is 4.


@node 159536 DateprototypesetDate date
@chapter @uref{#sec-15.9.5.36,15.9.5.36} Date.prototype.setDate (date)
@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}).
@item
Let dt be @uref{#sec-9.3,ToNumber}(date).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(@uref{#sec-15.9.1.3,YearFromTime}(t)@comma{} @uref{#sec-15.9.1.4,MonthFromTime}(t)@comma{} dt)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(newDate)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate



@node 159537 DateprototypesetUTCDate date
@chapter @uref{#sec-15.9.5.37,15.9.5.37} Date.prototype.setUTCDate (date)
@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
Let dt be @uref{#sec-9.3,ToNumber}(date).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(@uref{#sec-15.9.1.3,YearFromTime}(t)@comma{} @uref{#sec-15.9.1.4,MonthFromTime}(t)@comma{} dt)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t)).
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(newDate).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate


@node 159538 DateprototypesetMonth month [ date ]
@chapter @uref{#sec-15.9.5.38,15.9.5.38} Date.prototype.setMonth (month [@comma{} date ] )
If date is not specified@comma{} this behaves as if date were specified with the value @code{getDate()}.

@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}).
@item
Let m be @uref{#sec-9.3,ToNumber}(month).
@item
If date is not specified@comma{} then let dt be @uref{#sec-15.9.1.5,DateFromTime}(t); otherwise@comma{} let dt be @uref{#sec-9.3,ToNumber}(date).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(@uref{#sec-15.9.1.3,YearFromTime}(t)@comma{} m@comma{} dt)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(newDate)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate

The @code{length} property of the setMonth method is 2.


@node 159539 DateprototypesetUTCMonth month [ date ]
@chapter @uref{#sec-15.9.5.39,15.9.5.39} Date.prototype.setUTCMonth (month [@comma{} date ] )
If date is not specified@comma{} this behaves as if date were specified with the value @code{getUTCDate()}.

@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
Let m be @uref{#sec-9.3,ToNumber}(month).
@item
If date is not specified@comma{} then let dt be @uref{#sec-15.9.1.5,DateFromTime}(t); otherwise@comma{} let dt be @uref{#sec-9.3,ToNumber}(date).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(@uref{#sec-15.9.1.3,YearFromTime}(t)@comma{} m@comma{} dt)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t)).
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(newDate).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate

The @code{length} property of the setUTCMonth method is 2.


@node 159540 DateprototypesetFullYear year [ month [ date ] ]
@chapter @uref{#sec-15.9.5.40,15.9.5.40} Date.prototype.setFullYear (year [@comma{} month [@comma{} date ] ] )
If month is not specified@comma{} this behaves as if month were specified with the value @code{getMonth()}.

If date is not specified@comma{} this behaves as if date were specified with the value @code{getDate()}.

@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}); but if @uref{#def-this-time-value,this time value} is NaN@comma{} let t be +0.
@item
Let y be @uref{#sec-9.3,ToNumber}(year).
@item
If month is not specified@comma{} then let m be @uref{#sec-15.9.1.4,MonthFromTime}(t); otherwise@comma{} let m be @uref{#sec-9.3,ToNumber}(month).
@item
If date is not specified@comma{} then let dt be @uref{#sec-15.9.1.5,DateFromTime}(t); otherwise@comma{} let dt be @uref{#sec-9.3,ToNumber}(date).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(y@comma{} m@comma{} dt)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t)).
@item
Let u be @uref{#sec-15.9.1.14,TimeClip}(@uref{#sec-15.9.1.9,UTC}(newDate)).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to u.
@item
Return u.
@end enumerate

The @code{length} property of the setFullYear method is 3.


@node 159541 DateprototypesetUTCFullYear year [ month [ date ] ]
@chapter @uref{#sec-15.9.5.41,15.9.5.41} Date.prototype.setUTCFullYear (year [@comma{} month [@comma{} date ] ] )
If month is not specified@comma{} this behaves as if month were specified with the value @code{getUTCMonth()}.



@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}; but if @uref{#def-this-time-value,this time value} is NaN@comma{} let t be +0.
@item
Let y be @uref{#sec-9.3,ToNumber}(year).
@item
If month is not specified@comma{} then let m be @uref{#sec-15.9.1.4,MonthFromTime}(t); otherwise@comma{} let m be @uref{#sec-9.3,ToNumber}(month).
@item
If date is not specified@comma{} then let dt be @uref{#sec-15.9.1.5,DateFromTime}(t); otherwise@comma{} let dt be @uref{#sec-9.3,ToNumber}(date).
@item
Let newDate be @uref{#sec-15.9.1.13,MakeDate}(@uref{#sec-15.9.1.12,MakeDay}(y@comma{} m@comma{} dt)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t)).
@item
Let v be @uref{#sec-15.9.1.14,TimeClip}(newDate).
@item
Set the [[PrimitiveValue]] internal property of @uref{#def-this-Date-object,this Date object} to v.
@item
Return v.
@end enumerate

The @code{length} property of the setUTCFullYear method is 3.


@node 159542 DateprototypetoUTCString
@chapter @uref{#sec-15.9.5.42,15.9.5.42} Date.prototype.toUTCString ( )
This function returns a String value. The contents of the String are implementation-dependent@comma{} but are intended to represent the Date in a convenient@comma{} human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is more readable than the format specified in @uref{#sec-15.9.1.15,15.9.1.15}. It is not essential that the chosen format be unambiguous or easily machine parsable. If an implementation does not have a preferred human-readable format it is recommended to use the format defined in @uref{#sec-15.9.1.15,15.9.1.15} but with a space rather than a "T" used to separate the date and time elements.


@node 159543 DateprototypetoISOString
@chapter @uref{#sec-15.9.5.43,15.9.5.43} Date.prototype.toISOString ( )
This function returns a String value represent the instance in time represented by @uref{#def-this-Date-object,this Date object}. The format of the String is the Date Time string format defined in @uref{#sec-15.9.1.15,15.9.1.15}. All fields are present in the String. The time zone is always UTC@comma{} denoted by the suffix Z. If the time value of this object is not a finite Number a RangeError exception is thrown.


@node 159544 DateprototypetoJSON  key
@chapter @uref{#sec-15.9.5.44,15.9.5.44} Date.prototype.toJSON ( key )
This function provides a String representation of a Date object for use by JSON.stringify (@uref{#sec-15.12.3,15.12.3}).

When the toJSON method is called with argument key@comma{} the following steps are taken:

@enumerate
@item
Let O be the result of calling @uref{#sec-9.9,ToObject}@comma{} giving it the this value as its argument.
@item
Let tv be @uref{#sec-9.1,ToPrimitive}(O@comma{} hint Number).
@item
If tv is a Number and is not finite@comma{} return null.
@item
Let toISO be the result of calling the [[Get]] internal method of O with argument "toISOString".
@item
If @uref{#sec-9.11,IsCallable}(toISO) is false@comma{} throw a TypeError exception.
@item
Return the result of calling the [[Call]] internal method of toISO with O as the this value and an empty argument list.
@end enumerate

NOTE 1 The argument is ignored.

NOTE 2 The toJSON function is intentionally generic; it does not require that its this value be a Date object. Therefore@comma{} it can be transferred to other kinds of objects for use as a method. However@comma{} it does require that any such object have a toISOString method. An object is free to use the argument key to filter its stringification.


@node 1596 Properties of Date Instances
@chapter @uref{#sec-15.9.6,15.9.6} Properties of Date Instances
Date instances inherit properties from the Date prototype object and their [[Class]] internal property value is "Date". Date instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is time value represented by @uref{#def-this-Date-object,this Date object}.



@node 1510 RegExp Regular Expression Objects
@chapter @uref{#sec-15.10,15.10} RegExp (Regular Expression) Objects
A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 programming language.


@node 15101 Patterns
@chapter @uref{#sec-15.10.1,15.10.1} Patterns
The RegExp constructor applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of Pattern.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
Pattern ::
Disjunction
Disjunction ::
Alternative
Alternative @code{|} Disjunction
Alternative ::
[empty]
Alternative Term
Term ::
Assertion
Atom
Atom Quantifier
Assertion ::
@code{^}
@code{$}
@code{\} @code{b}
@code{\} @code{B}
@code{(} @code{?} @code{=} Disjunction @code{)}
@code{(} @code{?} @code{!} Disjunction @code{)}
Quantifier ::
QuantifierPrefix
QuantifierPrefix @code{?}
QuantifierPrefix ::
@code{*}
@code{+}
@code{?}
@code{@{} DecimalDigits @code{@}}
@code{@{} DecimalDigits @code{@comma{}} @code{@}}
@code{@{} DecimalDigits @code{@comma{}} DecimalDigits @code{@}}
Atom ::
PatternCharacter
@code{.}
@code{\} AtomEscape
CharacterClass
@code{(} Disjunction @code{)}
@code{(} @code{?} @code{:} Disjunction @code{)}

PatternCharacter :: SourceCharacter but not any of:
@code{^  $  \  .  *  +  ?  (  )  [  ]  @{  @}  |}
AtomEscape ::
DecimalEscape
CharacterEscape
CharacterClassEscape
CharacterEscape ::
ControlEscape
@code{c} ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape
ControlEscape :: one of
@code{f  n  r  t  v}
ControlLetter :: one of
@code{a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z}
@code{A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z}
IdentityEscape ::
SourceCharacter but not IdentifierPart
<ZWJ>
<ZWNJ>
DecimalEscape ::
DecimalIntegerLiteral [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit]
CharacterClassEscape :: one of
@code{d  D  s  S  w  W}
CharacterClass ::
@code{[} [@uref{#def-lookahead-notin,lookahead ∉} @{@code{^}@}] ClassRanges @code{]}
@code{[} @code{^} ClassRanges @code{]}
ClassRanges ::
[empty]
NonemptyClassRanges
NonemptyClassRanges ::
ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom @code{-} ClassAtom ClassRanges
NonemptyClassRangesNoDash ::
ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash @code{-} ClassAtom ClassRanges
ClassAtom ::
@code{-}
ClassAtomNoDash
ClassAtomNoDash ::
SourceCharacter but not one of @code{\} or @code{]} or @code{-}
@code{\} ClassEscape

ClassEscape ::
DecimalEscape
@code{b}
CharacterEscape
CharacterClassEscape

@node 15102 Pattern Semantics
@chapter @uref{#sec-15.10.2,15.10.2} Pattern Semantics
A regular expression pattern is converted into an internal procedure using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below@comma{} as long as the results are the same. The internal procedure is used as the value of a RegExp object’s [[Match]] internal property.


@node 151021 Notation
@chapter @uref{#sec-15.10.2.1,15.10.2.1} Notation
The descriptions below use the following variables:

@itemize
@item
Input is the String being matched by the regular expression pattern. The notation input[n] means the nth character of input@comma{} where n can range between 0 (inclusive) and InputLength (exclusive).

@item
InputLength is the number of characters in the Input String.

@item
NcapturingParens is the total number of left capturing parentheses (i.e. the total number of times the Atom :: @code{(} Disjunction @code{)} production is expanded) in the pattern. A left capturing parenthesis is any @code{(} pattern character that is matched by the @code{(} terminal of the Atom :: @code{(} Disjunction @code{)} production.

@item
IgnoreCase is the setting of the RegExp object’s @code{ignoreCase} property.

@item
Multiline is the setting of the RegExp object’s @code{multiline} property.

@end itemize

Furthermore@comma{} the descriptions below use the following internal data structures:

@itemize
@item
A CharSet is a mathematical set of characters.

@item
A State is an ordered pair (endIndex@comma{} captures) where endIndex is an integer and captures is an internal array of @uref{#def-NcapturingParens,NcapturingParens} values. States are used to represent partial match states in the regular expression matching algorithms. The endIndex is one plus the index of the last input character matched so far by the pattern@comma{} while captures holds the results of capturing parentheses. The nth element of captures is either a String that represents the value obtained by the nth set of capturing parentheses or undefined if the nth set of capturing parentheses hasn’t been reached yet. Due to backtracking@comma{} many States may be in use at any time during the matching process.

@item
A MatchResult is either a State or the special token failure that indicates that the match failed.

@item
A Continuation procedure is an internal closure (i.e. an internal procedure with some arguments already bound to values) that takes one State argument and returns a MatchResult result. If an internal closure references variables bound in the function that creates the closure@comma{} the closure uses the values that these variables had at the time the closure was created. The Continuation attempts to match the remaining portion (specified by the closure’s already-bound arguments) of the pattern against the input String@comma{} starting at the intermediate state given by its State argument. If the match succeeds@comma{} the Continuation returns the final State that it reached; if the match fails@comma{} the Continuation returns failure.

@item
A Matcher procedure is an internal closure that takes two arguments—a State and a Continuation—and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure’s already-bound arguments) of the pattern against the input String@comma{} starting at the intermediate state given by its State argument. The Continuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State@comma{} the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as well. If it can@comma{} the Matcher returns the State returned by Continuation; if not@comma{} the Matcher may try different choices at its choice points@comma{} repeatedly calling Continuation until it either succeeds or all possibilities have been exhausted.

@item
An AssertionTester procedure is an internal closure that takes a State argument and returns a Boolean result. The assertion tester tests a specific condition (specified by the closure’s already-bound

@item
An EscapeValue is either a character or an integer. An EscapeValue is used to denote the interpretation of a DecimalEscape escape sequence: a character ch means that the escape sequence is interpreted as the character ch@comma{} while an integer n means that the escape sequence is interpreted as a backreference to the nth set of capturing parentheses.

@end itemize


@node 151022 Pattern
@chapter @uref{#sec-15.10.2.2,15.10.2.2} Pattern
The production Pattern :: Disjunction evaluates as follows:

@enumerate
@item
Evaluate Disjunction to obtain a Matcher m.
@item
Return an internal closure that takes two arguments@comma{} a String str and an integer index@comma{} and performs the following:
@enumerate
@item
Let Input be the given String str. This variable will be used throughout the algorithms in @uref{#sec-15.10.2,15.10.2}.
@item
Let InputLength be the length of Input. This variable will be used throughout the algorithms in @uref{#sec-15.10.2,15.10.2}.
@item
Let c be a Continuation that always returns its State argument as a successful MatchResult.
@item
Let cap be an internal array of @uref{#def-NcapturingParens,NcapturingParens} undefined values@comma{} indexed 1 through @uref{#def-NcapturingParens,NcapturingParens}.
@item
Let x be the State (index@comma{} cap).
@item
Call m(x@comma{} c) and return its result.
@end enumerate

@end enumerate

NOTE A Pattern evaluates (“compiles”) to an internal procedure value. RegExp.prototype.exec can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String@comma{} and@comma{} if it does match@comma{} what the values of the capturing parentheses would be. The algorithms in @uref{#sec-15.10.2,15.10.2} are designed so that compiling a pattern may throw a SyntaxError exception; on the other hand@comma{} once the pattern is successfully compiled@comma{} applying its result internal procedure to find a match in a String cannot throw an exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory).


@node 151023 Disjunction
@chapter @uref{#sec-15.10.2.3,15.10.2.3} Disjunction
The production Disjunction :: Alternative evaluates by evaluating Alternative to obtain a Matcher and returning that Matcher.

The production Disjunction :: Alternative @code{|} Disjunction evaluates as follows:

@enumerate
@item
Evaluate Alternative to obtain a Matcher m1.
@item
Evaluate Disjunction to obtain a Matcher m2.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following:
@enumerate
@item
Call m1(x@comma{} c) and let r be its result.
@item
If r isn’t failure@comma{} return r.
@item
Call m2(x@comma{} c) and return its result.
@end enumerate

@end enumerate

NOTE The @code{|} regular expression operator separates two alternatives. The pattern first tries to match the left Alternative (followed by the sequel of the regular expression); if it fails@comma{} it tries to match the right Disjunction (followed by the sequel of the regular expression). If the left Alternative@comma{} the right Disjunction@comma{} and the sequel all have choice points@comma{} all choices in the sequel are tried before moving on to the next choice in the left Alternative. If choices in the left Alternative are exhausted@comma{} the right Disjunction is tried instead of the left Alternative. Any capturing parentheses inside a portion of the pattern skipped by @code{|} produce undefined values instead of Strings. Thus@comma{} for example@comma{}
@verbatim
/a|ab/.exec("abc")
@end verbatim

returns the result "a" and not "ab". Moreover@comma{}
@verbatim
/((a)|(ab))((c)|(bc))/.exec("abc")
@end verbatim

returns the array
@verbatim
["abc", "a", "a", undefined, "bc", undefined, "bc"]
@end verbatim

and not
@verbatim
["abc", "ab", undefined, "ab", "c", "c", undefined]
@end verbatim



@node 151024 Alternative
@chapter @uref{#sec-15.10.2.4,15.10.2.4} Alternative
The production Alternative :: [empty] evaluates by returning a Matcher that takes two arguments@comma{} a State x and a Continuation c@comma{} and returns the result of calling c(x).

The production Alternative :: Alternative Term evaluates as follows:

@enumerate
@item
Evaluate Alternative to obtain a Matcher m1.
@item
Evaluate Term to obtain a Matcher m2.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following:
@enumerate
@item
Create a Continuation d that takes a State argument y and returns the result of calling m2(y@comma{} c).
@item
Call m1(x@comma{} d) and return its result.
@end enumerate

@end enumerate

NOTE Consecutive Terms try to simultaneously match consecutive portions of the input String. If the left Alternative@comma{} the right Term@comma{} and the sequel of the regular expression all have choice points@comma{} all choices in the sequel are tried before moving on to the next choice in the right Term@comma{} and all choices in the right Term are tried before moving on to the next choice in the left Alternative.


@node 151025 Term
@chapter @uref{#sec-15.10.2.5,15.10.2.5} Term
The production Term :: Assertion evaluates by returning an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following:

@enumerate
@item
Evaluate Assertion to obtain an AssertionTester t.
@item
Call t(x) and let r be the resulting Boolean value.
@item
If r is false@comma{} return failure.
@item
Call c(x) and return its result.
@end enumerate

The production Term :: Atom evaluates by evaluating Atom to obtain a Matcher and returning that Matcher.

The production Term :: Atom Quantifier evaluates as follows:

@enumerate
@item
Evaluate Atom to obtain a Matcher m.
@item
Evaluate Quantifier to obtain the three results: an integer min@comma{} an integer (or ∞) max@comma{} and Boolean greedy.
@item
If max is finite and less than min@comma{} then throw a SyntaxError exception.
@item
Let parenIndex be the number of left capturing parentheses in the entire regular expression that occur to the left of this production expansion’s Term. This is the total number of times the Atom :: @code{(} Disjunction @code{)} production is expanded prior to this production’s Term plus the total number of Atom :: @code{(} Disjunction @code{)} productions enclosing this Term.
@item
Let parenCount be the number of left capturing parentheses in the expansion of this production’s Atom. This is the total number of Atom :: @code{(} Disjunction @code{)} productions enclosed by this production’s Atom.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following:
@enumerate
@item
Call RepeatMatcher(m@comma{} min@comma{} max@comma{} greedy@comma{} x@comma{} c@comma{} parenIndex@comma{} parenCount) and return its result.
@end enumerate

@end enumerate

The abstract operation RepeatMatcher takes eight parameters@comma{} a Matcher m@comma{} an integer min@comma{} an integer (or ∞) max@comma{} a Boolean greedy@comma{} a State x@comma{} a Continuation c@comma{} an integer parenIndex@comma{} and an integer parenCount@comma{} and performs the following:

@enumerate
@item
If max is zero@comma{} then call c(x) and return its result.
@item
Create an internal Continuation closure d that takes one State argument y and performs the following:
@enumerate
@item
If min is zero and y’s endIndex is equal to x’s endIndex@comma{} then return failure.
@item
If min is zero then let min2 be zero; otherwise let min2 be min−1.
@item
If max is ∞@comma{} then let max2 be ∞; otherwise let max2 be max−1.
@item

@end enumerate

@item
Let cap be a fresh copy of x’s captures internal array.
@item
For every integer k that satisfies parenIndex < k and k ≤ parenIndex+parenCount@comma{} set cap[k] to undefined.
@item
Let e be x’s endIndex.
@item
Let xr be the State (e@comma{} cap).
@item
If min is not zero@comma{} then call m(xr@comma{} d) and return its result.
@item
If greedy is false@comma{} then
@enumerate
@item
Call c(x) and let z be its result.
@item
If z is not failure@comma{} return z.
@item
Call m(xr@comma{} d) and return its result.
@end enumerate

@item
Call m(xr@comma{} d) and let z be its result.
@item
If z is not failure@comma{} return z.
@item
Call c(x) and return its result.
@end enumerate

NOTE An Atom followed by a Quantifier is repeated the number of times specified by the Quantifier. A Quantifier can be non-greedy@comma{} in which case the Atom pattern is repeated as few times as possible while still matching the sequel@comma{} or it can be greedy@comma{} in which case the Atom pattern is repeated as many times as possible while still matching the sequel. The Atom pattern is repeated rather than the input String that it matches@comma{} so different repetitions of the Atom can match different input substrings.

NOTE 2 If the Atom and the sequel of the regular expression all have choice points@comma{} the Atom is first matched as many (or as few@comma{} if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of Atom. All choices in the last (nth) repetition of Atom are tried before moving on to the next choice in the next-to-last (n−1)st repetition of Atom; at which point it may turn out that more or fewer repetitions of Atom are now possible; these are exhausted (again@comma{} starting with either as few or as many as possible) before moving on to the next choice in the (n−1)st repetition of Atom and so on. Compare
@verbatim
/a[a-z]{2,4}/.exec("abcdefghi")
@end verbatim

which returns "abcde" with
@verbatim
/a[a-z]{2,4}?/.exec("abcdefghi")
@end verbatim

which returns "abc".

Consider also
@verbatim
/(aa|aabaac|ba|b|c)*/.exec("aabaac")
@end verbatim

which@comma{} by the choice point ordering above@comma{} returns the array
@verbatim
["aaba", "ba"]
@end verbatim

and not any of:
@verbatim
["aabaac", "aabaac"]
["aabaac", "c"]
@end verbatim

The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:
@verbatim
"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")
@end verbatim

which returns the gcd in unary notation "aaaaa".

NOTE 3 Step 4 of the RepeatMatcher clears Atom’s captures each time Atom is repeated. We can see its behaviour in the regular expression
@verbatim
/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")
@end verbatim

which returns the array
@verbatim
["zaacbbbcac", "z", "ac", "a", undefined, "c"]
@end verbatim

and not
@verbatim
["zaacbbbcac", "z", "ac", "a", "bbb", "c"]
@end verbatim

because each iteration of the outermost @code{*} clears all captured Strings contained in the quantified Atom@comma{} which in this case includes capture Strings numbered 2@comma{} 3@comma{} and 4.


@verbatim
/(a*)*/.exec("b")
@end verbatim

or the slightly more complicated:
@verbatim
/(a*)b\1+/.exec("baaaac")
@end verbatim

which returns the array
@verbatim
["b", ""]
@end verbatim


@node 151026 Assertion
@chapter @uref{#sec-15.10.2.6,15.10.2.6} Assertion
The production Assertion :: @code{^} evaluates by returning an internal AssertionTester closure that takes a State argument x and performs the following:

@enumerate
@item
Let e be x’s endIndex.
@item
If e is zero@comma{} return true.
@item
If @uref{#def-Multiline,Multiline} is false@comma{} return false.
@item
If the character @uref{#def-Input,Input}[e−1] is one of LineTerminator@comma{} return true.
@item
Return false.
@end enumerate

The production Assertion :: @code{$} evaluates by returning an internal AssertionTester closure that takes a State argument x and performs the following:

@enumerate
@item
Let e be x’s endIndex.
@item
If e is equal to @uref{#def-InputLength,InputLength}@comma{} return true.
@item
If @uref{#def-Multiline,Multiline} is false@comma{} return false.
@item
If the character @uref{#def-Input,Input}[e] is one of LineTerminator@comma{} return true.
@item
Return false.
@end enumerate

The production Assertion :: @code{\} @code{b} evaluates by returning an internal AssertionTester closure that takes a State argument x and performs the following:

@enumerate
@item
Let e be x’s endIndex.
@item
Call @uref{#def-IsWordChar,IsWordChar}(e−1) and let a be the Boolean result.
@item
Call @uref{#def-IsWordChar,IsWordChar}(e) and let b be the Boolean result.
@item
If a is true and b is false@comma{} return true.
@item
If a is false and b is true@comma{} return true.
@item
Return false.
@end enumerate

The production Assertion :: @code{\} @code{B} evaluates by returning an internal AssertionTester closure that takes a State argument x and performs the following:

@enumerate
@item
Let e be x’s endIndex.
@item
Call @uref{#def-IsWordChar,IsWordChar}(e−1) and let a be the Boolean result.
@item
Call @uref{#def-IsWordChar,IsWordChar}(e) and let b be the Boolean result.
@item
If a is true and b is false@comma{} return false.
@item
If a is false and b is true@comma{} return false.
@item
Return true.
@end enumerate

The production Assertion :: @code{(} @code{?} @code{=} Disjunction @code{)} evaluates as follows:

@enumerate
@item
Evaluate Disjunction to obtain a Matcher m.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following steps:
@enumerate
@item
Let d be a Continuation that always returns its State argument as a successful MatchResult.
@item
Call m(x@comma{} d) and let r be its result.
@item
If r is failure@comma{} return failure.
@item
Let y be r’s State.
@item
Let cap be y’s captures internal array.
@item

@item
Let z be the State (xe@comma{} cap).
@item
Call c(z) and return its result.
@end enumerate

@end enumerate

The production Assertion :: @code{(} @code{?} @code{!} Disjunction @code{)} evaluates as follows:

@enumerate
@item
Evaluate Disjunction to obtain a Matcher m.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following steps:
@enumerate
@item
Let d be a Continuation that always returns its State argument as a successful MatchResult.
@item
Call m(x@comma{} d) and let r be its result.
@item
If r isn’t failure@comma{} return failure.
@item
Call c(x) and return its result.
@end enumerate

@end enumerate

The abstract operation IsWordChar takes an integer parameter e and performs the following:

@enumerate
@item
If e == −1 or e == @uref{#def-InputLength,InputLength}@comma{} return false.
@item
Let c be the character @uref{#def-Input,Input}[e].
@item
If c is one of the sixty-three characters below@comma{} return true.
@code{A b c d e f g h i j k l m n o p q r s t u v w x y z}
@code{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}
@code{0 1 2 3 4 5 6 7 8 9 _}
@item
Return false.
@end enumerate


@node 151027 Quantifier
@chapter @uref{#sec-15.10.2.7,15.10.2.7} Quantifier
The production Quantifier :: QuantifierPrefix evaluates as follows:

@enumerate
@item
Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max.
@item
Return the three results min @comma{} max@comma{} and true.
@end enumerate

The production Quantifier :: QuantifierPrefix @code{?} evaluates as follows:

@enumerate
@item
Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max.
@item
Return the three results min @comma{} max@comma{} and false.
@end enumerate

The production QuantifierPrefix :: @code{*} evaluates by returning the two results 0 and ∞.

The production QuantifierPrefix :: @code{+} evaluates by returning the two results 1 and ∞.

The production QuantifierPrefix :: @code{?} evaluates by returning the two results 0 and 1.

The production QuantifierPrefix :: @code{@{} DecimalDigits @code{@}} evaluates as follows:

@enumerate
@item
Let i be the MV of DecimalDigits (@uref{#sec-7.8.3,see 7.8.3}).
@item
Return the two results i and i.
@end enumerate

The production QuantifierPrefix :: @code{@{} DecimalDigits @code{@comma{}} @code{@}} evaluates as follows:

@enumerate
@item
Let i be the MV of DecimalDigits.
@item
Return the two results i and ∞.
@end enumerate

The production QuantifierPrefix :: @code{@{} DecimalDigits @code{@comma{}} DecimalDigits @code{@}} evaluates as follows:

@enumerate
@item
Let i be the MV of the first DecimalDigits.
@item
Let j be the MV of the second DecimalDigits.
@item
Return the two results i and j.
@end enumerate


@node 151028 Atom
@chapter @uref{#sec-15.10.2.8,15.10.2.8} Atom
The production Atom :: PatternCharacter evaluates as follows:

@enumerate
@item
Let ch be the character represented by PatternCharacter.
@item
Let A be a one-element CharSet containing the character ch.
@item
Call CharacterSetMatcher(A@comma{} false) and return its Matcher result.
@end enumerate

The production Atom :: @code{.} evaluates as follows:

@enumerate
@item
Let A be the set of all characters except LineTerminator.
@item
Call CharacterSetMatcher(A@comma{} false) and return its Matcher result.
@end enumerate

The production Atom :: @code{\} AtomEscape evaluates by evaluating AtomEscape to obtain a Matcher and returning that Matcher.

The production Atom :: CharacterClass evaluates as follows:

@enumerate
@item
Evaluate CharacterClass to obtain a CharSet A and a Boolean invert.
@item
Call CharacterSetMatcher(A@comma{} invert) and return its Matcher result.
@end enumerate

The production Atom :: @code{(} Disjunction @code{)} evaluates as follows:

@enumerate
@item
Evaluate Disjunction to obtain a Matcher m.
@item
Let parenIndex be the number of left capturing parentheses in the entire regular expression that occur to the left of this production expansion’s initial left parenthesis. This is the total number of times the Atom :: @code{(} Disjunction @code{)} production is expanded prior to this production’s Atom plus the total number of Atom :: @code{(} Disjunction @code{)} productions enclosing this Atom.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following steps:
@enumerate
@item
Create an internal Continuation closure d that takes one State argument y and performs the following steps:
@enumerate
@item
Let cap be a fresh copy of y’s captures internal array.
@item
Let xe be x’s endIndex.
@item
Let ye be y’s endIndex.
@item
Let s be a fresh String whose characters are the characters of @uref{#def-Input,Input} at positions xe (inclusive) through ye (exclusive).
@item
Set cap[parenIndex+1] to s.
@item
Let z be the State (ye@comma{} cap).
@item
Call c(z) and return its result.
@end enumerate

@item
Call m(x@comma{} d) and return its result.
@end enumerate

@end enumerate

The production Atom :: @code{(} @code{?} @code{:} Disjunction @code{)} evaluates by evaluating Disjunction to obtain a Matcher and returning that Matcher.

The abstract operation CharacterSetMatcher takes two arguments@comma{} a CharSet A and a Boolean flag invert@comma{} and performs the following:

@enumerate
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following steps:
@enumerate
@item
Let e be x’s endIndex.
@item
If e == @uref{#def-InputLength,InputLength}@comma{} return failure.
@item
Let c be the character @uref{#def-Input,Input}[e].
@item
Let cc be the result of @uref{#def-Canonicalize,Canonicalize}(c).
@item
If invert is false@comma{} then
@enumerate
@item
If there does not exist a member a of set A such that @uref{#def-Canonicalize,Canonicalize}(a) == cc@comma{} return failure.
@end enumerate

@item
Else invert is true@comma{}
@enumerate
@item
If there exists a member a of set A such that @uref{#def-Canonicalize,Canonicalize}(a) == cc@comma{} return failure.
@end enumerate

@item

@item
Let y be the State (e+1@comma{} cap).
@item
Call c(y) and return its result.
@end enumerate

@end enumerate

The abstract operation Canonicalize takes a character parameter ch and performs the following steps:

@enumerate
@item
If @uref{#def-IgnoreCase,IgnoreCase} is false@comma{} return ch.
@item
Let u be ch converted to upper case as if by calling the standard built-in method String.prototype.toUpperCase on the one-character String ch.
@item
If u does not consist of a single character@comma{} return ch.
@item
Let cu be u’s character.
@item
If ch’s code unit value is greater than or equal to decimal 128 and cu’s code unit value is less than decimal 128@comma{} then return ch.
@item
Return cu.
@end enumerate

NOTE 1 Parentheses of the form @code{(} Disjunction @code{)} serve both to group the components of the Disjunction pattern together and to save the result of the match. The result can be used either in a backreference (@code{\} followed by a nonzero decimal number)@comma{} referenced in a replace String@comma{} or returned as part of an array from the regular expression matching internal procedure. To inhibit the capturing behaviour of parentheses@comma{} use the form @code{(?:} Disjunction @code{)} instead.

NOTE 2 The form @code{(?=} Disjunction @code{)} specifies a zero-width positive lookahead. In order for it to succeed@comma{} the pattern inside Disjunction must match at the current position@comma{} but the current position is not advanced before matching the sequel. If Disjunction can match at the current position in several ways@comma{} only the first one is tried. Unlike other regular expression operators@comma{} there is no backtracking into a @code{(?=} form (this unusual behaviour is inherited from Perl). This only matters when the Disjunction contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.

For example@comma{}
@verbatim
/(?=(a+))/.exec("baaabac")
@end verbatim

matches the empty String immediately after the first @code{b} and therefore returns the array:
@verbatim
["", "aaa"]
@end verbatim

To illustrate the lack of backtracking into the lookahead@comma{} consider:
@verbatim
/(?=(a+))a*b\1/.exec("baaabac")
@end verbatim

This expression returns
@verbatim
["aba", "a"]
@end verbatim

and not:
@verbatim
["aaaba", "a"]
@end verbatim

NOTE 3 The form @code{(?!} Disjunction @code{)} specifies a zero-width negative lookahead. In order for it to succeed@comma{} the pattern inside Disjunction must fail to match at the current position. The current position is not advanced before matching the sequel. Disjunction can contain capturing parentheses@comma{} but backreferences to them only make sense from within Disjunction itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return undefined because the negative lookahead must fail for the pattern to succeed. For example@comma{}
@verbatim
/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")
@end verbatim

looks for an @code{a} not immediately followed by some positive number n of @code{a}’s@comma{} a @code{b}@comma{} another n @code{a}’s (specified by the first @code{\2}) and a @code{c}. The second @code{\2} is outside the negative lookahead@comma{} so it matches against undefined and therefore always succeeds. The whole expression returns the array:
@verbatim
["baaabaac", "ba", undefined, "abaac"]
@end verbatim

In case-insignificant matches all characters are implicitly converted to upper case immediately before they are compared. However@comma{} if converting a character to upper case would expand that character into more than one character (such as converting "ß" (\u00DF) into "SS")@comma{} then the character is left as-is instead. The character is also left as-is if it is not an ASCII character but converting it to upper case would make it into an ASCII character. This prevents Unicode characters such as \u0131 and \u017F from matching regular expressions such as @code{/[a-z]/i}@comma{} which are only intended to match ASCII letters. Furthermore@comma{} if these conversions were allowed@comma{} then @code{/[^\W]/i} would match each of @code{a}@comma{} @code{b}@comma{} ...@comma{} @code{h}@comma{} but not @code{i} or @code{s}.



@node 151029 AtomEscape
@chapter @uref{#sec-15.10.2.9,15.10.2.9} AtomEscape
The production AtomEscape :: DecimalEscape evaluates as follows:

@enumerate
@item
Evaluate DecimalEscape to obtain an EscapeValue e.
@item
If e is a character@comma{} then
@enumerate
@item
Let ch be e’s character.
@item
Let A be a one-element CharSet containing the character ch.
@item
Call CharacterSetMatcher(A@comma{} false) and return its Matcher result.
@end enumerate

@item
e must be an integer. Let n be that integer.
@item
If n=0 or n>@uref{#def-NcapturingParens,NcapturingParens} then throw a SyntaxError exception.
@item
Return an internal Matcher closure that takes two arguments@comma{} a State x and a Continuation c@comma{} and performs the following:
@enumerate
@item
Let cap be x’s captures internal array.
@item
Let s be cap[n].
@item
If s is undefined@comma{} then call c(x) and return its result.
@item
Let e be x’s endIndex.
@item
Let len be s’s length.
@item
Let f be e+len.
@item
If f>@uref{#def-InputLength,InputLength}@comma{} return failure.
@item
If there exists an integer i between 0 (inclusive) and len (exclusive) such that @uref{#def-Canonicalize,Canonicalize}(s[i]) is not the same character as @uref{#def-Canonicalize,Canonicalize}(@uref{#def-Input,Input}[e+i])@comma{} then return failure.
@item
Let y be the State (f@comma{} cap).
@item
Call c(y) and return its result.
@end enumerate

@end enumerate

The production AtomEscape :: CharacterEscape evaluates as follows:

@enumerate
@item
Evaluate CharacterEscape to obtain a character ch.
@item
Let A be a one-element CharSet containing the character ch.
@item
Call CharacterSetMatcher(A@comma{} false) and return its Matcher result.
@end enumerate

The production AtomEscape :: CharacterClassEscape evaluates as follows:

@enumerate
@item
Evaluate CharacterClassEscape to obtain a CharSet A.
@item
Call CharacterSetMatcher(A@comma{} false) and return its Matcher result.
@end enumerate

NOTE An escape sequence of the form @code{\} followed by a nonzero decimal number n matches the result of the nth set of capturing parentheses (@uref{#sec-15.10.2.11,see 15.10.2.11}). It is an error if the regular expression has fewer than n capturing parentheses. If the regular expression has n or more capturing parentheses but the nth one is undefined because it has not captured anything@comma{} then the backreference always succeeds.


@node 1510210 CharacterEscape
@chapter @uref{#sec-15.10.2.10,15.10.2.10} CharacterEscape
The production CharacterEscape :: ControlEscape evaluates by returning the character according to Table 23.

Table 23 — ControlEscape Character Values
ControlEscape
Code Unit
Name
Symbol
@code{t}
@code{\u0009}
horizontal tab
<HT>
@code{n}
@code{\u000A}
line feed (new line)
<LF>
@code{v}
@code{\u000B}
vertical tab
<VT>
@code{f}
@code{\u000C}
form feed
<FF>
@code{r}
@code{\u000D}
carriage return
<CR>
The production CharacterEscape :: @code{c} ControlLetter evaluates as follows:


@enumerate
@item
Let ch be the character represented by ControlLetter.
@item
Let i be ch’s code unit value.
@item
Let j be the remainder of dividing i by 32.
@item
Return the code unit numbered j.
@end enumerate

The production CharacterEscape :: HexEscapeSequence evaluates by evaluating the CV of the HexEscapeSequence (@uref{#sec-7.8.4,see 7.8.4}) and returning its character result.

The production CharacterEscape :: UnicodeEscapeSequence evaluates by evaluating the CV of the UnicodeEscapeSequence (@uref{#sec-7.8.4,see 7.8.4}) and returning its character result.

The production CharacterEscape :: IdentityEscape evaluates by returning the character represented by IdentityEscape.


@node 1510211 DecimalEscape
@chapter @uref{#sec-15.10.2.11,15.10.2.11} DecimalEscape
The production DecimalEscape :: DecimalIntegerLiteral [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit] evaluates as follows.

@enumerate
@item
Let i be @uref{#sec-7.8.3,the MV of} DecimalIntegerLiteral.
@item
If i is zero@comma{} return the EscapeValue consisting of a <NUL> character (Unicode value 0000).
@item
Return the EscapeValue consisting of the integer i.
@end enumerate

The definition of “the MV of DecimalIntegerLiteral” is in @uref{#sec-7.8.3,7.8.3}.

NOTE If @code{\} is followed by a decimal number n whose first digit is not @code{0}@comma{} then the escape sequence is considered to be a backreference. It is an error if n is greater than the total number of left capturing parentheses in the entire regular expression. @code{\0} represents the <NUL> character and cannot be followed by a decimal digit.


@node 1510212 CharacterClassEscape
@chapter @uref{#sec-15.10.2.12,15.10.2.12} CharacterClassEscape
The production CharacterClassEscape :: @code{d} evaluates by returning the ten-element set of characters containing the characters @code{0} through @code{9} inclusive.

The production CharacterClassEscape :: @code{D} evaluates by returning the set of all characters not included in the set returned by CharacterClassEscape :: @code{d}.

The production CharacterClassEscape :: @code{s} evaluates by returning the set of characters containing the characters that are on the right-hand side of the WhiteSpace (@uref{#sec-7.2,7.2}) or LineTerminator (@uref{#sec-7.3,7.3}) productions.

The production CharacterClassEscape :: @code{S} evaluates by returning the set of all characters not included in the set returned by CharacterClassEscape :: @code{s}.

The production CharacterClassEscape :: @code{w} evaluates by returning the set of characters containing the sixty-three characters:
@verbatim
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9 _
@end verbatim

The production CharacterClassEscape :: @code{W} evaluates by returning the set of all characters not included in the set returned by CharacterClassEscape :: @code{w}.


@node 1510213 CharacterClass
@chapter @uref{#sec-15.10.2.13,15.10.2.13} CharacterClass
The production CharacterClass :: @code{[} [@uref{#def-lookahead-notin,lookahead ∉} @{@code{^}@}] ClassRanges @code{]} evaluates by evaluating ClassRanges to obtain a CharSet and returning that CharSet and the Boolean false.




@node 1510214 ClassRanges
@chapter @uref{#sec-15.10.2.14,15.10.2.14} ClassRanges
The production ClassRanges :: [empty] evaluates by returning the empty CharSet.

The production ClassRanges :: NonemptyClassRanges evaluates by evaluating NonemptyClassRanges to obtain a CharSet and returning that CharSet.


@node 1510215 NonemptyClassRanges
@chapter @uref{#sec-15.10.2.15,15.10.2.15} NonemptyClassRanges
The production NonemptyClassRanges :: ClassAtom evaluates by evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash evaluates as follows:

@enumerate
@item
Evaluate ClassAtom to obtain a CharSet A.
@item
Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.
@item
Return the union of CharSets A and B.
@end enumerate

The production NonemptyClassRanges :: ClassAtom @code{-} ClassAtom ClassRanges evaluates as follows:

@enumerate
@item
Evaluate the first ClassAtom to obtain a CharSet A.
@item
Evaluate the second ClassAtom to obtain a CharSet B.
@item
Evaluate ClassRanges to obtain a CharSet C.
@item
Call CharacterRange(A@comma{} B) and let D be the resulting CharSet.
@item
Return the union of CharSets D and C.
@end enumerate

The abstract operation CharacterRange takes two CharSet parameters A and B and performs the following:

@enumerate
@item
If a does not contain exactly one character or b does not contain exactly one character then throw a SyntaxError exception.
@item
Let a be the one character in CharSet a.
@item
Let b be the one character in CharSet b.
@item
Let i be the code unit value of character a.
@item
Let j be the code unit value of character b.
@item
If i > j then throw a SyntaxError exception.
@item
Return the set containing all characters numbered i through j@comma{} inclusive.
@end enumerate


@node 1510216 NonemptyClassRangesNoDash
@chapter @uref{#sec-15.10.2.16,15.10.2.16} NonemptyClassRangesNoDash
The production NonemptyClassRangesNoDash :: ClassAtom evaluates by evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash evaluates as follows:

@enumerate
@item
Evaluate ClassAtomNoDash to obtain a CharSet A.
@item
Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.
@item
Return the union of CharSets A and B.
@end enumerate

The production NonemptyClassRangesNoDash :: ClassAtomNoDash @code{-} ClassAtom ClassRanges evaluates as follows:

@enumerate
@item
Evaluate ClassAtomNoDash to obtain a CharSet A.
@item
Evaluate ClassAtom to obtain a CharSet B.
@item
Evaluate ClassRanges to obtain a CharSet C.
@item

@item
Return the union of CharSets D and C.
@end enumerate

NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges of two ClassAtoms separated by dashes. In the latter case the ClassRanges includes all characters between the first ClassAtom and the second ClassAtom@comma{} inclusive; an error occurs if either ClassAtom does not represent a single character (for example@comma{} if one is @code{\w}) or if the first ClassAtom’s code unit value is greater than the second ClassAtom’s code unit value.

NOTE 2 Even if the pattern ignores case@comma{} the case of the two ends of a range is significant in determining which characters belong to the range. Thus@comma{} for example@comma{} the pattern @code{/[E-F]/i} matches only the letters @code{E}@comma{} @code{F}@comma{} @code{e}@comma{} and @code{f}@comma{} while the pattern @code{/[E-f]/i} matches all upper and lower-case ASCII letters as well as the symbols @code{[}@comma{} @code{\}@comma{} @code{]}@comma{} @code{^}@comma{} @code{_}@comma{} and @code{`}.

NOTE 3 A @code{-} character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of ClassRanges@comma{} the beginning or end limit of a range specification@comma{} or immediately follows a range specification.


@node 1510217 ClassAtom
@chapter @uref{#sec-15.10.2.17,15.10.2.17} ClassAtom
The production ClassAtom :: @code{-} evaluates by returning the CharSet containing the one character @code{-}.

The production ClassAtom :: ClassAtomNoDash evaluates by evaluating ClassAtomNoDash to obtain a CharSet and returning that CharSet.


@node 1510218 ClassAtomNoDash
@chapter @uref{#sec-15.10.2.18,15.10.2.18} ClassAtomNoDash
The production ClassAtomNoDash :: SourceCharacter but not one of @code{\} or @code{]} or @code{-} evaluates by returning a one-element CharSet containing the character represented by SourceCharacter.

The production ClassAtomNoDash :: @code{\} ClassEscape evaluates by evaluating ClassEscape to obtain a CharSet and returning that CharSet.


@node 1510219 ClassEscape
@chapter @uref{#sec-15.10.2.19,15.10.2.19} ClassEscape
The production ClassEscape :: DecimalEscape evaluates as follows:

@enumerate
@item
Evaluate DecimalEscape to obtain an EscapeValue E.
@item
If E is not a character then throw a SyntaxError exception.
@item
Let ch be E’s character.
@item
Return the one-element CharSet containing the character ch.
@end enumerate

The production ClassEscape :: @code{b} evaluates by returning the CharSet containing the one character <BS> (Unicode value 0008).

The production ClassEscape :: CharacterEscape evaluates by evaluating CharacterEscape to obtain a character and returning a one-element CharSet containing that character.

The production ClassEscape :: CharacterClassEscape evaluates by evaluating CharacterClassEscape to obtain a CharSet and returning that CharSet.

NOTE A ClassAtom can use any of the escape sequences that are allowed in the rest of the regular expression except for @code{\b}@comma{} @code{\B}@comma{} and backreferences. Inside a CharacterClass@comma{} @code{\b} means the backspace character@comma{} while @code{\B} and backreferences raise errors. Using a backreference inside a ClassAtom causes an error.



@node 15103 The RegExp Constructor Called as a Function
@chapter @uref{#sec-15.10.3,15.10.3} The RegExp Constructor Called as a Function

@node 151031 RegExppattern flags
@chapter @uref{#sec-15.10.3.1,15.10.3.1} RegExp(pattern@comma{} flags)
If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined@comma{} then return R unchanged. Otherwise call the standard built-in RegExp constructor (@uref{#sec-15.10.4.1,15.10.4.1}) as if by the expression @code{new RegExp(<var>pattern</var>@comma{} <var>flags</var>)} and return the object constructed by that constructor.


@node 15104 The RegExp Constructor
@chapter @uref{#sec-15.10.4,15.10.4} The RegExp Constructor
When RegExp is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 151041 new RegExppattern flags
@chapter @uref{#sec-15.10.4.1,15.10.4.1} new RegExp(pattern@comma{} flags)
If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined@comma{} then let P be the pattern used to construct R and let F be the flags used to construct R. If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is not undefined@comma{} then throw a TypeError exception. Otherwise@comma{} let P be the empty String if pattern is undefined and @uref{#sec-9.8,ToString}(pattern) otherwise@comma{} and let F be the empty String if flags is undefined and @uref{#sec-9.8,ToString}(flags) otherwise.

If the characters of P do not have the syntactic form Pattern@comma{} then throw a SyntaxError exception. Otherwise let the newly constructed object have a [[Match]] internal property obtained by evaluating (“compiling”) the characters of P as a Pattern as described in @uref{#sec-15.10.2,15.10.2}.

If F contains any character other than "g"@comma{} "i"@comma{} or "m"@comma{} or if it contains the same character more than once@comma{} then throw a SyntaxError exception.

If a SyntaxError exception is not thrown@comma{} then:

Let S be a String in the form of a Pattern equivalent to P@comma{} in which certain characters are escaped as described below. S may or may not be identical to P or pattern; however@comma{} the internal procedure that would result from evaluating S as a Pattern must behave identically to the internal procedure given by the constructed object’s [[Match]] internal property.

The characters @code{/} or backslash @code{\} occurring in the pattern shall be escaped in S as necessary to ensure that the String value formed by concatenating the Strings "/"@comma{} S@comma{} "/"@comma{} and F can be parsed (in an appropriate lexical context) as a RegularExpressionLiteral that behaves identically to the constructed regular expression. For example@comma{} if P is "/"@comma{} then S could be "\/" or "\u002F"@comma{} among other possibilities@comma{} but not "/"@comma{} because @code{///} followed by F would be parsed as a SingleLineComment rather than a RegularExpressionLiteral. If P is the empty String@comma{} this specification can be met by letting S be "(?:)".

The following properties of the newly constructed object are data properties with the attributes that are specified in @uref{#sec-15.10.7,15.10.7}. The [[Value]] of each property is set as follows:

The @code{source} property of the newly constructed object is set to S.

The @code{global} property of the newly constructed object is set to a Boolean value that is true if F contains the character "g" and false otherwise.

The @code{ignoreCase} property of the newly constructed object is set to a Boolean value that is true if F contains the character "i" and false otherwise.

The @code{multiline} property of the newly constructed object is set to a Boolean value that is true if F contains the character "m" and false otherwise.

The @code{lastIndex} property of the newly constructed object is set to 0.



The [[Class]] internal property of the newly constructed object is set to "RegExp".

NOTE If pattern is a StringLiteral@comma{} the usual escape sequence substitutions are performed before the String is processed by RegExp. If pattern must contain an escape sequence to be recognised by RegExp@comma{} any backslash @code{\} characters must be escaped within the StringLiteral to prevent them being removed when the contents of the StringLiteral are formed.


@node 15105 Properties of the RegExp Constructor
@chapter @uref{#sec-15.10.5,15.10.5} Properties of the RegExp Constructor
The value of the [[Prototype]] internal property of the RegExp constructor is the standard built-in Function prototype object (@uref{#sec-15.3.4,15.3.4}).

Besides the internal properties and the @code{length} property (whose value is 2)@comma{} the RegExp constructor has the following properties:


@node 151051 RegExpprototype
@chapter @uref{#sec-15.10.5.1,15.10.5.1} RegExp.prototype
The initial value of RegExp.prototype is the RegExp prototype object (@uref{#sec-15.10.6,15.10.6}).

This property shall have the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15106 Properties of the RegExp Prototype Object
@chapter @uref{#sec-15.10.6,15.10.6} Properties of the RegExp Prototype Object
The value of the [[Prototype]] internal property of the RegExp prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}). The RegExp prototype object is itself a regular expression object; its [[Class]] is "RegExp". The initial values of the RegExp prototype object’s data properties (@uref{#sec-15.10.7,15.10.7}) are set as if the object was created by the expression @code{new RegExp()} where @code{RegExp} is that standard built-in constructor with that name.

The RegExp prototype object does not have a @code{valueOf} property of its own; however@comma{} it inherits the @code{valueOf} property from the Object prototype object.

In the following descriptions of functions that are properties of the RegExp prototype object@comma{} the phrase “this RegExp object” refers to the object that is the this value for the invocation of the function; a TypeError exception is thrown if the this value is not an object or an object for which the value of the [[Class]] internal property is not "RegExp".


@node 151061 RegExpprototypeconstructor
@chapter @uref{#sec-15.10.6.1,15.10.6.1} RegExp.prototype.constructor
The initial value of RegExp.prototype.constructor is the standard built-in RegExp constructor.


@node 151062 RegExpprototypeexecstring
@chapter @uref{#sec-15.10.6.2,15.10.6.2} RegExp.prototype.exec(string)
Performs a regular expression match of string against the regular expression and returns an Array object containing the results of the match@comma{} or null if string did not match.

The String @uref{#sec-9.8,ToString}(string) is searched for an occurrence of the regular expression pattern as follows:

@enumerate
@item
Let R be @uref{#def-this-RegExp-object,this RegExp object}.
@item
Let S be the value of @uref{#sec-9.8,ToString}(string).
@item
Let length be the length of S.
@item
Let lastIndex be the result of calling the [[Get]] internal method of R with argument "lastIndex".
@item
Let i be the value of @uref{#sec-9.4,ToInteger}(lastIndex).
@item
Let global be the result of calling the [[Get]] internal method of R with argument "global".
@item

@item
Let matchSucceeded be false.
@item
Repeat@comma{} while matchSucceeded is false
@enumerate
@item
If i < 0 or i > length@comma{} then
@enumerate
@item
Call the [[Put]] internal method of R with arguments "lastIndex"@comma{} 0@comma{} and true.
@item
Return null.
@end enumerate

@item
Call the [[Match]] internal method of R with arguments S and i.
@item
If [[Match]] returned failure@comma{} then
@enumerate
@item
Let i = i+1.
@end enumerate

@item
else
@enumerate
@item
Let r be the State result of the call to [[Match]].
@item
Set matchSucceeded to true.
@end enumerate

@item
Let i = i+1.
@end enumerate

@item
Let e be r’s endIndex value.
@item
If global is true@comma{}
@enumerate
@item
Call the [[Put]] internal method of R with arguments "lastIndex"@comma{} e@comma{} and true.
@end enumerate

@item
Let n be the length of r’s captures array. (This is the same value as @uref{#sec-15.10.2.1,15.10.2.1}’s @uref{#def-NcapturingParens,NcapturingParens}.)
@item
Let A be a new array created as if by the expression @code{new Array()} where @code{Array} is the standard built-in constructor with that name.
@item
Let matchIndex be the position of the matched substring within the complete String S.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments "index"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: matchIndex@comma{} [[Writable]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and true.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments "input"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: S@comma{} [[Writable]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and true.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments "length"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: n + 1@}@comma{} and true.
@item
Let matchedSubstr be the matched substring (i.e. the portion of S between offset i inclusive and offset e exclusive).
@item
Call the [[DefineOwnProperty]] internal method of A with arguments "0"@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: matchedSubstr@comma{} [[Writable]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and true.
@item
For each integer i such that i > 0 and i ≤ n
@enumerate
@item
Let captureI be ith element of r’s captures array.
@item
Call the [[DefineOwnProperty]] internal method of A with arguments @uref{#sec-9.8,ToString}(i)@comma{} @uref{#sec-8.10,Property Descriptor} @{[[Value]]: captureI@comma{} [[Writable]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and true.
@end enumerate

@item
Return A.
@end enumerate


@node 151063 RegExpprototypeteststring
@chapter @uref{#sec-15.10.6.3,15.10.6.3} RegExp.prototype.test(string)
The following steps are taken:

@enumerate
@item
Let match be the result of evaluating the RegExp.prototype.exec (@uref{#sec-15.10.6.2,15.10.6.2}) algorithm upon @uref{#def-this-RegExp-object,this RegExp object} using string as the argument.
@item
If match is not null@comma{} then return true; else return false.
@end enumerate


@node 151064 RegExpprototypetoString
@chapter @uref{#sec-15.10.6.4,15.10.6.4} RegExp.prototype.toString()
Return the String value formed by concatenating the Strings "/"@comma{} the String value of the @code{source} property of @uref{#def-this-RegExp-object,this RegExp object}@comma{} and "/"; plus "g" if the @code{global} property is true@comma{} "i" if the @code{ignoreCase} property is true@comma{} and "m" if the @code{multiline} property is true.

NOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object with the same behaviour as this object.


@node 15107 Properties of RegExp Instances
@chapter @uref{#sec-15.10.7,15.10.7} Properties of RegExp Instances
RegExp instances inherit properties from the RegExp prototype object and their [[Class]] internal property value is "RegExp". RegExp instances also have a [[Match]] internal property and a @code{length} property.



RegExp instances also have the following properties.


@node 151071 source
@chapter @uref{#sec-15.10.7.1,15.10.7.1} source
The value of the @code{source} property is a String in the form of a Pattern representing the current regular expression. This property shall have the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 151072 global
@chapter @uref{#sec-15.10.7.2,15.10.7.2} global
The value of the @code{global} property is a Boolean value indicating whether the flags contained the character "g". This property shall have the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 151073 ignoreCase
@chapter @uref{#sec-15.10.7.3,15.10.7.3} ignoreCase
The value of the @code{ignoreCase} property is a Boolean value indicating whether the flags contained the character "i". This property shall have the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 151074 multiline
@chapter @uref{#sec-15.10.7.4,15.10.7.4} multiline
The value of the @code{multiline} property is a Boolean value indicating whether the flags contained the character "m". This property shall have the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 151075 lastIndex
@chapter @uref{#sec-15.10.7.5,15.10.7.5} lastIndex
The value of the @code{lastIndex} property specifies the String position at which to start the next match. It is coerced to an integer when used (@uref{#sec-15.10.6.2,see 15.10.6.2}). This property shall have the attributes @{ [[Writable]]: true@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.

NOTE Unlike the other standard built-in properties of RegExp instances@comma{} lastIndex is writable.


@node 1511 Error Objects
@chapter @uref{#sec-15.11,15.11} Error Objects
Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.


@node 15111 The Error Constructor Called as a Function
@chapter @uref{#sec-15.11.1,15.11.1} The Error Constructor Called as a Function
When Error is called as a function rather than as a constructor@comma{} it creates and initialises a new Error object. Thus the function call @code{Error(<var>...</var>)} is equivalent to the object creation expression @code{new Error(<var>...</var>)} with the same arguments.


@node 151111 Error message
@chapter @uref{#sec-15.11.1.1,15.11.1.1} Error (message)
The [[Prototype]] internal property of the newly constructed object is set to the original Error prototype object@comma{} the one that is the initial value of Error.prototype (@uref{#sec-15.11.3.1,15.11.3.1}).

The [[Class]] internal property of the newly constructed object is set to "Error".

The [[Extensible]] internal property of the newly constructed object is set to true.




@node 15112 The Error Constructor
@chapter @uref{#sec-15.11.2,15.11.2} The Error Constructor
When Error is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 151121 new Error message
@chapter @uref{#sec-15.11.2.1,15.11.2.1} new Error (message)
The [[Prototype]] internal property of the newly constructed object is set to the original Error prototype object@comma{} the one that is the initial value of Error.prototype (@uref{#sec-15.11.3.1,15.11.3.1}).

The [[Class]] internal property of the newly constructed Error object is set to "Error".

The [[Extensible]] internal property of the newly constructed object is set to true.

If the argument message is not undefined@comma{} the @code{message} own property of the newly constructed object is set to @uref{#sec-9.8,ToString}(message).


@node 15113 Properties of the Error Constructor
@chapter @uref{#sec-15.11.3,15.11.3} Properties of the Error Constructor
The value of the [[Prototype]] internal property of the Error constructor is @uref{#sec-15.3.4,the Function prototype object (15.3.4)}.

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} the Error constructor has the following property:


@node 151131 Errorprototype
@chapter @uref{#sec-15.11.3.1,15.11.3.1} Error.prototype
The initial value of Error.prototype is the Error prototype object (@uref{#sec-15.11.4,15.11.4}).

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.


@node 15114 Properties of the Error Prototype Object
@chapter @uref{#sec-15.11.4,15.11.4} Properties of the Error Prototype Object
The Error prototype object is itself an Error object (its [[Class]] is "Error").

The value of the [[Prototype]] internal property of the Error prototype object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}).


@node 151141 Errorprototypeconstructor
@chapter @uref{#sec-15.11.4.1,15.11.4.1} Error.prototype.constructor
The initial value of Error.prototype.constructor is the built-in Error constructor.


@node 151142 Errorprototypename
@chapter @uref{#sec-15.11.4.2,15.11.4.2} Error.prototype.name
The initial value of Error.prototype.name is "Error".


@node 151143 Errorprototypemessage
@chapter @uref{#sec-15.11.4.3,15.11.4.3} Error.prototype.message
The initial value of Error.prototype.message is the empty String.


@node 151144 ErrorprototypetoString
@chapter @uref{#sec-15.11.4.4,15.11.4.4} Error.prototype.toString ( )
The following steps are taken:

@enumerate
@item

@item
If @uref{#def-type,Type}(O) is not Object@comma{} throw a TypeError exception.
@item
Let name be the result of calling the [[Get]] internal method of O with argument "name".
@item
If name is undefined@comma{} then let name be "Error"; else let name be @uref{#sec-9.8,ToString}(name).
@item
Let msg be the result of calling the [[Get]] internal method of O with argument "message".
@item
If msg is undefined@comma{} then let msg be the empty String; else let msg be @uref{#sec-9.8,ToString}(msg).
@item
If name and msg are both the empty String@comma{} return "Error".
@item
If name is the empty String@comma{} return msg.
@item
If msg is the empty String@comma{} return name.
@item
Return the result of concatenating name@comma{} ":"@comma{} a single space character@comma{} and msg.
@end enumerate


@node 15115 Properties of Error Instances
@chapter @uref{#sec-15.11.5,15.11.5} Properties of Error Instances
Error instances inherit properties from the Error prototype object and their [[Class]] internal property value is "Error". Error instances have no special properties.


@node 15116 Native Error Types Used in This Standard
@chapter @uref{#sec-15.11.6,15.11.6} Native Error Types Used in This Standard
One of the NativeError objects below is thrown when a runtime error is detected. All of these objects share the same structure@comma{} as described in @uref{#sec-15.11.7,15.11.7}.


@node 151161 EvalError
@chapter @uref{#sec-15.11.6.1,15.11.6.1} EvalError
This exception is not currently used within this specification. This object remains for compatibility with previous editions of this specification.


@node 151162 RangeError
@chapter @uref{#sec-15.11.6.2,15.11.6.2} RangeError
Indicates a numeric value has exceeded the allowable range. @uref{#sec-15.4.2.2,See 15.4.2.2}@comma{} @uref{#sec-15.4.5.1,15.4.5.1}@comma{} @uref{#sec-15.7.4.2,15.7.4.2}@comma{} @uref{#sec-15.7.4.5,15.7.4.5}@comma{} @uref{#sec-15.7.4.6,15.7.4.6}@comma{} and @uref{#sec-15.7.4.7,15.7.4.7}@comma{} @uref{#sec-15.9.5.43,15.9.5.43}.


@node 151163 ReferenceError
@chapter @uref{#sec-15.11.6.3,15.11.6.3} ReferenceError
Indicate that an invalid reference value has been detected. @uref{#sec-8.7.1,See 8.7.1}@comma{} @uref{#sec-8.7.2,8.7.2}@comma{} @uref{#sec-10.2.1,10.2.1}@comma{} @uref{#sec-10.2.1.1.4,10.2.1.1.4}@comma{} @uref{#sec-10.2.1.2.4,10.2.1.2.4}@comma{} and @uref{#sec-11.13.1,11.13.1}.


@node 151164 SyntaxError
@chapter @uref{#sec-15.11.6.4,15.11.6.4} SyntaxError
Indicates that a parsing error has occurred. @uref{#sec-11.1.5,See 11.1.5}@comma{} @uref{#sec-11.3.1,11.3.1}@comma{} @uref{#sec-11.3.2,11.3.2}@comma{} @uref{#sec-11.4.1,11.4.1}@comma{} @uref{#sec-11.4.4,11.4.4}@comma{} @uref{#sec-11.4.5,11.4.5}@comma{} @uref{#sec-11.13.1,11.13.1}@comma{} @uref{#sec-11.13.2,11.13.2}@comma{} @uref{#sec-12.2.1,12.2.1}@comma{} @uref{#sec-12.10.1,12.10.1}@comma{} @uref{#sec-12.14.1,12.14.1}@comma{} @uref{#sec-13.1,13.1}@comma{} @uref{#sec-15.1.2.1,15.1.2.1}@comma{} @uref{#sec-15.3.2.1,15.3.2.1}@comma{} @uref{#sec-15.10.2.2,15.10.2.2}@comma{} @uref{#sec-15.10.2.5,15.10.2.5}@comma{} @uref{#sec-15.10.2.9,15.10.2.9}@comma{} @uref{#sec-15.10.2.15,15.10.2.15}@comma{} @uref{#sec-15.10.2.19,15.10.2.19}@comma{} @uref{#sec-15.10.4.1,15.10.4.1}@comma{} and @uref{#sec-15.12.2,15.12.2}.


@node 151165 TypeError
@chapter @uref{#sec-15.11.6.5,15.11.6.5} TypeError
Indicates the actual type of an operand is different than the expected type. @uref{#sec-8.6.2,See 8.6.2}@comma{} @uref{#sec-8.7.2,8.7.2}@comma{} @uref{#sec-8.10.5,8.10.5}@comma{} @uref{#sec-8.12.5,8.12.5}@comma{} @uref{#sec-8.12.7,8.12.7}@comma{} @uref{#sec-8.12.8,8.12.8}@comma{} @uref{#sec-8.12.9,8.12.9}@comma{} @uref{#sec-9.9,9.9}@comma{} @uref{#sec-9.10,9.10}@comma{} @uref{#sec-10.2.1,10.2.1}@comma{} @uref{#sec-10.2.1.1.3,10.2.1.1.3}@comma{} @uref{#sec-10.6,10.6}@comma{} @uref{#sec-11.2.2,11.2.2}@comma{} @uref{#sec-11.2.3,11.2.3}@comma{} @uref{#sec-11.4.1,11.4.1}@comma{} @uref{#sec-11.8.6,11.8.6}@comma{} @uref{#sec-11.8.7,11.8.7}@comma{} @uref{#sec-11.3.1,11.3.1}@comma{} @uref{#sec-13.2,13.2}@comma{} @uref{#sec-13.2.3,13.2.3}@comma{} @uref{#sec-15,15}@comma{} @uref{#sec-15.2.3.2,15.2.3.2}@comma{} @uref{#sec-15.2.3.3,15.2.3.3}@comma{} @uref{#sec-15.2.3.4,15.2.3.4}@comma{} @uref{#sec-15.2.3.5,15.2.3.5}@comma{} @uref{#sec-15.2.3.6,15.2.3.6}@comma{} @uref{#sec-15.2.3.7,15.2.3.7}@comma{} @uref{#sec-15.2.3.8,15.2.3.8}@comma{} @uref{#sec-15.2.3.9,15.2.3.9}@comma{} @uref{#sec-15.2.3.10,15.2.3.10}@comma{} @uref{#sec-15.2.3.11,15.2.3.11}@comma{} @uref{#sec-15.2.3.12,15.2.3.12}@comma{} @uref{#sec-15.2.3.13,15.2.3.13}@comma{} @uref{#sec-15.2.3.14,15.2.3.14}@comma{} @uref{#sec-15.2.4.3,15.2.4.3}@comma{} @uref{#sec-15.3.4.2,15.3.4.2}@comma{} @uref{#sec-15.3.4.3,15.3.4.3}@comma{} @uref{#sec-15.3.4.4,15.3.4.4}@comma{} @uref{#sec-15.3.4.5,15.3.4.5}@comma{} @uref{#sec-15.3.4.5.2,15.3.4.5.2}@comma{} @uref{#sec-15.3.4.5.3,15.3.4.5.3}@comma{} @uref{#sec-15.3.5,15.3.5}@comma{} @uref{#sec-15.3.5.3,15.3.5.3}@comma{} @uref{#sec-15.3.5.4,15.3.5.4}@comma{} @uref{#sec-15.4.4.3,15.4.4.3}@comma{} @uref{#sec-15.4.4.11,15.4.4.11}@comma{} @uref{#sec-15.4.4.16,15.4.4.16}@comma{} @uref{#sec-15.4.4.17,15.4.4.17}@comma{} @uref{#sec-15.4.4.18,15.4.4.18}@comma{} @uref{#sec-15.4.4.19,15.4.4.19}@comma{} @uref{#sec-15.4.4.20,15.4.4.20}@comma{} @uref{#sec-15.4.4.21,15.4.4.21}@comma{} @uref{#sec-15.4.4.22,15.4.4.22}@comma{} @uref{#sec-15.4.5.1,15.4.5.1}@comma{} @uref{#sec-15.5.4.2,15.5.4.2}@comma{} @uref{#sec-15.5.4.3,15.5.4.3}@comma{} @uref{#sec-15.6.4.2,15.6.4.2}@comma{} @uref{#sec-15.6.4.3,15.6.4.3}@comma{} @uref{#sec-15.7.4,15.7.4}@comma{} @uref{#sec-15.7.4.2,15.7.4.2}@comma{} @uref{#sec-15.7.4.4,15.7.4.4}@comma{} @uref{#sec-15.9.5,15.9.5}@comma{} @uref{#sec-15.9.5.44,15.9.5.44}@comma{} @uref{#sec-15.10.4.1,15.10.4.1}@comma{} @uref{#sec-15.10.6,15.10.6}@comma{} @uref{#sec-15.11.4.4,15.11.4.4} and @uref{#sec-15.12.3,15.12.3}.


@node 151166 URIError
@chapter @uref{#sec-15.11.6.6,15.11.6.6} URIError
Indicates that one of the global URI handling functions was used in a way that is incompatible with its definition. @uref{#sec-15.1.3,See 15.1.3}.



@node 15117 NativeError Object Structure
@chapter @uref{#sec-15.11.7,15.11.7} NativeError Object Structure
When an ECMAScript implementation detects a runtime error@comma{} it throws an instance of one of the NativeError objects defined in @uref{#sec-15.11.6,15.11.6}. Each of these objects has the structure described below@comma{} differing only in the name used as the constructor name instead of NativeError@comma{} in the @code{name} property of the prototype object@comma{} and in the implementation-defined @code{message} property of the prototype object.

For each error object@comma{} references to NativeError in the definition should be replaced with the appropriate error object name from @uref{#sec-15.11.6,15.11.6}.


@node 151171 NativeError Constructors Called as Functions
@chapter @uref{#sec-15.11.7.1,15.11.7.1} NativeError Constructors Called as Functions
When a NativeError constructor is called as a function rather than as a constructor@comma{} it creates and initialises a new object. A call of the object as a function is equivalent to calling it as a constructor with the same arguments.


@node 151172 NativeError message
@chapter @uref{#sec-15.11.7.2,15.11.7.2} NativeError (message)
The [[Prototype]] internal property of the newly constructed object is set to the prototype object for this error constructor. The [[Class]] internal property of the newly constructed object is set to "Error". The [[Extensible]] internal property of the newly constructed object is set to true.

If the argument message is not undefined@comma{} the @code{message} own property of the newly constructed object is set to @uref{#sec-9.8,ToString}(message).


@node 151173 The NativeError Constructors
@chapter @uref{#sec-15.11.7.3,15.11.7.3} The NativeError Constructors
When a NativeError constructor is called as part of a @code{new} expression@comma{} it is a constructor: it initialises the newly created object.


@node 151174 New NativeError message
@chapter @uref{#sec-15.11.7.4,15.11.7.4} New NativeError (message)
The [[Prototype]] internal property of the newly constructed object is set to the prototype object for this NativeError constructor. The [[Class]] internal property of the newly constructed object is set to "Error". The [[Extensible]] internal property of the newly constructed object is set to true.

If the argument message is not undefined@comma{} the @code{message} property of the newly constructed object is set to @uref{#sec-9.8,ToString}(message).


@node 151175 Properties of the NativeError Constructors
@chapter @uref{#sec-15.11.7.5,15.11.7.5} Properties of the NativeError Constructors
The value of the [[Prototype]] internal property of a NativeError constructor is @uref{#sec-15.3.4,the Function prototype object (15.3.4)}.

Besides the internal properties and the @code{length} property (whose value is 1)@comma{} each NativeError constructor has the following property:


@node 151176 NativeErrorprototype
@chapter @uref{#sec-15.11.7.6,15.11.7.6} NativeError.prototype
The initial value of NativeError.prototype is a NativeError prototype object (@uref{#sec-15.11.7.7,15.11.7.7}). Each NativeError constructor has a separate prototype object.

This property has the attributes @{ [[Writable]]: false@comma{} [[Enumerable]]: false@comma{} [[Configurable]]: false @}.



@node 151177 Properties of the NativeError Prototype Objects
@chapter @uref{#sec-15.11.7.7,15.11.7.7} Properties of the NativeError Prototype Objects
Each NativeError prototype object is an Error object (its [[Class]] is "Error").

The value of the [[Prototype]] internal property of each NativeError prototype object is the standard built-in Error prototype object (@uref{#sec-15.11.4,15.11.4}).


@node 151178 NativeErrorprototypeconstructor
@chapter @uref{#sec-15.11.7.8,15.11.7.8} NativeError.prototype.constructor
The initial value of the @code{constructor} property of the prototype for a given NativeError constructor is the NativeError constructor function itself (@uref{#sec-15.11.7,15.11.7}).


@node 151179 NativeErrorprototypename
@chapter @uref{#sec-15.11.7.9,15.11.7.9} NativeError.prototype.name
The initial value of the @code{name} property of the prototype for a given NativeError constructor is the name of the constructor (the name used instead of NativeError).


@node 1511710 NativeErrorprototypemessage
@chapter @uref{#sec-15.11.7.10,15.11.7.10} NativeError.prototype.message
The initial value of the @code{message} property of the prototype for a given NativeError constructor is the empty String.

NOTE The prototypes for the NativeError constructors do not themselves provide a toString function@comma{} but instances of errors will inherit it from the Error prototype object.


@node 1511711 Properties of NativeError Instances
@chapter @uref{#sec-15.11.7.11,15.11.7.11} Properties of NativeError Instances
NativeError instances inherit properties from their NativeError prototype object and their [[Class]] internal property value is "Error". NativeError instances have no special properties.


@node 1512 The JSON Object
@chapter @uref{#sec-15.12,15.12} The JSON Object
The JSON object is a single object that contains two functions@comma{} parse and stringify@comma{} that are used to parse and construct JSON texts. The JSON Data Interchange Format is described in RFC 4627 <@uref{http://www.ietf.org/rfc/rfc4627.txt,http://www.ietf.org/rfc/rfc4627.txt}>. The JSON interchange format used in this specification is exactly that described by RFC 4627 with two exceptions:

@itemize
@item
The top level JSONText production of the ECMAScript JSON grammar may consist of any JSONValue rather than being restricted to being a JSONObject or a JSONArray as specified by RFC 4627.
@item
Conforming implementations of JSON.parse and JSON.stringify must support the exact interchange format described in this specification without any deletions or extensions to the format. This differs from RFC 4627 which permits a JSON parser to accept non-JSON forms and extensions.
@end itemize

The value of the [[Prototype]] internal property of the JSON object is the standard built-in Object prototype object (@uref{#sec-15.2.4,15.2.4}). The value of the [[Class]] internal property of the JSON object is "JSON". The value of the [[Extensible]] internal property of the JSON object is set to true.

The JSON object does not have a [[Construct]] internal property; it is not possible to use the JSON object as a constructor with the @code{new} operator.

The JSON object does not have a [[Call]] internal property; it is not possible to invoke the JSON object as a function.



@node 15121 The JSON Grammar
@chapter @uref{#sec-15.12.1,15.12.1} The JSON Grammar
JSON.stringify produces a String that conforms to the following JSON grammar. JSON.parse accepts a String that conforms to the JSON grammar.


@node 151211 The JSON Lexical Grammar
@chapter @uref{#sec-15.12.1.1,15.12.1.1} The JSON Lexical Grammar
JSON is similar to ECMAScript source text in that it consists of a sequence of characters conforming to the rules of SourceCharacter. The JSON Lexical Grammar defines the tokens that make up a JSON text similar to the manner that the ECMAScript lexical grammar defines the tokens of an ECMAScript source test. The JSON Lexical grammar only recognizes the white space character specified by the production JSONWhiteSpace. The JSON lexical grammar shares some productions with the ECMAScript lexical grammar. All nonterminal symbols of the grammar that do not begin with the characters “JSON” are defined by productions of the ECMAScript lexical grammar.

@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
JSONWhiteSpace ::
<TAB>
<CR>
<LF>
<SP>
JSONString ::
@code{"} JSONStringCharacters_opt_ @code{"}
JSONStringCharacters ::
JSONStringCharacter JSONStringCharacters_opt_
JSONStringCharacter ::
SourceCharacter but not double-quote @code{"} or backslash @code{\} or U+0000 thru U+001F
@code{\} JSONEscapeSequence
JSONEscapeSequence ::
JSONEscapeCharacter
UnicodeEscapeSequence
JSONEscapeCharacter :: one of
@code{"} @code{/} @code{\} @code{b} @code{f} @code{n} @code{r} @code{t}
JSONNumber ::
@code{-}_opt_ DecimalIntegerLiteral JSONFraction_opt_ ExponentPart_opt_
JSONFraction ::
@code{.} DecimalDigits
JSONNullLiteral ::
NullLiteral
JSONBooleanLiteral ::
BooleanLiteral

@node 151212 The JSON Syntactic Grammar
@chapter @uref{#sec-15.12.1.2,15.12.1.2} The JSON Syntactic Grammar
The JSON Syntactic Grammar defines a valid JSON text in terms of tokens defined by the JSON lexical grammar. The goal symbol of the grammar is JSONText.


@menu
* Syntax::
@end menu

@node Syntax
@section Syntax
JSONText :
JSONValue
JSONValue :
JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber
JSONObject :
@code{@{} @code{@}}
@code{@{} JSONMemberList @code{@}}
JSONMember :
JSONString @code{:} JSONValue
JSONMemberList :
JSONMember
JSONMemberList @code{@comma{}} JSONMember
JSONArray :
@code{[} @code{]}
@code{[} JSONElementList @code{]}
JSONElementList :
JSONValue
JSONElementList @code{@comma{}} JSONValue

@node 15122 parse  text [  reviver ]
@chapter @uref{#sec-15.12.2,15.12.2} parse ( text [ @comma{} reviver ] )
The parse function parses a JSON text (a JSON-formatted String) and produces an ECMAScript value. The JSON format is a restricted form of ECMAScript literal. JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript arrays. JSON strings@comma{} numbers@comma{} booleans@comma{} and null are realized as ECMAScript Strings@comma{} Numbers@comma{} Booleans@comma{} and null. JSON uses a more limited set of white space characters than WhiteSpace and allows Unicode code points U+2028 and U+2029 to directly appear in JSONString literals without using an escape sequence. The process of parsing is similar to @uref{#sec-11.1.4,11.1.4} and @uref{#sec-11.1.5,11.1.5} as constrained by the JSON grammar.

The optional reviver parameter is a function that takes two parameters@comma{} (key and value). It can filter and transform the results. It is called with each of the key/value pairs produced by the parse@comma{} and its return value is used instead of the original value. If it returns what it received@comma{} the structure is not modified. If it returns undefined then the property is deleted from the result.

@enumerate
@item
Let JText be @uref{#sec-9.8,ToString}(text).
@item
Parse JText using the grammars in @uref{#sec-15.12.1,15.12.1}. Throw a SyntaxError exception if JText did not conform to the JSON grammar for the goal symbol JSONText.
@item
Let unfiltered be the result of parsing and evaluating JText as if it was the source text of an ECMAScript Program but using JSONString in place of StringLiteral. Note that since JText conforms to the JSON grammar this result will be either a primitive value or an object that is defined by either an ArrayLiteral or an ObjectLiteral.
@item
If @uref{#sec-9.11,IsCallable}(reviver) is true@comma{} then
@enumerate
@item
Let root be a new object created as if by the expression @code{new Object()}@comma{} where @code{Object} is the standard built-in constructor with that name.
@item
Call the [[DefineOwnProperty]] internal method of root with the empty String@comma{} the PropertyDescriptor @{[[Value]]: unfiltered@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false as arguments.
@item
Return the result of calling the abstract operation Walk@comma{} passing root and the empty String. The abstract operation Walk is described below.
@end enumerate

@item
Else
@enumerate
@item
Return unfiltered.
@end enumerate

@end enumerate

The abstract operation Walk is a recursive abstract operation that takes two parameters: a holder object and the String name of a property in that object. Walk uses the value of reviver that was originally passed to the above parse function.

@enumerate
@item
Let val be the result of calling the [[Get]] internal method of holder with argument name.
@item
If val is an object@comma{} then
@enumerate
@item
If the [[Class]] internal property of val is "Array"
@enumerate
@item
Set I to 0.
@item
Let len be the result of calling the [[Get]] internal method of val with argument "length".
@item
Repeat while I < len@comma{}
@enumerate
@item
Let newElement be the result of calling the abstract operation Walk@comma{} passing val and @uref{#sec-9.8,ToString}(I).
@item
If newElement is undefined@comma{} then
@enumerate
@item
Call the [[Delete]] internal method of val with @uref{#sec-9.8,ToString}(I) and false as arguments.
@end enumerate

@item
Else
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of val with arguments @uref{#sec-9.8,ToString}(I)@comma{} the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: newElement@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@item
Add 1 to I.
@end enumerate

@end enumerate

@item
Else
@enumerate
@item
Let keys be an internal @uref{#sec-8.8,List} of String values consisting of the names of all the own properties of val whose [[Enumerable]] attribute is true. The ordering of the Strings should be the same as that used by the Object.keys standard built-in function.
@item
For each String P in keys do@comma{}
@enumerate
@item
Let newElement be the result of calling the abstract operation Walk@comma{} passing val and P.
@item
If newElement is undefined@comma{} then
@enumerate
@item
Call the [[Delete]] internal method of val with P and false as arguments.
@end enumerate

@item
Else
@enumerate
@item
Call the [[DefineOwnProperty]] internal method of val with arguments P@comma{} the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: newElement@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@end enumerate

@end enumerate

@end enumerate

@end enumerate

@item
Return the result of calling the [[Call]] internal method of reviver passing holder as the this value and with an argument list consisting of name and val.
@end enumerate

It is not permitted for a conforming implementation of JSON.parse to extend the JSON grammars. If an implementation wishes to support a modified or extended JSON interchange format it must do so by defining a different parse function.

NOTE In the case where there are duplicate name Strings within an object@comma{} lexically preceding values for the same key shall be overwritten.


@node 15123 stringify  value [  replacer [  space ] ]
@chapter @uref{#sec-15.12.3,15.12.3} stringify ( value [ @comma{} replacer [ @comma{} space ] ] )
The stringify function returns a String in JSON format representing an ECMAScript value. It can take three parameters. The first parameter is required. The value parameter is an ECMAScript value@comma{} which is usually an object or array@comma{} although it can also be a String@comma{} Boolean@comma{} Number or null. The optional replacer parameter is either a function that alters the way objects and arrays are stringified@comma{} or an array of Strings and Numbers that acts as a white list for selecting the object properties that will be stringified. The optional space parameter is a String or Number that allows the result to have white space injected into it to improve human readability.



@enumerate
@item
Let stack be an empty @uref{#sec-8.8,List}.
@item
Let indent be the empty String.
@item
Let PropertyList and ReplacerFunction be undefined.
@item
If @uref{#def-type,Type}(replacer) is Object@comma{} then
@enumerate
@item
If @uref{#sec-9.11,IsCallable}(replacer) is true@comma{} then
@enumerate
@item
Let ReplacerFunction be replacer.
@end enumerate

@item
Else if the [[Class]] internal property of replacer is "Array"@comma{} then
@enumerate
@item
Let PropertyList be an empty internal @uref{#sec-8.8,List}
@item
For each value v of a property of replacer that has an array index property name. The properties are enumerated in the ascending array index order of their names.
@enumerate
@item
Let item be undefined.
@item
If @uref{#def-type,Type}(v) is String then let item be v.
@item
Else if @uref{#def-type,Type}(v) is Number then let item be @uref{#sec-9.8,ToString}(v).
@item
Else if @uref{#def-type,Type}(v) is Object then@comma{}
@enumerate
@item
If the [[Class]] internal property of v is "String" or "Number" then let item be @uref{#sec-9.8,ToString}(v).
@end enumerate

@item
If item is not undefined and item is not currently an element of PropertyList then@comma{}
@enumerate
@item
Append item to the end of PropertyList.
@end enumerate

@end enumerate

@end enumerate

@end enumerate

@item
If @uref{#def-type,Type}(space) is Object then@comma{}
@enumerate
@item
If the [[Class]] internal property of space is "Number" then@comma{}
@enumerate
@item
Let space be @uref{#sec-9.3,ToNumber}(space).
@end enumerate

@item
Else if the [[Class]] internal property of space is "String" then@comma{}
@enumerate
@item
Let space be @uref{#sec-9.8,ToString}(space).
@end enumerate

@end enumerate

@item
If @uref{#def-type,Type}(space) is Number
@enumerate
@item
Let space be min(10@comma{} @uref{#sec-9.4,ToInteger}(space)).
@item
Set gap to a String containing space space characters. This will be the empty String if space is less than 1.
@end enumerate

@item
Else if @uref{#def-type,Type}(space) is String
@enumerate
@item
If the number of characters in space is 10 or less@comma{} set gap to space otherwise set gap to a String consisting of the first 10 characters of space.
@end enumerate

@item
Else
@enumerate
@item
Set gap to the empty String.
@end enumerate

@item
Let wrapper be a new object created as if by the expression @code{new Object()}@comma{} where @code{Object} is the standard built-in constructor with that name.
@item
Call the [[DefineOwnProperty]] internal method of wrapper with arguments the empty String@comma{} the @uref{#sec-8.10,Property Descriptor} @{[[Value]]: value@comma{} [[Writable]]: true@comma{} [[Enumerable]]: true@comma{} [[Configurable]]: true@}@comma{} and false.
@item
Return the result of calling the abstract operation Str with the empty String and wrapper.
@end enumerate

The abstract operation Str(key@comma{} holder) has access to ReplacerFunction from the invocation of the stringify method. Its algorithm is as follows:

@enumerate
@item
Let value be the result of calling the [[Get]] internal method of holder with argument key.
@item
If @uref{#def-type,Type}(value) is Object@comma{} then
@enumerate
@item
Let toJSON be the result of calling the [[Get]] internal method of value with argument "toJSON".
@item
If @uref{#sec-9.11,IsCallable}(toJSON) is true
@enumerate
@item
Let value be the result of calling the [[Call]] internal method of toJSON passing value as the this value and with an argument list consisting of key.
@end enumerate

@end enumerate

@item
If ReplacerFunction is not undefined@comma{} then
@enumerate
@item
Let value be the result of calling the [[Call]] internal method of ReplacerFunction passing holder as the this value and with an argument list consisting of key and value.
@end enumerate

@item
If @uref{#def-type,Type}(value) is Object then@comma{}
@enumerate
@item
If the [[Class]] internal property of value is "Number" then@comma{}
@enumerate
@item
Let value be @uref{#sec-9.3,ToNumber}(value).
@end enumerate

@item
Else if the [[Class]] internal property of value is "String" then@comma{}
@enumerate
@item
Let value be @uref{#sec-9.8,ToString}(value).
@end enumerate

@item
Else if the [[Class]] internal property of value is "Boolean" then@comma{}
@enumerate
@item
Let value be the value of the [[PrimitiveValue]] internal property of value.
@end enumerate

@end enumerate

@item
If value is null then return "null".
@item
If value is true then return "true".
@item
If value is false then return "false".
@item
If @uref{#def-type,Type}(value) is String@comma{} then return the result of calling the abstract operation Quote with argument value.
@item
If @uref{#def-type,Type}(value) is Number
@enumerate
@item
If value is finite then return @uref{#sec-9.8,ToString}(value).
@item
Else@comma{} return "null".
@end enumerate

@item
If @uref{#def-type,Type}(value) is Object@comma{} and @uref{#sec-9.11,IsCallable}(value) is false
@enumerate
@item
If the [[Class]] internal property of value is "Array" then
@enumerate
@item
Return the result of calling the abstract operation JA with argument value.
@end enumerate

@item
Else@comma{} return the result of calling the abstract operation JO with argument value.
@end enumerate

@item
Return undefined.
@end enumerate

The abstract operation Quote(value) wraps a String value in double quotes and escapes characters within it.

@enumerate
@item
Let product be the double quote character.
@item
For each character C in value
@enumerate
@item
If C is the double quote character or the backslash character
@enumerate
@item
Let product be the concatenation of product and the backslash character.
@item
Let product be the concatenation of product and C.
@end enumerate

@item
Else if C is backspace@comma{} formfeed@comma{} newline@comma{} carriage return@comma{} or tab
@enumerate
@item
Let product be the concatenation of product and the backslash character.
@item
Let abbrev be the character corresponding to the value of C as follows:
backspace
"b"
formfeed
"f"
newline
"n"
carriage return
"r"
tab
"t"
@item
Let product be the concatenation of product and abbrev.
@end enumerate

@item
Else if C is a control character having a code unit value less than the space character
@enumerate
@item
Let product be the concatenation of product and the backslash character.
@item
Let product be the concatenation of product and "u".
@item
Let hex be the result of converting the numeric code unit value of C to a String of four hexadecimal digits.
@item
Let product be the concatenation of product and hex.
@end enumerate

@item
Else
@enumerate
@item
Let product be the concatenation of product and C.
@end enumerate

@end enumerate

@item
Let product be the concatenation of product and the double quote character.
@item
Return product.
@end enumerate

The abstract operation JO(value) serializes an object. It has access to the stack@comma{} indent@comma{} gap@comma{} PropertyList@comma{} ReplacerFunction@comma{} and space of the invocation of the stringify method.

@enumerate
@item
If stack contains value then throw a TypeError exception because the structure is cyclical.
@item
Append value to stack.
@item
Let stepback be indent.
@item
Let indent be the concatenation of indent and gap.
@item
If PropertyList is not undefined@comma{} then
@enumerate
@item
Let K be PropertyList.
@end enumerate

@item
Else
@enumerate
@item
Let K be an internal @uref{#sec-8.8,List} of Strings consisting of the names of all the own properties of value whose [[Enumerable]] attribute is true. The ordering of the Strings should be the same as that used by the Object.keys standard built-in function.
@end enumerate

@item
Let partial be an empty @uref{#sec-8.8,List}.
@item
For each element P of K.
@enumerate
@item
Let strP be the result of calling the abstract operation Str with arguments P and value.
@item
If strP is not undefined
@enumerate
@item
Let member be the result of calling the abstract operation Quote with argument P.
@item
Let member be the concatenation of member and the colon character.
@item
If gap is not the empty String
@enumerate
@item

@end enumerate

@item
Let member be the concatenation of member and strP.
@item
Append member to partial.
@end enumerate

@end enumerate

@item
If partial is empty@comma{} then
@enumerate
@item
Let final be "@{@}".
@end enumerate

@item
Else
@enumerate
@item
If gap is the empty String
@enumerate
@item
Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with the comma character. A comma is not inserted either before the first String or after the last String.
@item
Let final be the result of concatenating "@{"@comma{} properties@comma{} and "@}".
@end enumerate

@item
Else gap is not the empty String
@enumerate
@item
Let separator be the result of concatenating the comma character@comma{} the line feed character@comma{} and indent.
@item
Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.
@item
Let final be the result of concatenating "@{"@comma{} the line feed character@comma{} indent@comma{} properties@comma{} the line feed character@comma{} stepback@comma{} and "@}".
@end enumerate

@end enumerate

@item
Remove the last element of stack.
@item
Let indent be stepback.
@item
Return final.
@end enumerate

The abstract operation JA(value) serializes an array. It has access to the stack@comma{} indent@comma{} gap@comma{} and space of the invocation of the stringify method. The representation of arrays includes only the elements between zero and @code{<var>array</var>.length - 1} inclusive. Named properties are excluded from the stringification. An array is stringified as an open left bracket@comma{} elements separated by comma@comma{} and a closing right bracket.

@enumerate
@item
If stack contains value then throw a TypeError exception because the structure is cyclical.
@item
Append value to stack.
@item
Let stepback be indent.
@item
Let indent be the concatenation of indent and gap.
@item
Let partial be an empty @uref{#sec-8.8,List}.
@item
Let len be the result of calling the [[Get]] internal method of value with argument "length".
@item
Let index be 0.
@item
Repeat while index < len
@enumerate
@item
Let strP be the result of calling the abstract operation Str with arguments @uref{#sec-9.8,ToString}(index) and value.
@item
If strP is undefined
@enumerate
@item
Append "null" to partial.
@end enumerate

@item
Else
@enumerate
@item
Append strP to partial.
@end enumerate

@item
Increment index by 1.
@end enumerate

@item
If partial is empty @comma{}then
@enumerate
@item
Let final be "[]".
@end enumerate

@item
Else
@enumerate
@item
If gap is the empty String
@enumerate
@item
Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with the comma character. A comma is not inserted either before the first String or after the last String.
@item
Let final be the result of concatenating "["@comma{} properties@comma{} and "]".
@end enumerate

@item
Else
@enumerate
@item
Let separator be the result of concatenating the comma character@comma{} the line feed character@comma{} and indent.
@item
Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.
@item
Let final be the result of concatenating "["@comma{} the line feed character@comma{} indent@comma{} properties@comma{} the line feed character@comma{} stepback@comma{} and "[".
@end enumerate

@end enumerate

@item
Remove the last element of stack.
@item

@item
Return final.
@end enumerate

NOTE 1 JSON structures are allowed to be nested to any depth@comma{} but they must be acyclic. If value is or contains a cyclic structure@comma{} then the stringify function must throw a TypeError exception. This is an example of a value that cannot be stringified:
@verbatim
a = [];
a[0] = a;
my_text = JSON.stringify(a); // This must throw an TypeError.
@end verbatim

NOTE 2 Symbolic primitive values are rendered as follows:

@itemize
@item
The null value is rendered in JSON text as the String null.
@item
The undefined value is not rendered.
@item
The true value is rendered in JSON text as the String true.
@item
The false value is rendered in JSON text as the String false.
@end itemize

NOTE 3 String values are wrapped in double quotes. The characters @code{"} and @code{\} are escaped with @code{\} prefixes. Control characters are replaced with escape sequences @code{\u<var>HHHH</var>}@comma{} or with the shorter forms@comma{} @code{\b} (backspace)@comma{} @code{\f} (formfeed)@comma{} @code{\n} (newline)@comma{} @code{\r} (carriage return)@comma{} @code{\t} (tab).

NOTE 4 Finite numbers are stringified as if by calling @uref{#sec-9.8,ToString}(number). NaN and Infinity regardless of sign are represented as the String null.

NOTE 5 Values that do not have a JSON representation (such as undefined and functions) do not produce a String. Instead they produce the undefined value. In arrays these values are represented as the String null. In objects an unrepresentable value causes the property to be excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero or more properties@comma{} separated with commas@comma{} closed with a right brace. A property is a quoted String representing the key or property name@comma{} a colon@comma{} and then the stringified property value. An array is rendered as an opening left bracket followed by zero or more values@comma{} separated with commas@comma{} closed with a right bracket.


@node 16 Errors
@chapter @uref{#sec-16,16} Errors
An implementation must report most errors at the time the relevant ECMAScript language construct is evaluated. An early error is an error that can be detected and reported prior to the evaluation of any construct in the Program containing the error. An implementation must report early errors in a Program prior to the first evaluation of that Program. Early errors in @uref{#def-eval-code,eval} code are reported at the time eval is called but prior to evaluation of any construct within the eval code. All errors that are not early errors are runtime errors.

An implementation must treat any instance of the following kinds of errors as an early error:

@itemize
@item
Any syntax error.
@item
Attempts to define an ObjectLiteral that has multiple @code{get} property assignments with the same name or multiple @code{set} property assignments with the same name.
@item
Attempts to define an ObjectLiteral that has both a data property assignment and a @code{get} or @code{set} property assignment with the same name.
@item
Errors in regular expression literals that are not implementation-defined syntax extensions.
@item
Attempts in @uref{#sec-10.1.1,strict mode code} to define an ObjectLiteral that has multiple data property assignments with the same name.
@item
The occurrence of a WithStatement in @uref{#sec-10.1.1,strict mode code}.
@item
The occurrence of an Identifier value appearing more than once within a FormalParameterList of an individual strict mode FunctionDeclaration or FunctionExpression.
@item
Improper uses of @code{return}@comma{} @code{break}@comma{} and @code{continue}.
@item
Attempts to call @uref{#sec-8.7.2,PutValue} on any value for which an early determination can be made that the value is not a @uref{#sec-8.7,Reference} (for example@comma{} executing the assignment statement @code{3=4}).
@end itemize



An implementation shall report all errors as specified@comma{} except for the following:

@itemize
@item
An implementation may extend program syntax and regular expression pattern or flag syntax. To permit this@comma{} all operations (such as calling eval@comma{} using a regular expression literal@comma{} or using the Function or RegExp constructor) that are allowed to throw SyntaxError are permitted to exhibit implementation-defined behaviour instead of throwing SyntaxError when they encounter an implementation-defined extension to the program syntax or regular expression pattern or flag syntax.

@item
An implementation may provide additional types@comma{} values@comma{} objects@comma{} properties@comma{} and functions beyond those described in this specification. This may cause constructs (such as looking up a variable in the global scope) to have implementation-defined behaviour instead of throwing an error (such as ReferenceError).

@item
An implementation may define behaviour other than throwing RangeError for toFixed@comma{} toExponential@comma{} and toPrecision when the fractionDigits or precision argument is outside the specified range.

@end itemize



@node Annex A informative Grammar Summary
@chapter Annex A (informative) Grammar Summary

@node A1 Lexical Grammar
@chapter @uref{#sec-A.1,A.1} Lexical Grammar
@uref{#sec-6,See clause 6}
SourceCharacter ::
any Unicode code unit
@uref{#sec-7,See clause 7}
InputElementDiv ::
WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
@uref{#sec-7,See clause 7}
InputElementRegExp ::
WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral
@uref{#sec-7.2,See 7.2}
WhiteSpace ::
<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>
@uref{#sec-7.3,See 7.3}
LineTerminator ::
<LF>
<CR>
<LS>
<PS>
@uref{#sec-7.3,See 7.3}
LineTerminatorSequence ::
<LF>
<CR> [@uref{#def-lookahead-notin,lookahead ∉} <LF>]
<LS>
<PS>
<CR> <LF>
@uref{#sec-7.4,See 7.4}
Comment ::
MultiLineComment
SingleLineComment

@uref{#sec-7.4,See 7.4}
MultiLineComment ::
@code{/*} MultiLineCommentChars_opt_ @code{*/}
@uref{#sec-7.4,See 7.4}
MultiLineCommentChars ::
MultiLineNotAsteriskChar MultiLineCommentChars_opt_
@code{*} PostAsteriskCommentChars_opt_
@uref{#sec-7.4,See 7.4}
PostAsteriskCommentChars ::
MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars_opt_
@code{*} PostAsteriskCommentChars_opt_
@uref{#sec-7.4,See 7.4}
MultiLineNotAsteriskChar ::
SourceCharacter but not asterisk @code{*}
@uref{#sec-7.4,See 7.4}
MultiLineNotForwardSlashOrAsteriskChar ::
SourceCharacter but not forward-slash @code{/} or asterisk @code{*}
@uref{#sec-7.4,See 7.4}
SingleLineComment ::
@code{//} SingleLineCommentChars_opt_
@uref{#sec-7.4,See 7.4}
SingleLineCommentChars ::
SingleLineCommentChar SingleLineCommentChars_opt_
@uref{#sec-7.4,See 7.4}
SingleLineCommentChar ::
SourceCharacter but not LineTerminator
@uref{#sec-7.5,See 7.5}
Token ::
IdentifierName
Punctuator
NumericLiteral
StringLiteral
@uref{#sec-7.6,See 7.6}
Identifier ::
IdentifierName but not ReservedWord
@uref{#sec-7.6,See 7.6}
IdentifierName ::
IdentifierStart
IdentifierName IdentifierPart
@uref{#sec-7.6,See 7.6}
IdentifierStart ::
UnicodeLetter
@code{$}
@code{_}
@code{\} UnicodeEscapeSequence

@uref{#sec-7.6,See 7.6}
IdentifierPart ::
IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>
@uref{#sec-7.6,See 7.6}
UnicodeLetter ::
any character in the Unicode categories “Uppercase letter (Lu)”@comma{} “Lowercase letter (Ll)”@comma{} “Titlecase letter (Lt)”@comma{} “Modifier letter (Lm)”@comma{} “Other letter (Lo)”@comma{} or “Letter number (Nl)”.
@uref{#sec-7.6,See 7.6}
UnicodeCombiningMark ::
any character in the Unicode categories “Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”
@uref{#sec-7.6,See 7.6}
UnicodeDigit ::
any character in the Unicode category “Decimal number (Nd)”
@uref{#sec-7.6,See 7.6}
UnicodeConnectorPunctuation ::
any character in the Unicode category “Connector punctuation (Pc)”
@uref{#sec-7.6.1,See 7.6.1}
ReservedWord ::
Keyword
FutureReservedWord
NullLiteral
BooleanLiteral
@uref{#sec-7.6.1.1,See 7.6.1.1}
Keyword :: one of
@code{break} @code{do} @code{instanceof} @code{typeof} @code{case} @code{else} @code{new} @code{var} @code{catch} @code{finally} @code{return} @code{void} @code{continue} @code{for} @code{switch} @code{while} @code{debugger} @code{function} @code{this} @code{with} @code{default} @code{if} @code{throw} @code{@ } @code{delete} @code{in} @code{try}
@uref{#sec-7.6.1.2,See 7.6.1.2}
FutureReservedWord :: one of
@code{class} @code{enum} @code{extends} @code{super} @code{const} @code{export} @code{import}
or in strict mode code one of
@code{implements} @code{let} @code{private} @code{public} @code{interface} @code{package} @code{protected} @code{static} @code{yield}

@uref{#sec-7.7,See 7.7}
Punctuator :: one of
@code{@{} @code{@}} @code{(} @code{)} @code{[} @code{]} @code{.} @code{;} @code{@comma{}} @code{<} @code{>} @code{<=} @code{>=} @code{==} @code{!=} @code{===} @code{!==} @code{+} @code{-} @code{*} @code{%} @code{++} @code{--} @code{<<} @code{>>} @code{>>>} @code{&} @code{|} @code{^} @code{!} @code{~} @code{&&} @code{||} @code{?} @code{:} @code{=} @code{+=} @code{-=} @code{*=} @code{%=} @code{<<=} @code{>>=} @code{>>>=} @code{&=} @code{|=} @code{^=}
@uref{#sec-7.7,See 7.7}
DivPunctuator :: one of
@code{/} @code{/=}
@uref{#sec-7.8,See 7.8}
Literal ::
NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral
@uref{#sec-7.8.1,See 7.8.1}
NullLiteral ::
@code{null}
@uref{#sec-7.8.2,See 7.8.2}
BooleanLiteral ::
@code{true}
@code{false}
@uref{#sec-7.8.3,See 7.8.3}
NumericLiteral ::
DecimalLiteral
HexIntegerLiteral
@uref{#sec-7.8.3,See 7.8.3}
DecimalLiteral ::
DecimalIntegerLiteral @code{.} DecimalDigits_opt_ ExponentPart_opt_
@code{.} DecimalDigits ExponentPart_opt_
DecimalIntegerLiteral ExponentPart_opt_
@uref{#sec-7.8.3,See 7.8.3}
DecimalIntegerLiteral ::
@code{0}
NonZeroDigit DecimalDigits_opt_
@uref{#sec-7.8.3,See 7.8.3}
DecimalDigits ::
DecimalDigit
DecimalDigits DecimalDigit
@uref{#sec-7.8.3,See 7.8.3}
DecimalDigit :: one of
@code{0  1  2  3  4  5  6  7  8  9}
@uref{#sec-7.8.3,See 7.8.3}
NonZeroDigit :: one of
@code{1  2  3  4  5  6  7  8  9}
@uref{#sec-7.8.3,See 7.8.3}
ExponentPart ::
ExponentIndicator SignedInteger

@uref{#sec-7.8.3,See 7.8.3}
ExponentIndicator :: one of
@code{e  E}
@uref{#sec-7.8.3,See 7.8.3}
SignedInteger ::
DecimalDigits
@code{+} DecimalDigits
@code{-} DecimalDigits
@uref{#sec-7.8.3,See 7.8.3}
HexIntegerLiteral ::
@code{0x} HexDigit
@code{0X} HexDigit
HexIntegerLiteral HexDigit
@uref{#sec-7.8.3,See 7.8.3}
HexDigit :: one of
@code{0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F}
@uref{#sec-7.8.4,See 7.8.4}
StringLiteral ::
@code{"} DoubleStringCharacters_opt_ @code{"}
@code{'} SingleStringCharacters_opt_ @code{'}
@uref{#sec-7.8.4,See 7.8.4}
DoubleStringCharacters ::
DoubleStringCharacter DoubleStringCharacters_opt_
@uref{#sec-7.8.4,See 7.8.4}
SingleStringCharacters ::
SingleStringCharacter SingleStringCharacters_opt_
@uref{#sec-7.8.4,See 7.8.4}
DoubleStringCharacter ::
SourceCharacter but not double-quote @code{"} or backslash @code{\} or LineTerminator
@code{\} EscapeSequence
LineContinuation
@uref{#sec-7.8.4,See 7.8.4}
SingleStringCharacter ::
SourceCharacter but not single-quote @code{?} or backslash @code{\} or LineTerminator
@code{\} EscapeSequence
LineContinuation
@uref{#sec-7.8.4,See 7.8.4}
LineContinuation ::
@code{\} LineTerminatorSequence
@uref{#sec-7.8.4,See 7.8.4}
EscapeSequence ::
CharacterEscapeSequence
@code{0} [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence
@uref{#sec-7.8.4,See 7.8.4}
CharacterEscapeSequence ::
SingleEscapeCharacter
NonEscapeCharacter
@uref{#sec-7.8.4,See 7.8.4}
SingleEscapeCharacter :: one of
@code{?  "  \  b  f  n  r  t  v}
@uref{#sec-7.8.4,See 7.8.4}
NonEscapeCharacter ::
SourceCharacter but not EscapeCharacter or LineTerminator

@uref{#sec-7.8.4,See 7.8.4}
EscapeCharacter ::
SingleEscapeCharacter
DecimalDigit
@code{x}
@code{u}
@uref{#sec-7.8.4,See 7.8.4}
HexEscapeSequence ::
@code{x} HexDigit HexDigit
@uref{#sec-7.8.4,See 7.8.4}
UnicodeEscapeSequence ::
@code{u} HexDigit HexDigit HexDigit HexDigit
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionLiteral ::
@code{/} RegularExpressionBody @code{/} RegularExpressionFlags
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionBody ::
RegularExpressionFirstChar RegularExpressionChars
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionChars ::
[empty]
RegularExpressionChars RegularExpressionChar
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionFirstChar ::
RegularExpressionNonTerminator but not @code{*} or @code{\} or @code{/} or @code{[}
RegularExpressionBackslashSequence
RegularExpressionClass
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionChar ::
RegularExpressionNonTerminator but not @code{\} or @code{/} or @code{[}
RegularExpressionBackslashSequence
RegularExpressionClass
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionBackslashSequence ::
@code{\} RegularExpressionNonTerminator
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionNonTerminator ::
SourceCharacter but not LineTerminator
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionClass ::
@code{[} RegularExpressionClassChars @code{]}
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionClassChars ::
[empty]
RegularExpressionClassChars RegularExpressionClassChar
@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionClassChar ::
RegularExpressionNonTerminator but not @code{]} or @code{\}
RegularExpressionBackslashSequence

@uref{#sec-7.8.5,See 7.8.5}
RegularExpressionFlags ::
[empty]
RegularExpressionFlags IdentifierPart

@node A2 Number Conversions
@chapter @uref{#sec-A.2,A.2} Number Conversions
@uref{#sec-9.3.1,See 9.3.1}
StringNumericLiteral :::
StrWhiteSpace_opt_
StrWhiteSpace_opt_ StrNumericLiteral StrWhiteSpace_opt_
@uref{#sec-9.3.1,See 9.3.1}
StrWhiteSpace :::
StrWhiteSpaceChar StrWhiteSpace_opt_
@uref{#sec-9.3.1,See 9.3.1}
StrWhiteSpaceChar :::
WhiteSpace
LineTerminator
@uref{#sec-9.3.1,See 9.3.1}
StrNumericLiteral :::
StrDecimalLiteral
HexIntegerLiteral
@uref{#sec-9.3.1,See 9.3.1}
StrDecimalLiteral :::
StrUnsignedDecimalLiteral
@code{+} StrUnsignedDecimalLiteral
@code{-} StrUnsignedDecimalLiteral
@uref{#sec-9.3.1,See 9.3.1}
StrUnsignedDecimalLiteral :::
@code{Infinity}
DecimalDigits @code{.} DecimalDigits_opt_ ExponentPart_opt_
@code{.} DecimalDigits ExponentPart_opt_
DecimalDigits ExponentPart_opt_
@uref{#sec-9.3.1,See 9.3.1}
DecimalDigits :::
DecimalDigit
DecimalDigits DecimalDigit
@uref{#sec-9.3.1,See 9.3.1}
DecimalDigit ::: one of
@code{0  1  2  3  4  5  6  7  8  9}
@uref{#sec-9.3.1,See 9.3.1}
ExponentPart :::
ExponentIndicator SignedInteger
@uref{#sec-9.3.1,See 9.3.1}
ExponentIndicator ::: one of
@code{e  E}
@uref{#sec-9.3.1,See 9.3.1}
SignedInteger :::
DecimalDigits
@code{+} DecimalDigits
@code{-} DecimalDigits

@uref{#sec-9.3.1,See 9.3.1}
HexIntegerLiteral :::
@code{0x} HexDigit
@code{0X} HexDigit
HexIntegerLiteral HexDigit
@uref{#sec-9.3.1,See 9.3.1}
HexDigit ::: one of
@code{0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F}

@node A3 Expressions
@chapter @uref{#sec-A.3,A.3} Expressions
@uref{#sec-11.1,See 11.1}
PrimaryExpression :
@code{this}
Identifier
Literal
ArrayLiteral
ObjectLiteral
@code{(} Expression @code{)}
@uref{#sec-11.1.4,See 11.1.4}
ArrayLiteral :
@code{[} Elision_opt_ @code{]}
@code{[} ElementList @code{]}
@code{[} ElementList @code{@comma{}} Elision_opt_ @code{]}
@uref{#sec-11.1.4,See 11.1.4}
ElementList :
Elision_opt_ AssignmentExpression
ElementList @code{@comma{}} Elision_opt_ AssignmentExpression
@uref{#sec-11.1.4,See 11.1.4}
Elision :
@code{@comma{}}
Elision @code{@comma{}}
@uref{#sec-11.1.5,See 11.1.5}
ObjectLiteral :
@code{@{} @code{@{}
@code{@{} PropertyNameAndValueList @code{@}}
@code{@{} PropertyNameAndValueList @code{@comma{}} @code{@}}
@uref{#sec-11.1.5,See 11.1.5}
PropertyNameAndValueList :
PropertyAssignment
PropertyNameAndValueList @code{@comma{}} PropertyAssignment
@uref{#sec-11.1.5,See 11.1.5}
PropertyAssignment :
PropertyName @code{:} AssignmentExpression
@code{get} PropertyName @code{(} @code{)} @code{@{} FunctionBody @code{@}}
@code{set} PropertyName @code{(} PropertySetParameterList @code{)} @code{@{} FunctionBody @code{@}}
@uref{#sec-11.1.5,See 11.1.5}
PropertyName :
IdentifierName
StringLiteral
NumericLiteral
@uref{#sec-11.1.5,See 11.1.5}
PropertySetParameterList :
Identifier

@uref{#sec-11.2,See 11.2}
MemberExpression :
PrimaryExpression
FunctionExpression
MemberExpression @code{[} Expression @code{]}
MemberExpression @code{.} IdentifierName
@code{new} MemberExpression Arguments
@uref{#sec-11.2,See 11.2}
NewExpression :
MemberExpression
@code{new} NewExpression
@uref{#sec-11.2,See 11.2}
CallExpression :
MemberExpression Arguments
CallExpression Arguments
CallExpression @code{[} Expression @code{]}
CallExpression @code{.} IdentifierName
@uref{#sec-11.2,See 11.2}
Arguments :
@code{(} @code{)}
@code{(} ArgumentList @code{)}
@uref{#sec-11.2,See 11.2}
ArgumentList :
AssignmentExpression
ArgumentList @code{@comma{}} AssignmentExpression
@uref{#sec-11.2,See 11.2}
LeftHandSideExpression :
NewExpression
CallExpression
@uref{#sec-11.3,See 11.3}
PostfixExpression :
LeftHandSideExpression
LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{++}
LeftHandSideExpression @uref{#def-restricted-production,[no LineTerminator here]} @code{--}
@uref{#sec-11.4,See 11.4}
UnaryExpression :
PostfixExpression
@code{delete} UnaryExpression
@code{void} UnaryExpression
@code{typeof} UnaryExpression
@code{++} UnaryExpression
@code{--} UnaryExpression
@code{+} UnaryExpression
@code{-} UnaryExpression
@code{~} UnaryExpression
@code{!} UnaryExpression
@uref{#sec-11.5,See 11.5}
MultiplicativeExpression :
UnaryExpression
MultiplicativeExpression @code{*} UnaryExpression
MultiplicativeExpression @code{/} UnaryExpression
MultiplicativeExpression @code{%} UnaryExpression

@uref{#sec-11.6,See 11.6}
AdditiveExpression :
MultiplicativeExpression
AdditiveExpression @code{+} MultiplicativeExpression
AdditiveExpression @code{-} MultiplicativeExpression
@uref{#sec-11.7,See 11.7}
ShiftExpression :
AdditiveExpression
ShiftExpression @code{<<} AdditiveExpression
ShiftExpression @code{>>} AdditiveExpression
ShiftExpression @code{>>>} AdditiveExpression
@uref{#sec-11.8,See 11.8}
RelationalExpression :
ShiftExpression
RelationalExpression @code{<} ShiftExpression
RelationalExpression @code{>} ShiftExpression
RelationalExpression @code{<=} ShiftExpression
RelationalExpression @code{>=} ShiftExpression
RelationalExpression @code{instanceof} ShiftExpression
RelationalExpression @code{in} ShiftExpression
@uref{#sec-11.8,See 11.8}
RelationalExpressionNoIn :
ShiftExpression
RelationalExpressionNoIn @code{<} ShiftExpression
RelationalExpressionNoIn @code{>} ShiftExpression
RelationalExpressionNoIn @code{<=} ShiftExpression
RelationalExpressionNoIn @code{>=} ShiftExpression
RelationalExpressionNoIn @code{instanceof} ShiftExpression
@uref{#sec-11.9,See 11.9}
EqualityExpression :
RelationalExpression
EqualityExpression @code{==} RelationalExpression
EqualityExpression @code{!=} RelationalExpression
EqualityExpression @code{===} RelationalExpression
EqualityExpression @code{!==} RelationalExpression
@uref{#sec-11.9,See 11.9}
EqualityExpressionNoIn :
RelationalExpressionNoIn
EqualityExpressionNoIn @code{==} RelationalExpressionNoIn
EqualityExpressionNoIn @code{!=} RelationalExpressionNoIn
EqualityExpressionNoIn @code{===} RelationalExpressionNoIn
EqualityExpressionNoIn @code{!==} RelationalExpressionNoIn
@uref{#sec-11.10,See 11.10}
BitwiseANDExpression :
EqualityExpression
BitwiseANDExpression @code{&} EqualityExpression
@uref{#sec-11.10,See 11.10}
BitwiseANDExpressionNoIn :
EqualityExpressionNoIn
BitwiseANDExpressionNoIn @code{&} EqualityExpressionNoIn

@uref{#sec-11.10,See 11.10}
BitwiseXORExpression :
BitwiseANDExpression
BitwiseXORExpression @code{^} BitwiseANDExpression
@uref{#sec-11.10,See 11.10}
BitwiseXORExpressionNoIn :
BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn @code{^} BitwiseANDExpressionNoIn
@uref{#sec-11.10,See 11.10}
BitwiseORExpression :
BitwiseXORExpression
BitwiseORExpression @code{|} BitwiseXORExpression
@uref{#sec-11.10,See 11.10}
BitwiseORExpressionNoIn :
BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn @code{|} BitwiseXORExpressionNoIn
@uref{#sec-11.11,See 11.11}
LogicalANDExpression :
BitwiseORExpression
LogicalANDExpression @code{&&} BitwiseORExpression
@uref{#sec-11.11,See 11.11}
LogicalANDExpressionNoIn :
BitwiseORExpressionNoIn
LogicalANDExpressionNoIn @code{&&} BitwiseORExpressionNoIn
@uref{#sec-11.11,See 11.11}
LogicalORExpression :
LogicalANDExpression
LogicalORExpression @code{||} LogicalANDExpression
@uref{#sec-11.11,See 11.11}
LogicalORExpressionNoIn :
LogicalANDExpressionNoIn
LogicalORExpressionNoIn @code{||} LogicalANDExpressionNoIn
@uref{#sec-11.12,See 11.12}
ConditionalExpression :
LogicalORExpression
LogicalORExpression @code{?} AssignmentExpression @code{:} AssignmentExpression
@uref{#sec-11.12,See 11.12}
ConditionalExpressionNoIn :
LogicalORExpressionNoIn
LogicalORExpressionNoIn @code{?} AssignmentExpressionNoIn @code{:} AssignmentExpressionNoIn
@uref{#sec-11.13,See 11.13}
AssignmentExpression :
ConditionalExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
@uref{#sec-11.13,See 11.13}
AssignmentExpressionNoIn :
ConditionalExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn
@uref{#sec-11.13,See 11.13}
AssignmentOperator : one of
@code{=    *=   /=   %=   +=   -=   <<=  >>=  >>>= &=   ^=    |=}

@uref{#sec-11.14,See 11.14}
Expression :
AssignmentExpression
Expression @code{@comma{}} AssignmentExpression
@uref{#sec-11.14,See 11.14}
ExpressionNoIn :
AssignmentExpressionNoIn
ExpressionNoIn @code{@comma{}} AssignmentExpressionNoIn

@node A4 Statements
@chapter @uref{#sec-A.4,A.4} Statements
@uref{#sec-12,See clause 12}
Statement :
Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement
@uref{#sec-12.1,See 12.1}
Block :
@code{@{} StatementList_opt_ @code{@}}
@uref{#sec-12.1,See 12.1}
StatementList :
Statement
StatementList Statement
@uref{#sec-12.2,See 12.2}
VariableStatement :
@code{var} VariableDeclarationList @code{;}
@uref{#sec-12.2,See 12.2}
VariableDeclarationList :
VariableDeclaration
VariableDeclarationList @code{@comma{}} VariableDeclaration
@uref{#sec-12.2,See 12.2}
VariableDeclarationListNoIn :
VariableDeclarationNoIn
VariableDeclarationListNoIn @code{@comma{}} VariableDeclarationNoIn
@uref{#sec-12.2,See 12.2}
VariableDeclaration :
Identifier Initialiser_opt_
@uref{#sec-12.2,See 12.2}
VariableDeclarationNoIn :
Identifier InitialiserNoIn_opt_

@uref{#sec-12.2,See 12.2}
Initialiser :
@code{=} AssignmentExpression
@uref{#sec-12.2,See 12.2}
InitialiserNoIn :
@code{=} AssignmentExpressionNoIn
@uref{#sec-12.3,See 12.3}
EmptyStatement :
@code{;}
@uref{#sec-12.4,See 12.4}
ExpressionStatement :
[@uref{#def-lookahead-notin,lookahead ∉} @{@code{@{}@comma{} @code{function}@}] Expression @code{;}
@uref{#sec-12.5,See 12.5}
IfStatement :
@code{if} @code{(} Expression @code{)} Statement @code{else} Statement
@code{if} @code{(} Expression @code{)} Statement
@uref{#sec-12.6,See 12.6}
IterationStatement :
@code{do} Statement @code{while} @code{(} Expression @code{);}
@code{while} @code{(} Expression @code{)} Statement
@code{for} @code{(} ExpressionNoIn_opt_ @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} @code{var} VariableDeclarationListNoIn @code{;} Expression_opt_ @code{;} Expression_opt_ @code{)} Statement
@code{for} @code{(} LeftHandSideExpression @code{in} Expression @code{)} Statement
@code{for} @code{(} @code{var} VariableDeclarationNoIn @code{in} Expression @code{)} Statement
@uref{#sec-12.7,See 12.7}
ContinueStatement :
@code{continue} @uref{#def-restricted-production,[no LineTerminator here]} Identifier_opt_ @code{;}
@uref{#sec-12.8,See 12.8}
BreakStatement :
@code{break} @uref{#def-restricted-production,[no LineTerminator here]} Identifier_opt_ @code{;}
@uref{#sec-12.9,See 12.9}
ReturnStatement :
@code{return} @uref{#def-restricted-production,[no LineTerminator here]} Expression_opt_ @code{;}
@uref{#sec-12.10,See 12.10}
WithStatement :
@code{with} @code{(} Expression @code{)} Statement
@uref{#sec-12.11,See 12.11}
SwitchStatement :
@code{switch} @code{(} Expression @code{)} CaseBlock
@uref{#sec-12.11,See 12.11}
CaseBlock :
@code{@{} CaseClauses_opt_ @code{@}}
@code{@{} CaseClauses_opt_ DefaultClause CaseClauses_opt_ @code{@}}
@uref{#sec-12.11,See 12.11}
CaseClauses :
CaseClause
CaseClauses CaseClause

@uref{#sec-12.11,See 12.11}
CaseClause :
@code{case} Expression @code{:} StatementList_opt_
@uref{#sec-12.11,See 12.11}
DefaultClause :
@code{default} @code{:} StatementList_opt_
@uref{#sec-12.12,See 12.12}
LabelledStatement :
Identifier @code{:} Statement
@uref{#sec-12.13,See 12.13}
ThrowStatement :
@code{throw} @uref{#def-restricted-production,[no LineTerminator here]} Expression @code{;}
@uref{#sec-12.14,See 12.14}
TryStatement :
@code{try} Block Catch
@code{try} Block Finally
@code{try} Block Catch Finally
@uref{#sec-12.14,See 12.14}
Catch :
@code{catch} @code{(} Identifier @code{)} Block
@uref{#sec-12.14,See 12.14}
Finally :
@code{finally} Block
@uref{#sec-12.15,See 12.15}
DebuggerStatement :
@code{debugger} @code{;}

@node A5 Functions and Programs
@chapter @uref{#sec-A.5,A.5} Functions and Programs
@uref{#sec-13,See clause 13}
FunctionDeclaration :
@code{function} Identifier @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}}
@uref{#sec-13,See clause 13}
FunctionExpression :
@code{function} Identifier_opt_ @code{(} FormalParameterList_opt_ @code{)} @code{@{} FunctionBody @code{@}}
@uref{#sec-13,See clause 13}
FormalParameterList :
Identifier
FormalParameterList @code{@comma{}} Identifier
@uref{#sec-13,See clause 13}
FunctionBody :
SourceElements_opt_
@uref{#sec-14,See clause 14}
Program :
SourceElements_opt_
@uref{#sec-14,See clause 14}
SourceElements :
SourceElement
SourceElements SourceElement

@uref{#sec-14,See clause 14}
SourceElement :
Statement
FunctionDeclaration

@node A6 Universal Resource Identifier Character Classes
@chapter @uref{#sec-A.6,A.6} Universal Resource Identifier Character Classes
@uref{#sec-15.1.3,See 15.1.3}
uri :::
uriCharacters_opt_
@uref{#sec-15.1.3,See 15.1.3}
uriCharacters :::
uriCharacter uriCharacters_opt_
@uref{#sec-15.1.3,See 15.1.3}
uriCharacter :::
uriReserved
uriUnescaped
uriEscaped
@uref{#sec-15.1.3,See 15.1.3}
uriReserved ::: one of
@code{;  /  ?  :  @@  &  =  +  $  @comma{}}
@uref{#sec-15.1.3,See 15.1.3}
uriUnescaped :::
uriAlpha
DecimalDigit
uriMark
@uref{#sec-15.1.3,See 15.1.3}
uriEscaped :::
@code{%} HexDigit HexDigit
@uref{#sec-15.1.3,See 15.1.3}
uriAlpha ::: one of
@code{a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z}
@code{A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z}
@uref{#sec-15.1.3,See 15.1.3}
uriMark ::: one of
@code{-  _  .  !  ~  *  `  (  )}

@node A7 Regular Expressions
@chapter @uref{#sec-A.7,A.7} Regular Expressions
@uref{#sec-15.10.1,See 15.10.1}
Pattern ::
Disjunction
@uref{#sec-15.10.1,See 15.10.1}
Disjunction ::
Alternative
Alternative @code{|} Disjunction
@uref{#sec-15.10.1,See 15.10.1}
Alternative ::
[empty]
Alternative Term

@uref{#sec-15.10.1,See 15.10.1}
Term ::
Assertion
Atom
Atom Quantifier
@uref{#sec-15.10.1,See 15.10.1}
Assertion ::
@code{^}
@code{$}
@code{\} @code{b}
@code{\} @code{B}
@code{(} @code{?} @code{=} Disjunction @code{)}
@code{(} @code{?} @code{!} Disjunction @code{)}
@uref{#sec-15.10.1,See 15.10.1}
Quantifier ::
QuantifierPrefix
QuantifierPrefix @code{?}
@uref{#sec-15.10.1,See 15.10.1}
QuantifierPrefix ::
@code{*}
@code{+}
@code{?}
@code{@{} DecimalDigits @code{@}}
@code{@{} DecimalDigits @code{@comma{}} @code{@}}
@code{@{} DecimalDigits @code{@comma{}} DecimalDigits @code{@}}
@uref{#sec-15.10.1,See 15.10.1}
Atom ::
PatternCharacter
@code{.}
@code{\} AtomEscape
CharacterClass
@code{(} Disjunction @code{)}
@code{(} @code{?} @code{:} Disjunction @code{)}
@uref{#sec-15.10.1,See 15.10.1}
PatternCharacter :: SourceCharacter but not any of:
@code{^  $  \  .  *  +  ?  (  )  [  ]  @{  @}  |}
@uref{#sec-15.10.1,See 15.10.1}
AtomEscape ::
DecimalEscape
CharacterEscape
CharacterClassEscape
@uref{#sec-15.10.1,See 15.10.1}
CharacterEscape ::
ControlEscape
@code{c} ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape
@uref{#sec-15.10.1,See 15.10.1}
ControlEscape :: one of
@code{f  n  r  t  v}

@uref{#sec-15.10.1,See 15.10.1}
ControlLetter :: one of
@code{a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z}
@code{A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z}
@uref{#sec-15.10.1,See 15.10.1}
IdentityEscape ::
SourceCharacter but not IdentifierPart
<ZWJ>
<ZWNJ>
@uref{#sec-15.10.1,See 15.10.1}
DecimalEscape ::
DecimalIntegerLiteral [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit]
@uref{#sec-15.10.1,See 15.10.1}
CharacterClassEscape :: one of
@code{d  D  s  S  w  W}
@uref{#sec-15.10.1,See 15.10.1}
CharacterClass ::
@code{[} [@uref{#def-lookahead-notin,lookahead ∉} @{@code{^}@}] ClassRanges @code{]}
@code{[} @code{^} ClassRanges @code{]}
@uref{#sec-15.10.1,See 15.10.1}
ClassRanges ::
[empty]
NonemptyClassRanges
@uref{#sec-15.10.1,See 15.10.1}
NonemptyClassRanges ::
ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom @code{-} ClassAtom ClassRanges
@uref{#sec-15.10.1,See 15.10.1}
NonemptyClassRangesNoDash ::
ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash @code{-} ClassAtom ClassRanges
@uref{#sec-15.10.1,See 15.10.1}
ClassAtom ::
@code{-}
ClassAtomNoDash
@uref{#sec-15.10.1,See 15.10.1}
ClassAtomNoDash ::
SourceCharacter but not one of @code{\} or @code{]} or @code{-}
@code{\} ClassEscape
@uref{#sec-15.10.1,See 15.10.1}
ClassEscape ::
DecimalEscape
@code{b}
CharacterEscape
CharacterClassEscape


@node A8 JSON
@chapter @uref{#sec-A.8,A.8} JSON

@node A81 JSON Lexical Grammar
@chapter @uref{#sec-A.8.1,A.8.1} JSON Lexical Grammar
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONWhiteSpace ::
<TAB>
<CR>
<LF>
<SP>
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONString ::
@code{"} JSONStringCharacters_opt_ @code{"}
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONStringCharacters ::
JSONStringCharacter JSONStringCharacters_opt_
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONStringCharacter ::
SourceCharacter but not double-quote @code{"} or backslash @code{\} or U+0000 thru U+001F
@code{\} JSONEscapeSequence
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONEscapeSequence ::
JSONEscapeCharacter
UnicodeEscapeSequence
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONEscapeCharacter :: one of
@code{" / \ b f n r t}
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONNumber ::
@code{-}_opt_ DecimalIntegerLiteral JSONFraction_opt_ ExponentPart_opt_
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONFraction ::
@code{.} DecimalDigits
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONNullLiteral ::
NullLiteral
@uref{#sec-15.12.1.1,See 15.12.1.1}
JSONBooleanLiteral ::
BooleanLiteral

@node A82 JSON Syntactic Grammar
@chapter @uref{#sec-A.8.2,A.8.2} JSON Syntactic Grammar
@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONText :
JSONValue
@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONValue :
JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber
@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONObject :
@code{@{} @code{@}}
@code{@{} JSONMemberList @code{@}}
@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONMember :
JSONString @code{:} JSONValue

@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONMemberList :
JSONMember
JSONMemberList @code{@comma{}} JSONMember
@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONArray :
@code{[} @code{]}
@code{[} JSONElementList @code{]}
@uref{#sec-15.12.1.2,See 15.12.1.2}
JSONElementList :
JSONValue
JSONElementList @code{@comma{}} JSONValue



@node Annex B informative Compatibility
@chapter Annex B (informative) Compatibility

@node B1 Additional Syntax
@chapter @uref{#sec-B.1,B.1} Additional Syntax
Past editions of ECMAScript have included additional syntax and semantics for specifying octal literals and octal escape sequences. These have been removed from this edition of ECMAScript. This non-normative annex presents uniform syntax and semantics for octal literals and octal escape sequences for compatibility with some older ECMAScript programs.


@node B11 Numeric Literals
@chapter @uref{#sec-B.1.1,B.1.1} Numeric Literals
The syntax and semantics of @uref{#sec-7.8.3,7.8.3} can be extended as follows except that this extension is not allowed for @uref{#sec-10.1.1,strict mode code}:

@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
NumericLiteral ::
DecimalLiteral
HexIntegerLiteral
OctalIntegerLiteral
OctalIntegerLiteral ::
@code{0} OctalDigit
OctalIntegerLiteral OctalDigit
OctalDigit :: one of
@code{0  1  2  3  4  5  6  7}

@node Semantics
@section Semantics
@itemize
@item
The MV of NumericLiteral :: OctalIntegerLiteral is the MV of OctalIntegerLiteral.
@item
The MV of OctalDigit :: @code{0} is 0.
@item
The MV of OctalDigit :: @code{1} is 1.
@item
The MV of OctalDigit :: @code{2} is 2.
@item
The MV of OctalDigit :: @code{3} is 3.
@item
The MV of OctalDigit :: @code{4} is 4.
@item
The MV of OctalDigit :: @code{5} is 5.
@item
The MV of OctalDigit :: @code{6} is 6.
@item
The MV of OctalDigit :: @code{7} is 7.
@item
The MV of OctalIntegerLiteral :: @code{0} OctalDigit is the MV of OctalDigit.
@item
The MV of OctalIntegerLiteral :: OctalIntegerLiteral OctalDigit is (the MV of OctalIntegerLiteral times 8) plus the MV of OctalDigit.
@end itemize


@node B12 String Literals
@chapter @uref{#sec-B.1.2,B.1.2} String Literals
The syntax and semantics of @uref{#sec-7.8.4,7.8.4} can be extended as follows except that this extension is not allowed for @uref{#sec-10.1.1,strict mode code}:


@menu
* Syntax::
* Semantics::
@end menu

@node Syntax
@section Syntax
EscapeSequence ::
CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence
OctalEscapeSequence ::
OctalDigit [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit]
ZeroToThree OctalDigit [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit
ZeroToThree :: one of
@code{0} @code{1} @code{2} @code{3}
FourToSeven :: one of
@code{4} @code{5} @code{6} @code{7}

@node Semantics
@section Semantics
@itemize
@item
The CV of EscapeSequence :: OctalEscapeSequence is the CV of the OctalEscapeSequence.
@item
The CV of OctalEscapeSequence :: OctalDigit [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit] is the character whose code unit value is the MV of the OctalDigit.
@item
The CV of OctalEscapeSequence :: ZeroToThree OctalDigit [@uref{#def-lookahead-notin,lookahead ∉} DecimalDigit] is the character whose code unit value is (8 times the MV of the ZeroToThree) plus the MV of the OctalDigit.
@item
The CV of OctalEscapeSequence :: FourToSeven OctalDigit is the character whose code unit value is (8 times the MV of the FourToSeven) plus the MV of the OctalDigit.
@item
The CV of OctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit is the character whose code unit value is (64 (that is@comma{} 82) times the MV of the ZeroToThree) plus (8 times the MV of the first OctalDigit) plus the MV of the second OctalDigit.
@item
The MV of ZeroToThree :: @code{0} is 0.
@item
The MV of ZeroToThree :: @code{1} is 1.
@item
The MV of ZeroToThree :: @code{2} is 2.
@item
The MV of ZeroToThree :: @code{3} is 3.
@item
The MV of FourToSeven :: @code{4} is 4.
@item
The MV of FourToSeven :: @code{5} is 5.
@item
The MV of FourToSeven :: @code{6} is 6.
@item
The MV of FourToSeven :: @code{7} is 7.
@end itemize


@node B2 Additional Properties
@chapter @uref{#sec-B.2,B.2} Additional Properties
Some implementations of ECMAScript have included additional properties for some of the standard native objects. This non-normative annex suggests uniform semantics for such properties without making the properties or their semantics part of this standard.


@node B21 escape string
@chapter @uref{#sec-B.2.1,B.2.1} escape (string)
The escape function is a property of the global object. It computes a new version of a String value in which certain characters have been replaced by a hexadecimal escape sequence.

For those characters being replaced whose code unit value is @code{0xFF} or less@comma{} a two-digit escape sequence of the form @code{%<var>xx</var>} is used. For those characters being replaced whose code unit value is greater than @code{0xFF}@comma{} a four-digit escape sequence of the form @code{%u<var>xxxx</var>} is used.



@enumerate
@item
Call @uref{#sec-9.8,ToString}(string).
@item
Compute the number of characters in @uref{#def-Result,Result}(1).
@item
Let R be the empty string.
@item
Let k be 0.
@item
If k equals @uref{#def-Result,Result}(2)@comma{} return R.
@item
Get the character (represented as a 16-bit unsigned integer) at position k within @uref{#def-Result,Result}(1).
@item
If @uref{#def-Result,Result}(6) is one of the 69 nonblank characters “@code{ABCDEFGHIJKLMNOPQRSTUVWXYZ<wbr />abcdefghijklmnopqrstuvwxyz<wbr />0123456789@@*_+-./}” then go to step 13.
@item
If @uref{#def-Result,Result}(6)@comma{} is less than 256@comma{} go to step 11.
@item
Let S be a String containing six characters "%uwxyz" where wxyz are four hexadecimal digits encoding the value of @uref{#def-Result,Result}(6).
@item
Go to step 14.
@item
Let S be a String containing three characters "%xy" where xy are two hexadecimal digits encoding the value of @uref{#def-Result,Result}(6).
@item
Go to step 14.
@item
Let S be a String containing the single character @uref{#def-Result,Result}(6).
@item
Let R be a new String value computed by concatenating the previous value of R and S.
@item
Increase k by 1.
@item
Go to step 5.
@end enumerate

NOTE The encoding is partly based on the encoding described in RFC 1738@comma{} but the entire encoding specified in this standard is described above without regard to the contents of RFC 1738.


@node B22 unescape string
@chapter @uref{#sec-B.2.2,B.2.2} unescape (string)
The unescape function is a property of the global object. It computes a new version of a String value in which each escape sequence of the sort that might be introduced by the @uref{#sec-B.2.1,escape} function is replaced with the character that it represents.

When the unescape function is called with one argument string@comma{} the following steps are taken:

@enumerate
@item
Call @uref{#sec-9.8,ToString}(string).
@item
Compute the number of characters in @uref{#def-Result,Result}(1).
@item
Let R be the empty String.
@item
Let k be 0.
@item
If k equals @uref{#def-Result,Result}(2)@comma{} return R.
@item
Let c be the character at position k within @uref{#def-Result,Result}(1).
@item
If c is not @code{%}@comma{} go to step 18.
@item
If k is greater than @uref{#def-Result,Result}(2)−6@comma{} go to step 14.
@item
If the character at position k+1 within @uref{#def-Result,Result}(1) is not @code{u}@comma{} go to step 14.
@item
If the four characters at positions k+2@comma{} k+3@comma{} k+4@comma{} and k+5 within @uref{#def-Result,Result}(1) are not all hexadecimal digits@comma{} go to step 14.
@item
Let c be the character whose code unit value is the integer represented by the four hexadecimal digits at positions k+2@comma{} k+3@comma{} k+4@comma{} and k+5 within @uref{#def-Result,Result}(1).
@item
Increase k by 5.
@item
Go to step 18.
@item
If k is greater than @uref{#def-Result,Result}(2)−3@comma{} go to step 18.
@item
If the two characters at positions k+1 and k+2 within @uref{#def-Result,Result}(1) are not both hexadecimal digits@comma{} go to step 18.
@item
Let c be the character whose code unit value is the integer represented by two zeroes plus the two hexadecimal digits at positions k+1 and k+2 within @uref{#def-Result,Result}(1).
@item
Increase k by 2.
@item
Let R be a new String value computed by concatenating the previous value of R and c.
@item
Increase k by 1.
@item
Go to step 5.
@end enumerate



@node B23 Stringprototypesubstr start length
@chapter @uref{#sec-B.2.3,B.2.3} String.prototype.substr (start@comma{} length)
The substr method takes two arguments@comma{} start and length@comma{} and returns a substring of the result of converting the this object to a String@comma{} starting from character position start and running for length characters (or through the end of the String if length is undefined). If start is negative@comma{} it is treated as (sourceLength+start) where sourceLength is the length of the String. The result is a String value@comma{} not a String object. The following steps are taken:

@enumerate
@item
Call @uref{#sec-9.8,ToString}@comma{} giving it the this value as its argument.
@item
Call @uref{#sec-9.4,ToInteger}(start).
@item
If length is undefined@comma{} use +∞; otherwise call @uref{#sec-9.4,ToInteger}(length).
@item
Compute the number of characters in @uref{#def-Result,Result}(1).
@item
If @uref{#def-Result,Result}(2) is positive or zero@comma{} use @uref{#def-Result,Result}(2); else use max(@uref{#def-Result,Result}(4)+@uref{#def-Result,Result}(2)@comma{}0).
@item
Compute min(max(@uref{#def-Result,Result}(3)@comma{}0)@comma{} @uref{#def-Result,Result}(4)−@uref{#def-Result,Result}(5)).
@item
If @uref{#def-Result,Result}(6) ≤ 0@comma{} return the empty String "".
@item
Return a String containing @uref{#def-Result,Result}(6) consecutive characters from @uref{#def-Result,Result}(1) beginning with the character at position @uref{#def-Result,Result}(5).
@end enumerate

The @code{length} property of the substr method is 2.

NOTE The substr function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.


@node B24 DateprototypegetYear
@chapter @uref{#sec-B.2.4,B.2.4} Date.prototype.getYear ( )
NOTE The @uref{#sec-15.9.5.10,getFullYear} method is preferred for nearly all purposes@comma{} because it avoids the “year 2000 problem.”

When the getYear method is called with no arguments@comma{} the following steps are taken:

@enumerate
@item
Let t be @uref{#def-this-time-value,this time value}.
@item
If t is NaN@comma{} return NaN.
@item
Return @uref{#sec-15.9.1.3,YearFromTime}(@uref{#sec-15.9.1.9,LocalTime}(t)) − 1900.
@end enumerate


@node B25 DateprototypesetYear year
@chapter @uref{#sec-B.2.5,B.2.5} Date.prototype.setYear (year)
NOTE The @uref{#sec-15.9.5.40,setFullYear} method is preferred for nearly all purposes@comma{} because it avoids the “year 2000 problem.”

When the setYear method is called with one argument year@comma{} the following steps are taken:

@enumerate
@item
Let t be the result of @uref{#sec-15.9.1.9,LocalTime}(@uref{#def-this-time-value,this time value}); but if @uref{#def-this-time-value,this time value} is NaN@comma{} let t be +0.
@item
Call @uref{#sec-9.3,ToNumber}(year).
@item
If @uref{#def-Result,Result}(2) is NaN@comma{} set the [[PrimitiveValue]] internal property of the this value to NaN and return NaN.
@item
If @uref{#def-Result,Result}(2) is not NaN and 0 ≤ @uref{#sec-9.4,ToInteger}(@uref{#def-Result,Result}(2)) ≤ 99 then @uref{#def-Result,Result}(4) is @uref{#sec-9.4,ToInteger}(@uref{#def-Result,Result}(2)) + 1900. Otherwise@comma{} @uref{#def-Result,Result}(4) is @uref{#def-Result,Result}(2).
@item
Compute @uref{#sec-15.9.1.12,MakeDay}(@uref{#def-Result,Result}(4)@comma{} @uref{#sec-15.9.1.4,MonthFromTime}(t)@comma{} @uref{#sec-15.9.1.5,DateFromTime}(t)).
@item
Compute @uref{#sec-15.9.1.9,UTC}(@uref{#sec-15.9.1.13,MakeDate}(@uref{#def-Result,Result}(5)@comma{} @uref{#sec-15.9.1.2,TimeWithinDay}(t))).
@item
Set the [[PrimitiveValue]] internal property of the this value to @uref{#sec-15.9.1.14,TimeClip}(@uref{#def-Result,Result}(6)).
@item
Return the value of the [[PrimitiveValue]] internal property of the this value.
@end enumerate


@node B26 DateprototypetoGMTString
@chapter @uref{#sec-B.2.6,B.2.6} Date.prototype.toGMTString ( )
NOTE The property @code{toUTCString} is preferred. The @code{toGMTString} property is provided principally for compatibility with old code. It is recommended that the @code{toUTCString} property be used in new ECMAScript code.

The Function object that is the initial value of Date.prototype.toGMTString is the same Function object that is the initial value of @uref{#sec-15.9.5.42,Date.prototype.toUTCString}.



@node Annex C informative The Strict Mode of ECMAScript
@chapter Annex C (informative) The Strict Mode of ECMAScript
@menu
* The strict mode restriction and exceptions::
@end menu

@node The strict mode restriction and exceptions
@section The strict mode restriction and exceptions
@itemize
@item
The identifiers "implements"@comma{} "interface"@comma{} "let"@comma{} "package"@comma{} "private"@comma{} "protected"@comma{} "public"@comma{} "static"@comma{} and "yield" are classified as FutureReservedWord tokens within strict mode code. (7.6.12).

@item
A conforming implementation@comma{} when processing @uref{#sec-10.1.1,strict mode code}@comma{} may not extend the syntax of NumericLiteral (@uref{#sec-7.8.3,7.8.3}) to include OctalIntegerLiteral as described in @uref{#sec-B.1.1,B.1.1}.

@item
A conforming implementation@comma{} when processing @uref{#sec-10.1.1,strict mode code (see 10.1.1)}@comma{} may not extend the syntax of EscapeSequence to include OctalEscapeSequence as described in @uref{#sec-B.1.2,B.1.2}.

@item
Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within @uref{#sec-10.1.1,strict mode code}@comma{} its LeftHandSide must not evaluate to an @uref{#def-IsUnresolvableReference,unresolvable Reference}. If it does a ReferenceError exception is thrown (@uref{#sec-8.7.2,8.7.2}). The LeftHandSide also may not be a reference to a data property with the attribute value @{[[Writable]]:false@}@comma{} to an accessor property with the attribute value @{[[Set]]:undefined@}@comma{} nor to a non-existent property of an object whose [[Extensible]] internal property has the value false. In these cases a TypeError exception is thrown (@uref{#sec-11.13.1,11.13.1}).

@item
The identifier @code{eval} or @code{arguments} may not appear as the LeftHandSideExpression of an Assignment operator (@uref{#sec-11.13,11.13}) or of a PostfixExpression (@uref{#sec-11.3,11.3}) or as the UnaryExpression operated upon by a Prefix Increment (@uref{#sec-11.4.4,11.4.4}) or a Prefix Decrement (@uref{#sec-11.4.5,11.4.5}) operator.

@item
Arguments objects for strict mode functions define non-configurable accessor properties named “@code{caller}” and “@code{callee}” which throw a TypeError exception on access (@uref{#sec-10.6,10.6}).

@item
Arguments objects for strict mode functions do not dynamically share their array indexed property values with the corresponding formal parameter bindings of their functions. (@uref{#sec-10.6,10.6}).

@item
For strict mode functions@comma{} if an arguments object is created the binding of the local identifier @code{arguments} to the arguments object is immutable and hence may not be the target of an assignment expression. (@uref{#sec-10.5,10.5}).

@item
It is a SyntaxError if @uref{#sec-10.1.1,strict mode code} contains an ObjectLiteral with more than one definition of any data property (@uref{#sec-11.1.5,11.1.5}).

@item
It is a SyntaxError if the Identifier “@code{eval}” or the Identifier “@code{arguments}” occurs as the Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in @uref{#sec-10.1.1,strict code} or if its FunctionBody is @uref{#sec-10.1.1,strict code} (@uref{#sec-11.1.5,11.1.5}).

@item
Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead@comma{} a new variable environment is created and that environment is used for declaration binding instantiation for the @uref{#def-eval-code,eval code} (@uref{#sec-10.4.2,10.4.2}).

@item
If @code{this} is evaluated within @uref{#sec-10.1.1,strict mode code}@comma{} then the this value is not coerced to an object. A this value of null or undefined is not converted to the global object and primitive values are not converted to wrapper objects. The this value passed via a function call (including calls made using Function.prototype.apply and Function.prototype.call) do not coerce the passed this value to an object (@uref{#sec-10.4.3,10.4.3}@comma{} @uref{#sec-11.1.1,11.1.1}@comma{} @uref{#sec-15.3.4.3,15.3.4.3}@comma{} @uref{#sec-15.3.4.4,15.3.4.4}).

@item
When a @code{delete} operator occurs within @uref{#sec-10.1.1,strict mode code}@comma{} a SyntaxError is thrown if its UnaryExpression is a direct reference to a variable@comma{} function argument@comma{} or function name (@uref{#sec-11.4.1,11.4.1}).

@item
When a @code{delete} operator occurs within @uref{#sec-10.1.1,strict mode code}@comma{} a TypeError is thrown if the property to be deleted has the attribute @{ [[Configurable]]:false @} (@uref{#sec-11.4.1,11.4.1}).

@item
It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within @uref{#sec-10.1.1,strict code} and its Identifier is @code{eval} or @code{arguments} (@uref{#sec-12.2.1,12.2.1}).

@item


@item
It is a SyntaxError if a TryStatement with a Catch occurs within @uref{#sec-10.1.1,strict code} and the Identifier of the Catch production is @code{eval} or @code{arguments} (@uref{#sec-12.14.1,12.14.1})

@item
It is a SyntaxError if the identifier @code{eval} or @code{arguments} appears within a FormalParameterList of a strict mode FunctionDeclaration or FunctionExpression (@uref{#sec-13.1,13.1})

@item
A strict mode function may not have two or more formal parameters that have the same name. An attempt to create such a function using a FunctionDeclaration@comma{} FunctionExpression@comma{} or Function constructor is a SyntaxError (@uref{#sec-13.1,13.1}@comma{} @uref{#sec-15.3.2,15.3.2}).

@item
An implementation may not extend@comma{} beyond that defined in this specification@comma{} the meanings within strict mode functions of properties named @code{caller} or @code{arguments} of function instances. ECMAScript code may not create or modify properties with these names on function objects that correspond to strict mode functions (@uref{#sec-10.6,10.6}@comma{} @uref{#sec-13.2,13.2}@comma{} @uref{#sec-15.3.4.5.3,15.3.4.5.3}).

@item
It is a SyntaxError to use within @uref{#sec-10.1.1,strict mode code} the identifiers @code{eval} or @code{arguments} as the Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name (@uref{#sec-13.1,13.1}). Attempting to dynamically define such a strict mode function using the Function constructor (@uref{#sec-15.3.2,15.3.2}) will throw a SyntaxError exception.

@end itemize



@node Annex D informative Corrections and Clarifications in the 5th Edition with Possible 3rd Edition Compatibility Impact
@chapter Annex D (informative) Corrections and Clarifications in the 5th Edition with Possible 3rd Edition Compatibility Impact
Throughout: In the Edition 3 specification the meaning of phrases such as “as if by the expression @code{new Array()}” are subject to misinterpretation. In the Edition 5 specification text for all internal references and invocations of standard built-in objects and methods has been clarified by making it explicit that the intent is that the actual built-in object is to be used rather than the current dynamic value of the correspondingly named property.

@uref{#sec-11.8.2,11.8.2}@comma{} @uref{#sec-11.8.3,11.8.3}@comma{} @uref{#sec-11.8.5,11.8.5}: ECMAScript generally uses a left to right evaluation order@comma{} however the Edition 3 specification language for the @code{>} and @code{<=} operators resulted in a partial right to left order. The specification has been corrected for these operators such that it now specifies a full left to right evaluation order. However@comma{} this change of order is potentially observable if side-effects occur during the evaluation process.

@uref{#sec-11.1.4,11.1.4}: Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.

@uref{#sec-11.2.3,11.2.3}: Edition 5 reverses the order of steps 2 and 3 of the algorithm. The original order as specified in Editions 1 through 3 was incorrectly specified such that side-effects of evaluating Arguments could affect the result of evaluating MemberExpression.

@uref{#sec-12.4,12.4}: In Edition 3@comma{} an object is created@comma{} as if by @code{new Object()} to serve as the scope for resolving the name of the exception parameter passed to a @code{catch} clause of a @code{try} statement. If the actual exception object is a function and it is called from within the @code{catch} clause@comma{} the scope object will be passed as the @code{this} value of the call. The body of the function can then define new properties on its @code{this} value and those property names become visible identifiers bindings within the scope of the @code{catch} clause after the function returns. In Edition 5@comma{} when an exception parameter is called as a function@comma{} undefined is passed as the this value.

@uref{#sec-13,13}: In Edition 3@comma{} the algorithm for the production FunctionExpression with an Identifier adds an object created as if by @code{new Object()} to the scope chain to serve as a scope for looking up the name of the function. The identifier resolution rules (10.1.4 in Edition 3) when applied to such an object will@comma{} if necessary@comma{} follow the object’s prototype chain when attempting to resolve an identifier. This means all the properties of Object.prototype are visible as identifiers within that scope. In practice most implementations of Edition 3 have not implemented this semantics. Edition 5 changes the specified semantics by using a @uref{#sec-10.2.1.1,Declarative Environment Record} to bind the name of the function.

@uref{#sec-14,14}: In Edition 3@comma{} the algorithm for the production SourceElements : SourceElements SourceElement did not correctly propagate statement result values in the same manner as Block. This could result in the eval function producing an incorrect result when evaluating a Program text. In practice most implementations of Edition 3 have implemented the correct propagation rather than what was specified in Edition 3.

@uref{#sec-15.10.6,15.10.6}: RegExp.prototype is now a RegExp object rather than an instance of Object. The value of its [[Class]] internal property which is observable using Object.prototype.toString is now "RegExp" rather than "Object".




@node Annex E informative Additions and Changes in the 5th Edition that Introduce Incompatibilities with the 3rd Edition
@chapter Annex E (informative) Additions and Changes in the 5th Edition that Introduce Incompatibilities with the 3rd Edition
@uref{#sec-7.1,7.1}: Unicode format control characters are no longer stripped from ECMAScript source text before processing. In Edition 5@comma{} if such a character appears in a StringLiteral or RegularExpressionLiteral the character will be incorporated into the literal where in Edition 3 the character would not be incorporated into the literal.

@uref{#sec-7.2,7.2}: Unicode character <BOM> is now treated as whitespace and its presence in the middle of what appears to be an identifier could result in a syntax error which would not have occurred in Edition 3

@uref{#sec-7.3,7.3}: Line terminator characters that are preceded by an escape sequence are now allowed within a string literal token. In Edition 3 a syntax error would have been produced.

@uref{#sec-7.8.5,7.8.5}: Regular expression literals now return a unique object each time the literal is evaluated. This change is detectable by any programs that test the object identity of such literal values or that are sensitive to the shared side effects.

@uref{#sec-7.8.5,7.8.5}: Edition 5 requires early reporting of any possible RegExp constructor errors that would be produced when converting a RegularExpressionLiteral to a RegExp object. Prior to Edition 5 implementations were permitted to defer the reporting of such errors until the actual execution time creation of the object.

@uref{#sec-7.8.5,7.8.5}: In Edition 5 unescaped “@code{/}” characters may appear as a CharacterClass in a regular expression literal. In Edition 3 such a character would have been interpreted as the final character of the literal.

@uref{#sec-10.4.2,10.4.2}: In Edition 5@comma{} @uref{#sec-15.1.2.1.1,indirect calls} to @uref{#sec-15.1.2.1,the eval function} use the global environment as both the variable environment and @uref{#sec-10.2,lexical environment} for the @uref{#def-eval-code,eval code}. In Edition 3@comma{} the variable and lexical environments of the caller of an indirect eval was used as the environments for the @uref{#def-eval-code,eval code}.

@uref{#sec-15.4.4,15.4.4}: In Edition 5 all methods of @uref{#sec-15.4.4,Array.prototype} are intentionally generic. In Edition 3 toString and toLocaleString were not generic and would throw a TypeError exception if applied to objects that were not instances of Array.

@uref{#sec-10.6,10.6}: In Edition 5 the array indexed properties of argument objects that correspond to actual formal parameters are enumerable. In Edition 3@comma{} such properties were not enumerable.

@uref{#sec-10.6,10.6}: In Edition 5 the value of the [[Class]] internal property of an arguments object is "Arguments". In Edition 3@comma{} it was "Object". This is observable if toString is called as a method of an arguments object.

@uref{#sec-12.6.4,12.6.4}: for-in statements no longer throw a TypeError if the @code{in} expression evaluates to null or undefined. Instead@comma{} the statement behaves as if the value of the expression was an object with no enumerable properties.

@uref{#sec-15,15}: In Edition 5@comma{} the following new properties are defined on built-in objects that exist in Edition 3: @uref{#sec-15.2.3.2,Object.getPrototypeOf}@comma{} @uref{#sec-15.2.3.3,Object.getOwnPropertyDescriptor}@comma{} @uref{#sec-15.2.3.4,Object.getOwnPropertyNames}@comma{} @uref{#sec-15.2.3.5,Object.create}@comma{} @uref{#sec-15.2.3.6,Object.defineProperty}@comma{} @uref{#sec-15.2.3.7,Object.defineProperties}@comma{} @uref{#sec-15.2.3.8,Object.seal}@comma{} @uref{#sec-15.2.3.9,Object.freeze}@comma{} @uref{#sec-15.2.3.10,Object.preventExtensions}@comma{} @uref{#sec-15.2.3.11,Object.isSealed}@comma{} @uref{#sec-15.2.3.12,Object.isFrozen}@comma{} @uref{#sec-15.2.3.13,Object.isExtensible}@comma{} @uref{#sec-15.2.3.14,Object.keys}@comma{} @uref{#sec-15.3.4.5,Function.prototype.bind}@comma{} @uref{#sec-15.4.4.14,Array.prototype.indexOf}@comma{} @uref{#sec-15.4.4.15,Array.prototype.lastIndexOf}@comma{} @uref{#sec-15.4.4.16,Array.prototype.every}@comma{} @uref{#sec-15.4.4.17,Array.prototype.some}@comma{} @uref{#sec-15.4.4.18,Array.prototype.forEach}@comma{} @uref{#sec-15.4.4.19,Array.prototype.map}@comma{} @uref{#sec-15.4.4.20,Array.prototype.filter}@comma{} @uref{#sec-15.4.4.21,Array.prototype.reduce}@comma{} @uref{#sec-15.4.4.22,Array.prototype.reduceRight}@comma{} @uref{#sec-15.5.4.20,String.prototype.trim}@comma{} @uref{#sec-15.9.4.4,Date.now}@comma{} @uref{#sec-15.9.5.43,Date.prototype.toISOString}@comma{} @uref{#sec-15.9.5.44,Date.prototype.toJSON}.



@uref{#sec-15.1.1,15.1.1}: The value properties NaN@comma{} Infinity@comma{} and undefined of the Global Object have been changed to be read-only properties.

@uref{#sec-15.1.2.1,15.1.2.1}: Implementations are no longer permitted to restrict the use of eval in ways that are not a @uref{#sec-15.1.2.1.1,direct call}. In addition@comma{} any invocation of eval that is not a direct call uses @uref{#sec-10.2.3,the global environment} as its variable environment rather than the caller’s variable environment.

@uref{#sec-15.1.2.2,15.1.2.2}: The specification of the function parseInt no longer allows implementations to treat Strings beginning with a @code{0} character as octal values.

@uref{#sec-15.3.4.3,15.3.4.3}: In Edition 3@comma{} a TypeError is thrown if the second argument passed to Function.prototype.apply is neither an array object nor an arguments object. In Edition 5@comma{} the second argument may be any kind of generic array-like object that has a valid @code{length} property.

@uref{#sec-15.3.4.3,15.3.4.3}@comma{} @uref{#sec-15.3.4.4,15.3.4.4}: In Edition 3 passing undefined or null as the first argument to either Function.prototype.apply or Function.prototype.call causes the global object to be passed to the indirectly invoked target function as the this value. If the first argument is a primitive value the result of calling @uref{#sec-9.9,ToObject} on the primitive value is passed as the this value. In Edition 5@comma{} these transformations are not performed and the actual first argument value is passed as the this value. This difference will normally be unobservable to existing ECMAScript Edition 3 code because a corresponding transformation takes place upon activation of the target function. However@comma{} depending upon the implementation@comma{} this difference may be observable by host object functions called using apply or call. In addition@comma{} invoking a standard built-in function in this manner with null or undefined passed as the this value will in many cases cause behaviour in Edition 5 implementations that differ from Edition 3 behaviour. In particular@comma{} in Edition 5 built-in functions that are specified to actually use the passed this value as an object typically throw a TypeError exception if passed null or undefined as the this value.

@uref{#sec-15.3.5.2,15.3.5.2}: In Edition 5@comma{} the @code{prototype} property of Function instances is not enumerable. In Edition 3@comma{} this property was enumerable.

@uref{#sec-15.5.5.2,15.5.5.2}: In Edition 5@comma{} the individual characters of a String object’s [[PrimitiveValue] may be accessed as array indexed properties of the String object. These properties are non-writable and non-configurable and shadow any inherited properties with the same names. In Edition 3@comma{} these properties did not exist and ECMAScript code could dynamically add and remove writable properties with such names and could access inherited properties with such names.

@uref{#sec-15.9.4.2,15.9.4.2}: @uref{#sec-15.9.4.2,Date.parse} is now required to first attempt to parse its argument as an ISO format string. Programs that use this format but depended upon implementation specific behaviour (including failure) may behave differently.

@uref{#sec-15.10.2.12,15.10.2.12}: In Edition 5@comma{} @code{\s} now additionally matches <BOM>.

@uref{#sec-15.10.4.1,15.10.4.1}: In Edition 3@comma{} the exact form of the String value of the @code{source} property of an object created by the RegExp constructor is implementation defined. In Edition 5@comma{} the String must conform to @uref{#def-RegExp-source,certain specified requirements} and hence may be different from that produced by an Edition 3 implementation.

@uref{#sec-15.10.6.4,15.10.6.4}: In Edition 3@comma{} the result of @uref{#sec-15.10.6.4,RegExp.prototype.toString} need not be derived from the value of the RegExp object’s @code{source} property. In Edition 5 the result must be derived from the @code{source} property in a specified manner and hence may be different from the result produced by an Edition 3 implementation.

@uref{#sec-15.11.2.1,15.11.2.1}@comma{} @uref{#sec-15.11.4.3,15.11.4.3}: In Edition 5@comma{} if an initial value for the @code{message} property of an Error object is not specified via the Error constructor the initial value of the property is the empty String. In Edition 3@comma{} such an initial value is implementation defined.


@uref{#sec-15.11.4.4,15.11.4.4}: In Edition 3@comma{} the result of @uref{#sec-15.11.4.4,Error.prototype.toString} is implementation defined. In Edition 5@comma{} the result is fully specified and hence may differ from some Edition 3 implementations.

@uref{#sec-15.12,15.12}: In Edition 5@comma{} the name @uref{#sec-15.12,JSON} is defined in the @uref{#sec-10.2.3,global environment}. In Edition 3@comma{} testing for the presence of that name will show it to be undefined unless it is defined by the program or implementation.




@node Bibliography
@chapter Bibliography
@enumerate
@item
[1] ANSI/IEEE Std 754-1985: IEEE Standard for Binary Floating-Point Arithmetic. Institute of Electrical and Electronic Engineers@comma{} New York (1985)
@item
[2] The Unicode Consortium. The Unicode Standard@comma{} Version 3.0@comma{} defined by: The Unicode Standard@comma{} Version 3.0 (Boston@comma{} MA@comma{} Addison-Wesley@comma{} 2000. ISBN 0-201-61635-5)
@item
[3] Unicode Inc. (1998)@comma{} Unicode Technical Report #15: Unicode Normalization Forms
@end enumerate


@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
© Ecma International 2009
